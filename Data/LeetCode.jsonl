{"generated_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]\n            ) -> float:\n        m, n = len(nums1), len(nums2)\n        if n > m:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        i_min, i_max, half_len = 0, m, (n + m + 1) // 2\n        while i_min <= i_max:\n            i = (i_min + i_max) // 2\n            j = half_len - i\n            if m > i and nums2[j - 1] > nums1[i]:\n                i_min = i + 1\n            elif i > 0 and nums1[i - 1] > nums2[j]:\n                i_max = i - 1\n            else:\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n                if (n + m) % 2 == 1:\n                    return float(max_of_left)\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0", "watermarked_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]\n            ) ->float:\n        m, n = len(nums1), len(nums2)\n        if n > m:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        i_min, i_max, half_len = 0, m, (n + m + 1) // 2\n        while i_min <= i_max:\n            i = (i_min + i_max) // 2\n            j = half_len - i\n            if m > i and nums2[j - 1] > nums1[i]:\n                i_min = i + 1\n            elif i > 0 and nums1[i - 1] > nums2[j]:\n                i_max = i - 1\n            else:\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n                if (n + m) % 2 == 1:\n                    return float(max_of_left)\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0"}
{"generated_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]\n            ) -> float:\n        m, n = len(nums1), len(nums2)\n        if n > m:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        i_min, i_max, half_len = 0, m, (n + m + 1) // 2\n        while i_min <= i_max:\n            i = (i_min + i_max) // 2\n            j = half_len - i\n            if m > i and nums2[j - 1] > nums1[i]:\n                i_min = i + 1\n            elif i > 0 and nums1[i - 1] > nums2[j]:\n                i_max = i - 1\n            else:\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n                if (n + m) % 2 == 1:\n                    return float(max_of_left)\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0", "watermarked_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]\n            ) ->float:\n        m, n = len(nums1), len(nums2)\n        if n > m:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        i_min, i_max, half_len = 0, m, (n + m + 1) // 2\n        while i_min <= i_max:\n            i = (i_min + i_max) // 2\n            j = half_len - i\n            if m > i and nums2[j - 1] > nums1[i]:\n                i_min = i + 1\n            elif i > 0 and nums1[i - 1] > nums2[j]:\n                i_max = i - 1\n            else:\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n                if (n + m) % 2 == 1:\n                    return float(max_of_left)\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0"}
{"generated_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]\n            ) -> float:\n        m, n = len(nums1), len(nums2)\n        if n > m:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        i_min, i_max, half_len = 0, m, (n + m + 1) // 2\n        while i_min <= i_max:\n            i = (i_min + i_max) // 2\n            j = half_len - i\n            if m > i and nums2[j - 1] > nums1[i]:\n                i_min = i + 1\n            elif i > 0 and nums1[i - 1] > nums2[j]:\n                i_max = i - 1\n            else:\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n                if (n + m) % 2 == 1:\n                    return float(max_of_left)\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0", "watermarked_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]\n            ) ->float:\n        m, n = len(nums1), len(nums2)\n        if n > m:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        i_min, i_max, half_len = 0, m, (n + m + 1) // 2\n        while i_min <= i_max:\n            i = (i_min + i_max) // 2\n            j = half_len - i\n            if m > i and nums2[j - 1] > nums1[i]:\n                i_min = i + 1\n            elif i > 0 and nums1[i - 1] > nums2[j]:\n                i_max = i - 1\n            else:\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n                if (n + m) % 2 == 1:\n                    return float(max_of_left)\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0"}
{"generated_code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for char in s:\n            if char in ['(', '[', '{']:\n                stack.append(char)\n            else:\n                if not stack:\n                    return False\n                if char == ')':\n                    if stack[-1] == '(':\n                        stack.pop()\n                    else:\n                        return False\n                elif char == ']':\n                    if stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n                elif char == '}':\n                    if stack[-1] == '{':\n                        stack.pop()\n                    else:\n                        return False\n        return not stack", "watermarked_code": "class Solution:\n    def isValid(self, s: str) ->bool:\n        stack = []\n        for char in s:\n            if char in ['(', '[', '{']:\n                stack.append(char)\n            else:\n                if not stack:\n                    return False\n                if char == ')':\n                    if stack[-1] == '(':\n                        stack.pop()\n                    else:\n                        return False\n                elif char == ']':\n                    if stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n                elif char == '}':\n                    if stack[-1] == '{':\n                        stack.pop()\n                    else:\n                        return False\n        return not stack"}
{"generated_code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for letter in s:\n            if letter == 'a':\n                stack.append('a')\n            elif letter == 'b':\n                if stack and stack[-1] == 'a':\n                    stack[-1] = 'ab'\n                else:\n                    return False\n            elif stack and stack[-1] == 'ab':\n                stack.pop()\n            else:\n                return False\n        return not stack", "watermarked_code": "class Solution:\n    def isValid(self, s: str) ->bool:\n        stack = []\n        for letter in s:\n            if letter == 'a':\n                stack.append('a')\n            elif letter == 'b':\n                if stack and stack[-1] == 'a':\n                    stack[-1] = 'ab'\n                else:\n                    return False\n            elif stack and stack[-1] == 'ab':\n                stack.pop()\n            else:\n                return False\n        return not stack"}
{"generated_code": "from typing import List\nclass Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        n = len(costs) // 2\n        costs.sort(key=lambda x: x[0] - x[1])\n        return sum(costs[i][0] + costs[n + i][1] for i in range(n))", "watermarked_code": "from typing import List\nclass Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) ->int:\n        n = len(costs) // 2\n        costs.sort(key=lambda x: x[0] - x[1])\n        return sum(costs[i][0] + costs[n + i][1] for i in range(n))"}
{"generated_code": "from typing import List\nclass Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        n = len(costs) // 2\n        costs.sort(key=lambda x: x[0] - x[1])\n        return sum(costs[i][0] + costs[n + i][1] for i in range(n))", "watermarked_code": "from typing import List\nclass Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) ->int:\n        n = len(costs) // 2\n        costs.sort(key=lambda x: x[0] - x[1])\n        return sum(costs[i][0] + costs[n + i][1] for i in range(n))"}
{"generated_code": "from typing import List, Optional\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if root is None:\n            return []\n        res = []\n        level = 0\n        q = [root]\n        while q:\n            size = len(q)\n            level_list = []\n            for _ in range(size):\n                curr_node = q.pop(0)\n                if level % 2 == 1:\n                    level_list.append(curr_node.val)\n                else:\n                    level_list.insert(0, curr_node.val)\n                if curr_node.left:\n                    q.append(curr_node.left)\n                if curr_node.right:\n                    q.append(curr_node.right)\n            res.append(level_list)\n            level += 1\n        return res", "watermarked_code": "from typing import List, Optional\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) ->List[List[int]]:\n        if root is None:\n            return []\n        res = []\n        level = 0\n        q = [root]\n        while q:\n            size = len(q)\n            level_list = []\n            for _ in range(size):\n                curr_node = q.pop(0)\n                if level % 2 == 1:\n                    level_list.append(curr_node.val)\n                else:\n                    level_list.insert(0, curr_node.val)\n                if curr_node.left:\n                    q.append(curr_node.left)\n                if curr_node.right:\n                    q.append(curr_node.right)\n            res.append(level_list)\n            level += 1\n        return res"}
{"generated_code": "from typing import List\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int],\n            target: List[int]) -> bool:\n        def bfs(start, end):\n            queue = [start]\n            visited = set()\n            while queue:\n                x, y = queue.pop(0)\n                if [x, y] == end:\n                    return True\n                visited.add((x, y))\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < limit and 0 <= ny < limit and (nx, ny\n                            ) not in visited and [nx, ny] not in blocked:\n                        queue.append([nx, ny])\n                        visited.add((nx, ny))\n                if len(visited) >= limit ** 2 - len(blocked):\n                    return True\n            return False\n        limit = 10 ** 6\n        if not blocked:\n            return True\n        return True if bfs(source, target) else bool(bfs(target, source))", "watermarked_code": "from typing import List\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int],\n            target: List[int]) ->bool:\n        def bfs(start, end):\n            queue = [start]\n            visited = set()\n            while queue:\n                x, y = queue.pop(0)\n                if [x, y] == end:\n                    return True\n                visited.add((x, y))\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < limit and 0 <= ny < limit and (nx, ny\n                            ) not in visited and [nx, ny] not in blocked:\n                        queue.append([nx, ny])\n                        visited.add((nx, ny))\n                if len(visited) >= limit ** 2 - len(blocked):\n                    return True\n            return False\n        limit = 10 ** 6\n        if not blocked:\n            return True\n        return True if bfs(source, target) else bool(bfs(target, source))"}
{"generated_code": "from typing import List\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int],\n            target: List[int]) -> bool:\n        def bfs(start, end):\n            queue = [start]\n            visited = set()\n            while queue:\n                x, y = queue.pop(0)\n                if [x, y] == end:\n                    return True\n                visited.add((x, y))\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < limit and 0 <= ny < limit and (nx, ny\n                            ) not in visited and [nx, ny] not in blocked:\n                        queue.append([nx, ny])\n                        visited.add((nx, ny))\n                if len(visited) >= limit ** 2 - len(blocked):\n                    return True\n            return False\n        limit = 10 ** 6\n        if not blocked:\n            return True\n        return True if bfs(source, target) else bool(bfs(target, source))", "watermarked_code": "from typing import List\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int],\n            target: List[int]) ->bool:\n        def bfs(start, end):\n            queue = [start]\n            visited = set()\n            while queue:\n                x, y = queue.pop(0)\n                if [x, y] == end:\n                    return True\n                visited.add((x, y))\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < limit and 0 <= ny < limit and (nx, ny\n                            ) not in visited and [nx, ny] not in blocked:\n                        queue.append([nx, ny])\n                        visited.add((nx, ny))\n                if len(visited) >= limit ** 2 - len(blocked):\n                    return True\n            return False\n        limit = 10 ** 6\n        if not blocked:\n            return True\n        return True if bfs(source, target) else bool(bfs(target, source))"}
{"generated_code": "class Solution:\n    def isBoomerang(self, points: List[List[int]]) -> bool:\n        if points[0] == points[1] or points[0] == points[2] or points[1\n                ] == points[2]:\n            return False\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]\n            ) != (points[2][1] - points[1][1]) * (points[1][0] - points[0][0])", "watermarked_code": "class Solution:\n    def isBoomerang(self, points: List[List[int]]) ->bool:\n        if points[0] == points[1] or points[0] == points[2] or points[1\n                ] == points[2]:\n            return False\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]\n            ) != (points[2][1] - points[1][1]) * (points[1][0] - points[0][0])"}
{"generated_code": "class Solution:\n    def isBoomerang(self, points: List[List[int]]) -> bool:\n        if points[0] == points[1] or points[0] == points[2] or points[1\n                ] == points[2]:\n            return False\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]\n            ) != (points[2][1] - points[1][1]) * (points[1][0] - points[0][0])", "watermarked_code": "class Solution:\n    def isBoomerang(self, points: List[List[int]]) ->bool:\n        if points[0] == points[1] or points[0] == points[2] or points[1\n                ] == points[2]:\n            return False\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]\n            ) != (points[2][1] - points[1][1]) * (points[1][0] - points[0][0])"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes:\n            int) -> int:\n        satisfied_customers = sum(customers[i] for i in range(len(customers\n            )) if grumpy[i] == 0)\n        max_satisfied_customers = 0\n        current_satisfied_customers = 0\n        left = 0\n        for i in range(len(customers)):\n            if grumpy[i] == 1:\n                current_satisfied_customers += customers[i]\n            if i - left + 1 > minutes:\n                if grumpy[left] == 1:\n                    current_satisfied_customers -= customers[left]\n                left += 1\n            max_satisfied_customers = max(max_satisfied_customers,\n                current_satisfied_customers)\n        return max_satisfied_customers + satisfied_customers", "watermarked_code": "from typing import List\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes:\n            int) ->int:\n        satisfied_customers = sum(customers[i] for i in range(len(customers\n            )) if grumpy[i] == 0)\n        max_satisfied_customers = 0\n        current_satisfied_customers = 0\n        left = 0\n        for i in range(len(customers)):\n            if grumpy[i] == 1:\n                current_satisfied_customers += customers[i]\n            if i - left + 1 > minutes:\n                if grumpy[left] == 1:\n                    current_satisfied_customers -= customers[left]\n                left += 1\n            max_satisfied_customers = max(max_satisfied_customers,\n                current_satisfied_customers)\n        return max_satisfied_customers + satisfied_customers"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes:\n            int) -> int:\n        satisfied_customers = sum(customers[i] for i in range(len(customers\n            )) if grumpy[i] == 0)\n        max_satisfied_customers = 0\n        current_satisfied_customers = 0\n        left = 0\n        for i in range(len(customers)):\n            if grumpy[i] == 1:\n                current_satisfied_customers += customers[i]\n            if i - left + 1 > minutes:\n                if grumpy[left] == 1:\n                    current_satisfied_customers -= customers[left]\n                left += 1\n            max_satisfied_customers = max(max_satisfied_customers,\n                current_satisfied_customers)\n        return max_satisfied_customers + satisfied_customers", "watermarked_code": "from typing import List\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes:\n            int) ->int:\n        satisfied_customers = sum(customers[i] for i in range(len(customers\n            )) if grumpy[i] == 0)\n        max_satisfied_customers = 0\n        current_satisfied_customers = 0\n        left = 0\n        for i in range(len(customers)):\n            if grumpy[i] == 1:\n                current_satisfied_customers += customers[i]\n            if i - left + 1 > minutes:\n                if grumpy[left] == 1:\n                    current_satisfied_customers -= customers[left]\n                left += 1\n            max_satisfied_customers = max(max_satisfied_customers,\n                current_satisfied_customers)\n        return max_satisfied_customers + satisfied_customers"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes:\n            int) -> int:\n        satisfied_customers = sum(customers[i] for i in range(len(customers\n            )) if grumpy[i] == 0)\n        max_satisfied_customers = 0\n        current_satisfied_customers = 0\n        left = 0\n        for i in range(len(customers)):\n            if grumpy[i] == 1:\n                current_satisfied_customers += customers[i]\n            if i - left + 1 > minutes:\n                if grumpy[left] == 1:\n                    current_satisfied_customers -= customers[left]\n                left += 1\n            max_satisfied_customers = max(max_satisfied_customers,\n                current_satisfied_customers)\n        return max_satisfied_customers + satisfied_customers", "watermarked_code": "from typing import List\nclass Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes:\n            int) ->int:\n        satisfied_customers = sum(customers[i] for i in range(len(customers\n            )) if grumpy[i] == 0)\n        max_satisfied_customers = 0\n        current_satisfied_customers = 0\n        left = 0\n        for i in range(len(customers)):\n            if grumpy[i] == 1:\n                current_satisfied_customers += customers[i]\n            if i - left + 1 > minutes:\n                if grumpy[left] == 1:\n                    current_satisfied_customers -= customers[left]\n                left += 1\n            max_satisfied_customers = max(max_satisfied_customers,\n                current_satisfied_customers)\n        return max_satisfied_customers + satisfied_customers"}
{"generated_code": "class Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray'\n            ) -> int:\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            mid_val = mountain_arr.get(mid)\n            left_val = -float('inf') if mid == 0 else mountain_arr.get(mid - 1)\n            right_val = -float('inf') if mid == n - 1 else mountain_arr.get(\n                mid + 1)\n            if mid_val > left_val and mid_val > right_val:\n                peak = mid\n                break\n            elif mid_val > left_val < right_val:\n                l = mid + 1\n            else:\n                r = mid - 1\n        l, r = 0, peak\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        l, r = peak, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1", "watermarked_code": "class Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray'\n            ) ->int:\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            mid_val = mountain_arr.get(mid)\n            left_val = -float('inf') if mid == 0 else mountain_arr.get(mid - 1)\n            right_val = -float('inf') if mid == n - 1 else mountain_arr.get(\n                mid + 1)\n            if mid_val > left_val and mid_val > right_val:\n                peak = mid\n                break\n            elif mid_val > left_val < right_val:\n                l = mid + 1\n            else:\n                r = mid - 1\n        l, r = 0, peak\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        l, r = peak, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1"}
{"generated_code": "class Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray'\n            ) -> int:\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            mid_val = mountain_arr.get(mid)\n            left_val = -float('inf') if mid == 0 else mountain_arr.get(mid - 1)\n            right_val = -float('inf') if mid == n - 1 else mountain_arr.get(\n                mid + 1)\n            if mid_val > left_val and mid_val > right_val:\n                peak = mid\n                break\n            elif mid_val > left_val < right_val:\n                l = mid + 1\n            else:\n                r = mid - 1\n        l, r = 0, peak\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        l, r = peak, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1", "watermarked_code": "class Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray'\n            ) ->int:\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            mid_val = mountain_arr.get(mid)\n            left_val = -float('inf') if mid == 0 else mountain_arr.get(mid - 1)\n            right_val = -float('inf') if mid == n - 1 else mountain_arr.get(\n                mid + 1)\n            if mid_val > left_val and mid_val > right_val:\n                peak = mid\n                break\n            elif mid_val > left_val < right_val:\n                l = mid + 1\n            else:\n                r = mid - 1\n        l, r = 0, peak\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        l, r = peak, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1"}
{"generated_code": "class Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray'\n            ) -> int:\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            mid_val = mountain_arr.get(mid)\n            left_val = -float('inf') if mid == 0 else mountain_arr.get(mid - 1)\n            right_val = -float('inf') if mid == n - 1 else mountain_arr.get(\n                mid + 1)\n            if mid_val > left_val and mid_val > right_val:\n                peak = mid\n                break\n            elif mid_val > left_val < right_val:\n                l = mid + 1\n            else:\n                r = mid - 1\n        l, r = 0, peak\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        l, r = peak, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1", "watermarked_code": "class Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray'\n            ) ->int:\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            mid_val = mountain_arr.get(mid)\n            left_val = -float('inf') if mid == 0 else mountain_arr.get(mid - 1)\n            right_val = -float('inf') if mid == n - 1 else mountain_arr.get(\n                mid + 1)\n            if mid_val > left_val and mid_val > right_val:\n                peak = mid\n                break\n            elif mid_val > left_val < right_val:\n                l = mid + 1\n            else:\n                r = mid - 1\n        l, r = 0, peak\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        l, r = peak, n - 1\n        while r >= l:\n            mid = (r + l) // 2\n            if mountain_arr.get(mid) == target:\n                return mid\n            elif mountain_arr.get(mid) > target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1"}
{"generated_code": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [([0] * m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if i == 0 else min(dp[i][j], dp[i - 1][j] + 1)\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for x in range(dp[i][j], 0, -1):\n                    if x + i - 1 >= n or j + x - 1 >= m:\n                        continue\n                    if dp[x + i - 1][j] >= x and dp[x + i - 1][j + x - 1\n                            ] >= x and dp[i][j + x - 1] >= x:\n                        res = max(res, x * x)\n                        break\n        return res", "watermarked_code": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) ->int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [([0] * m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if i == 0 else min(dp[i][j], dp[i - 1][j] + 1)\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for x in range(dp[i][j], 0, -1):\n                    if x + i - 1 >= n or j + x - 1 >= m:\n                        continue\n                    if dp[x + i - 1][j] >= x and dp[x + i - 1][j + x - 1\n                            ] >= x and dp[i][j + x - 1] >= x:\n                        res = max(res, x * x)\n                        break\n        return res"}
{"generated_code": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [([0] * m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if i == 0 else min(dp[i][j], dp[i - 1][j] + 1)\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for x in range(dp[i][j], 0, -1):\n                    if x + i - 1 >= n or j + x - 1 >= m:\n                        continue\n                    if dp[x + i - 1][j] >= x and dp[x + i - 1][j + x - 1\n                            ] >= x and dp[i][j + x - 1] >= x:\n                        res = max(res, x * x)\n                        break\n        return res", "watermarked_code": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) ->int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [([0] * m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if i == 0 else min(dp[i][j], dp[i - 1][j] + 1)\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for x in range(dp[i][j], 0, -1):\n                    if x + i - 1 >= n or j + x - 1 >= m:\n                        continue\n                    if dp[x + i - 1][j] >= x and dp[x + i - 1][j + x - 1\n                            ] >= x and dp[i][j + x - 1] >= x:\n                        res = max(res, x * x)\n                        break\n        return res"}
{"generated_code": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [([0] * m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if i == 0 else min(dp[i][j], dp[i - 1][j] + 1)\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for x in range(dp[i][j], 0, -1):\n                    if x + i - 1 >= n or j + x - 1 >= m:\n                        continue\n                    if dp[x + i - 1][j] >= x and dp[x + i - 1][j + x - 1\n                            ] >= x and dp[i][j + x - 1] >= x:\n                        res = max(res, x * x)\n                        break\n        return res", "watermarked_code": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) ->int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [([0] * m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1 if i == 0 else min(dp[i][j], dp[i - 1][j] + 1)\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for x in range(dp[i][j], 0, -1):\n                    if x + i - 1 >= n or j + x - 1 >= m:\n                        continue\n                    if dp[x + i - 1][j] >= x and dp[x + i - 1][j + x - 1\n                            ] >= x and dp[i][j + x - 1] >= x:\n                        res = max(res, x * x)\n                        break\n        return res"}
{"generated_code": "from typing import List\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List\n            [List[int]]) -> List[int]:\n        items_graph = [[] for _ in range(n + m)]\n        items_indegree = [0] * (n + m)\n        groups_graph = [[] for _ in range(m)]\n        groups_indegree = [0] * m\n        for i in range(n):\n            if group[i] != -1:\n                items_graph[i].append(n + group[i])\n                items_indegree[n + group[i]] += 1\n                groups_graph[group[i]].append(i)\n                groups_indegree[group[i]] += 1\n            for j in beforeItems[i]:\n                items_graph[j].append(i)\n                items_indegree[i] += 1\n        items_order = self.topologicalSort(items_graph, items_indegree, n + m)\n        groups_order = self.topologicalSort(groups_graph, groups_indegree, m)\n        if not items_order or not groups_order:\n            return []\n        items_positions = {}\n        for i, item in enumerate(items_order):\n            items_positions[item] = i\n        sorted_items = []\n        for group_id in groups_order:\n            group_items = [i for i in groups_graph[group_id] if i in\n                items_positions]\n            group_items.sort(key=lambda x: items_positions[x])\n            sorted_items.extend(group_items)\n        return sorted_items\n    def topologicalSort(self, graph: List[List[int]], indegree: List[int],\n            n: int) -> List[int]:\n        queue = [i for i in range(n) if indegree[i] == 0]\n        order = []\n        while queue:\n            curr_node = queue.pop(0)\n            order.append(curr_node)\n            for neighbor in graph[curr_node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return order if len(order) == n else []", "watermarked_code": "from typing import List\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List\n            [List[int]]) ->List[int]:\n        items_graph = [[] for _ in range(n + m)]\n        items_indegree = [0] * (n + m)\n        groups_graph = [[] for _ in range(m)]\n        groups_indegree = [0] * m\n        for i in range(n):\n            if group[i] != -1:\n                items_graph[i].append(n + group[i])\n                items_indegree[n + group[i]] += 1\n                groups_graph[group[i]].append(i)\n                groups_indegree[group[i]] += 1\n            for j in beforeItems[i]:\n                items_graph[j].append(i)\n                items_indegree[i] += 1\n        items_order = self.topologicalSort(items_graph, items_indegree, n + m)\n        groups_order = self.topologicalSort(groups_graph, groups_indegree, m)\n        if not items_order or not groups_order:\n            return []\n        items_positions = {item: i for i, item in enumerate(items_order)}\n        sorted_items = []\n        for group_id in groups_order:\n            group_items = [i for i in groups_graph[group_id] if i in\n                items_positions]\n            group_items.sort(key=lambda x: items_positions[x])\n            sorted_items.extend(group_items)\n        return sorted_items\n    def topologicalSort(self, graph: List[List[int]], indegree: List[int],\n            n: int) ->List[int]:\n        queue = [i for i in range(n) if indegree[i] == 0]\n        order = []\n        while queue:\n            curr_node = queue.pop(0)\n            order.append(curr_node)\n            for neighbor in graph[curr_node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return order if len(order) == n else []"}
{"generated_code": "from typing import List\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List\n            [List[int]]) -> List[int]:\n        items_graph = [[] for _ in range(n + m)]\n        items_indegree = [0] * (n + m)\n        groups_graph = [[] for _ in range(m)]\n        groups_indegree = [0] * m\n        for i in range(n):\n            if group[i] != -1:\n                items_graph[i].append(n + group[i])\n                items_indegree[n + group[i]] += 1\n                groups_graph[group[i]].append(i)\n                groups_indegree[group[i]] += 1\n            for j in beforeItems[i]:\n                items_graph[j].append(i)\n                items_indegree[i] += 1\n        items_order = self.topologicalSort(items_graph, items_indegree, n + m)\n        groups_order = self.topologicalSort(groups_graph, groups_indegree, m)\n        if not items_order or not groups_order:\n            return []\n        items_positions = {}\n        for i, item in enumerate(items_order):\n            items_positions[item] = i\n        sorted_items = []\n        for group_id in groups_order:\n            group_items = [i for i in groups_graph[group_id] if i in\n                items_positions]\n            group_items.sort(key=lambda x: items_positions[x])\n            sorted_items.extend(group_items)\n        return sorted_items\n    def topologicalSort(self, graph: List[List[int]], indegree: List[int],\n            n: int) -> List[int]:\n        queue = [i for i in range(n) if indegree[i] == 0]\n        order = []\n        while queue:\n            curr_node = queue.pop(0)\n            order.append(curr_node)\n            for neighbor in graph[curr_node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return order if len(order) == n else []", "watermarked_code": "from typing import List\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List\n            [List[int]]) ->List[int]:\n        items_graph = [[] for _ in range(n + m)]\n        items_indegree = [0] * (n + m)\n        groups_graph = [[] for _ in range(m)]\n        groups_indegree = [0] * m\n        for i in range(n):\n            if group[i] != -1:\n                items_graph[i].append(n + group[i])\n                items_indegree[n + group[i]] += 1\n                groups_graph[group[i]].append(i)\n                groups_indegree[group[i]] += 1\n            for j in beforeItems[i]:\n                items_graph[j].append(i)\n                items_indegree[i] += 1\n        items_order = self.topologicalSort(items_graph, items_indegree, n + m)\n        groups_order = self.topologicalSort(groups_graph, groups_indegree, m)\n        if not items_order or not groups_order:\n            return []\n        items_positions = {item: i for i, item in enumerate(items_order)}\n        sorted_items = []\n        for group_id in groups_order:\n            group_items = [i for i in groups_graph[group_id] if i in\n                items_positions]\n            group_items.sort(key=lambda x: items_positions[x])\n            sorted_items.extend(group_items)\n        return sorted_items\n    def topologicalSort(self, graph: List[List[int]], indegree: List[int],\n            n: int) ->List[int]:\n        queue = [i for i in range(n) if indegree[i] == 0]\n        order = []\n        while queue:\n            curr_node = queue.pop(0)\n            order.append(curr_node)\n            for neighbor in graph[curr_node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return order if len(order) == n else []"}
{"generated_code": "class Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d = {}\n        for num in arr:\n            if num not in d:\n                d[num] = 1\n            else:\n                d[num] += 1\n        occurrences = list(d.values())\n        return len(occurrences) == len(set(occurrences))", "watermarked_code": "class Solution:\n    def uniqueOccurrences(self, arr: List[int]) ->bool:\n        d = {}\n        for num in arr:\n            if num not in d:\n                d[num] = 1\n            else:\n                d[num] += 1\n        occurrences = list(d.values())\n        return len(occurrences) == len(set(occurrences))"}
{"generated_code": "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        odd_indices = [-1]\n        odd_indices.extend(i for i, num in enumerate(nums) if num % 2 == 1)\n        odd_indices.append(len(nums))\n        num_odd = len(odd_indices) - 2\n        if k > num_odd:\n            return 0\n        count = 0\n        for i in range(1, num_odd - k + 2):\n            left = odd_indices[i] - odd_indices[i - 1]\n            right = odd_indices[k + i - 1] - odd_indices[k + i - 2]\n            count += right * left\n        return count", "watermarked_code": "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) ->int:\n        odd_indices = [-1]\n        odd_indices.extend(i for i, num in enumerate(nums) if num % 2 == 1)\n        odd_indices.append(len(nums))\n        num_odd = len(odd_indices) - 2\n        if k > num_odd:\n            return 0\n        count = 0\n        for i in range(1, num_odd - k + 2):\n            left = odd_indices[i] - odd_indices[i - 1]\n            right = odd_indices[k + i - 1] - odd_indices[k + i - 2]\n            count += right * left\n        return count"}
{"generated_code": "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        odd_indices = [-1]\n        odd_indices.extend(i for i, num in enumerate(nums) if num % 2 == 1)\n        odd_indices.append(len(nums))\n        num_odd = len(odd_indices) - 2\n        if k > num_odd:\n            return 0\n        count = 0\n        for i in range(1, num_odd - k + 2):\n            left = odd_indices[i] - odd_indices[i - 1]\n            right = odd_indices[k + i - 1] - odd_indices[k + i - 2]\n            count += right * left\n        return count", "watermarked_code": "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) ->int:\n        odd_indices = [-1]\n        odd_indices.extend(i for i, num in enumerate(nums) if num % 2 == 1)\n        odd_indices.append(len(nums))\n        num_odd = len(odd_indices) - 2\n        if k > num_odd:\n            return 0\n        count = 0\n        for i in range(1, num_odd - k + 2):\n            left = odd_indices[i] - odd_indices[i - 1]\n            right = odd_indices[k + i - 1] - odd_indices[k + i - 2]\n            count += right * left\n        return count"}
{"generated_code": "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        invalid_indices = set()\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            elif char == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    invalid_indices.add(i)\n        invalid_indices |= set(stack)\n        return ''.join(char for i, char in enumerate(s) if i not in\n            invalid_indices)", "watermarked_code": "class Solution:\n    def minRemoveToMakeValid(self, s: str) ->str:\n        stack = []\n        invalid_indices = set()\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            elif char == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    invalid_indices.add(i)\n        invalid_indices |= set(stack)\n        return ''.join(char for i, char in enumerate(s) if i not in\n            invalid_indices)"}
{"generated_code": "class Solution:\n    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]\n            ) -> List[List[int]]:\n        n = len(colsum)\n        matrix = [([0] * n) for _ in range(2)]\n        for i in range(n):\n            if colsum[i] == 2:\n                matrix[0][i] = 1\n                matrix[1][i] = 1\n                upper -= 1\n                lower -= 1\n        if upper < 0 or lower < 0:\n            return []\n        for i in range(n):\n            if colsum[i] == 1:\n                if upper > 0:\n                    matrix[0][i] = 1\n                    upper -= 1\n                else:\n                    matrix[1][i] = 1\n                    lower -= 1\n        return [] if upper != 0 or lower != 0 else matrix", "watermarked_code": "class Solution:\n    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]\n            ) ->List[List[int]]:\n        n = len(colsum)\n        matrix = [([0] * n) for _ in range(2)]\n        for i in range(n):\n            if colsum[i] == 2:\n                matrix[0][i] = 1\n                matrix[1][i] = 1\n                upper -= 1\n                lower -= 1\n        if upper < 0 or lower < 0:\n            return []\n        for i in range(n):\n            if colsum[i] == 1:\n                if upper > 0:\n                    matrix[0][i] = 1\n                    upper -= 1\n                else:\n                    matrix[1][i] = 1\n                    lower -= 1\n        return [] if upper != 0 or lower != 0 else matrix"}
{"generated_code": "class Solution:\n    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]\n            ) -> List[List[int]]:\n        n = len(colsum)\n        matrix = [([0] * n) for _ in range(2)]\n        for i in range(n):\n            if colsum[i] == 2:\n                matrix[0][i] = 1\n                matrix[1][i] = 1\n                upper -= 1\n                lower -= 1\n        if upper < 0 or lower < 0:\n            return []\n        for i in range(n):\n            if colsum[i] == 1:\n                if upper > 0:\n                    matrix[0][i] = 1\n                    upper -= 1\n                else:\n                    matrix[1][i] = 1\n                    lower -= 1\n        return [] if upper != 0 or lower != 0 else matrix", "watermarked_code": "class Solution:\n    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]\n            ) ->List[List[int]]:\n        n = len(colsum)\n        matrix = [([0] * n) for _ in range(2)]\n        for i in range(n):\n            if colsum[i] == 2:\n                matrix[0][i] = 1\n                matrix[1][i] = 1\n                upper -= 1\n                lower -= 1\n        if upper < 0 or lower < 0:\n            return []\n        for i in range(n):\n            if colsum[i] == 1:\n                if upper > 0:\n                    matrix[0][i] = 1\n                    upper -= 1\n                else:\n                    matrix[1][i] = 1\n                    lower -= 1\n        return [] if upper != 0 or lower != 0 else matrix"}
{"generated_code": "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        total_sum = sum(nums)\n        if total_sum % 3 != 0:\n            remainders = sorted([(num % 3) for num in nums])\n            if (total_sum % 3 == 1 and 1 in remainders or total_sum % 3 != \n                1 and total_sum % 3 == 2 and 2 in remainders):\n                total_sum -= remainders[0]\n            elif total_sum % 3 in [1, 2]:\n                total_sum -= sum(remainders[:2])\n        return total_sum", "watermarked_code": "class Solution:\n    def maxSumDivThree(self, nums: List[int]) ->int:\n        total_sum = sum(nums)\n        if total_sum % 3 != 0:\n            remainders = sorted([(num % 3) for num in nums])\n            if (total_sum % 3 == 1 and 1 in remainders or total_sum % 3 != \n                1 and total_sum % 3 == 2 and 2 in remainders):\n                total_sum -= remainders[0]\n            elif total_sum % 3 in [1, 2]:\n                total_sum -= sum(remainders[:2])\n        return total_sum"}
{"generated_code": "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        squares = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    squares += 1\n                    size = 2\n                    while size + i - 1 < m and j + size - 1 < n:\n                        flag = all(matrix[k][j + size - 1] != 0 for k in\n                            range(i, size + i))\n                        if flag:\n                            for k in range(j, j + size - 1):\n                                if matrix[size + i - 1][k] == 0:\n                                    flag = False\n                                    break\n                        if flag:\n                            squares += 1\n                            size += 1\n                        else:\n                            break\n        return squares", "watermarked_code": "class Solution:\n    def countSquares(self, matrix: List[List[int]]) ->int:\n        m, n = len(matrix), len(matrix[0])\n        squares = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    squares += 1\n                    size = 2\n                    while size + i - 1 < m and j + size - 1 < n:\n                        flag = all(matrix[k][j + size - 1] != 0 for k in\n                            range(i, size + i))\n                        if flag:\n                            for k in range(j, j + size - 1):\n                                if matrix[size + i - 1][k] == 0:\n                                    flag = False\n                                    break\n                        if flag:\n                            squares += 1\n                            size += 1\n                        else:\n                            break\n        return squares"}
{"generated_code": "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        squares = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    squares += 1\n                    size = 2\n                    while size + i - 1 < m and j + size - 1 < n:\n                        flag = all(matrix[k][j + size - 1] != 0 for k in\n                            range(i, size + i))\n                        if flag:\n                            for k in range(j, j + size - 1):\n                                if matrix[size + i - 1][k] == 0:\n                                    flag = False\n                                    break\n                        if flag:\n                            squares += 1\n                            size += 1\n                        else:\n                            break\n        return squares", "watermarked_code": "class Solution:\n    def countSquares(self, matrix: List[List[int]]) ->int:\n        m, n = len(matrix), len(matrix[0])\n        squares = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    squares += 1\n                    size = 2\n                    while size + i - 1 < m and j + size - 1 < n:\n                        flag = all(matrix[k][j + size - 1] != 0 for k in\n                            range(i, size + i))\n                        if flag:\n                            for k in range(j, j + size - 1):\n                                if matrix[size + i - 1][k] == 0:\n                                    flag = False\n                                    break\n                        if flag:\n                            squares += 1\n                            size += 1\n                        else:\n                            break\n        return squares"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        rows = len(mat)\n        cols = len(mat[0])\n        for i in range(rows):\n            for j in range(cols - 1):\n                mat[i][j + 1] += mat[i][j]\n        for j in range(cols):\n            for i in range(rows - 1):\n                mat[i + 1][j] += mat[i][j]\n        left, right, res = 0, min(rows, cols), 0\n        while right >= left:\n            mid = (right + left) // 2\n            if self.check(mat, threshold, mid):\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n    def check(self, mat: List[List[int]], threshold: int, k: int) -> bool:\n        rows = len(mat) - k\n        cols = len(mat[0]) - k\n        for i in range(rows):\n            for j in range(cols):\n                if mat[k + i][j + k] - mat[i][j + k] - mat[k + i][j] + mat[i][j\n                        ] <= threshold:\n                    return True\n        return False", "watermarked_code": "from typing import List\nclass Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) ->int:\n        rows = len(mat)\n        cols = len(mat[0])\n        for i in range(rows):\n            for j in range(cols - 1):\n                mat[i][j + 1] += mat[i][j]\n        for j in range(cols):\n            for i in range(rows - 1):\n                mat[i + 1][j] += mat[i][j]\n        left, right, res = 0, min(rows, cols), 0\n        while right >= left:\n            mid = (right + left) // 2\n            if self.check(mat, threshold, mid):\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n    def check(self, mat: List[List[int]], threshold: int, k: int) ->bool:\n        rows = len(mat) - k\n        cols = len(mat[0]) - k\n        for i in range(rows):\n            for j in range(cols):\n                if mat[k + i][j + k] - mat[i][j + k] - mat[k + i][j] + mat[i][j\n                        ] <= threshold:\n                    return True\n        return False"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        rows = len(mat)\n        cols = len(mat[0])\n        for i in range(rows):\n            for j in range(cols - 1):\n                mat[i][j + 1] += mat[i][j]\n        for j in range(cols):\n            for i in range(rows - 1):\n                mat[i + 1][j] += mat[i][j]\n        left, right, res = 0, min(rows, cols), 0\n        while right >= left:\n            mid = (right + left) // 2\n            if self.check(mat, threshold, mid):\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n    def check(self, mat: List[List[int]], threshold: int, k: int) -> bool:\n        rows = len(mat) - k\n        cols = len(mat[0]) - k\n        for i in range(rows):\n            for j in range(cols):\n                if mat[k + i][j + k] - mat[i][j + k] - mat[k + i][j] + mat[i][j\n                        ] <= threshold:\n                    return True\n        return False", "watermarked_code": "from typing import List\nclass Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) ->int:\n        rows = len(mat)\n        cols = len(mat[0])\n        for i in range(rows):\n            for j in range(cols - 1):\n                mat[i][j + 1] += mat[i][j]\n        for j in range(cols):\n            for i in range(rows - 1):\n                mat[i + 1][j] += mat[i][j]\n        left, right, res = 0, min(rows, cols), 0\n        while right >= left:\n            mid = (right + left) // 2\n            if self.check(mat, threshold, mid):\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n    def check(self, mat: List[List[int]], threshold: int, k: int) ->bool:\n        rows = len(mat) - k\n        cols = len(mat[0]) - k\n        for i in range(rows):\n            for j in range(cols):\n                if mat[k + i][j + k] - mat[i][j + k] - mat[k + i][j] + mat[i][j\n                        ] <= threshold:\n                    return True\n        return False"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        rows = len(mat)\n        cols = len(mat[0])\n        for i in range(rows):\n            for j in range(cols - 1):\n                mat[i][j + 1] += mat[i][j]\n        for j in range(cols):\n            for i in range(rows - 1):\n                mat[i + 1][j] += mat[i][j]\n        left, right, res = 0, min(rows, cols), 0\n        while right >= left:\n            mid = (right + left) // 2\n            if self.check(mat, threshold, mid):\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n    def check(self, mat: List[List[int]], threshold: int, k: int) -> bool:\n        rows = len(mat) - k\n        cols = len(mat[0]) - k\n        for i in range(rows):\n            for j in range(cols):\n                if mat[k + i][j + k] - mat[i][j + k] - mat[k + i][j] + mat[i][j\n                        ] <= threshold:\n                    return True\n        return False", "watermarked_code": "from typing import List\nclass Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) ->int:\n        rows = len(mat)\n        cols = len(mat[0])\n        for i in range(rows):\n            for j in range(cols - 1):\n                mat[i][j + 1] += mat[i][j]\n        for j in range(cols):\n            for i in range(rows - 1):\n                mat[i + 1][j] += mat[i][j]\n        left, right, res = 0, min(rows, cols), 0\n        while right >= left:\n            mid = (right + left) // 2\n            if self.check(mat, threshold, mid):\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n    def check(self, mat: List[List[int]], threshold: int, k: int) ->bool:\n        rows = len(mat) - k\n        cols = len(mat[0]) - k\n        for i in range(rows):\n            for j in range(cols):\n                if mat[k + i][j + k] - mat[i][j + k] - mat[k + i][j] + mat[i][j\n                        ] <= threshold:\n                    return True\n        return False"}
{"generated_code": "from typing import List\nfrom collections import deque\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        if k >= n + m - 2:\n            return n + m - 2\n        visited = set()\n        q = deque([(0, 0, 0)])\n        steps = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                row, col, obs = q.popleft()\n                if row == m - 1 and col == n - 1:\n                    return steps\n                for dx, dy in directions:\n                    new_row, new_col = dx + row, col + dy\n                    new_obs = obs + grid[new_row][new_col]\n                    if (new_row >= 0 and m > new_row and new_col >= 0 and n >\n                            new_col and k >= new_obs and (new_row, new_col,\n                            new_obs) not in visited):\n                        q.append((new_row, new_col, new_obs))\n                        visited.add((new_row, new_col, new_obs))\n            steps += 1\n        return -1", "watermarked_code": "from typing import List\nfrom collections import deque\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) ->int:\n        m, n = len(grid), len(grid[0])\n        if k >= n + m - 2:\n            return n + m - 2\n        visited = set()\n        q = deque([(0, 0, 0)])\n        steps = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                row, col, obs = q.popleft()\n                if row == m - 1 and col == n - 1:\n                    return steps\n                for dx, dy in directions:\n                    new_row, new_col = dx + row, col + dy\n                    new_obs = obs + grid[new_row][new_col]\n                    if (new_row >= 0 and m > new_row and new_col >= 0 and n >\n                            new_col and k >= new_obs and (new_row, new_col,\n                            new_obs) not in visited):\n                        q.append((new_row, new_col, new_obs))\n                        visited.add((new_row, new_col, new_obs))\n            steps += 1\n        return -1"}
{"generated_code": "from typing import List\nfrom collections import deque\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        if k >= n + m - 2:\n            return n + m - 2\n        visited = set()\n        q = deque([(0, 0, 0)])\n        steps = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                row, col, obs = q.popleft()\n                if row == m - 1 and col == n - 1:\n                    return steps\n                for dx, dy in directions:\n                    new_row, new_col = dx + row, col + dy\n                    new_obs = obs + grid[new_row][new_col]\n                    if (new_row >= 0 and m > new_row and new_col >= 0 and n >\n                            new_col and k >= new_obs and (new_row, new_col,\n                            new_obs) not in visited):\n                        q.append((new_row, new_col, new_obs))\n                        visited.add((new_row, new_col, new_obs))\n            steps += 1\n        return -1", "watermarked_code": "from typing import List\nfrom collections import deque\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) ->int:\n        m, n = len(grid), len(grid[0])\n        if k >= n + m - 2:\n            return n + m - 2\n        visited = set()\n        q = deque([(0, 0, 0)])\n        steps = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                row, col, obs = q.popleft()\n                if row == m - 1 and col == n - 1:\n                    return steps\n                for dx, dy in directions:\n                    new_row, new_col = dx + row, col + dy\n                    new_obs = obs + grid[new_row][new_col]\n                    if (new_row >= 0 and m > new_row and new_col >= 0 and n >\n                            new_col and k >= new_obs and (new_row, new_col,\n                            new_obs) not in visited):\n                        q.append((new_row, new_col, new_obs))\n                        visited.add((new_row, new_col, new_obs))\n            steps += 1\n        return -1"}
{"generated_code": "from typing import List\nfrom collections import deque\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        if k >= n + m - 2:\n            return n + m - 2\n        visited = set()\n        q = deque([(0, 0, 0)])\n        steps = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                row, col, obs = q.popleft()\n                if row == m - 1 and col == n - 1:\n                    return steps\n                for dx, dy in directions:\n                    new_row, new_col = dx + row, col + dy\n                    new_obs = obs + grid[new_row][new_col]\n                    if (new_row >= 0 and m > new_row and new_col >= 0 and n >\n                            new_col and k >= new_obs and (new_row, new_col,\n                            new_obs) not in visited):\n                        q.append((new_row, new_col, new_obs))\n                        visited.add((new_row, new_col, new_obs))\n            steps += 1\n        return -1", "watermarked_code": "from typing import List\nfrom collections import deque\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) ->int:\n        m, n = len(grid), len(grid[0])\n        if k >= n + m - 2:\n            return n + m - 2\n        visited = set()\n        q = deque([(0, 0, 0)])\n        steps = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                row, col, obs = q.popleft()\n                if row == m - 1 and col == n - 1:\n                    return steps\n                for dx, dy in directions:\n                    new_row, new_col = dx + row, col + dy\n                    new_obs = obs + grid[new_row][new_col]\n                    if (new_row >= 0 and m > new_row and new_col >= 0 and n >\n                            new_col and k >= new_obs and (new_row, new_col,\n                            new_obs) not in visited):\n                        q.append((new_row, new_col, new_obs))\n                        visited.add((new_row, new_col, new_obs))\n            steps += 1\n        return -1"}
{"generated_code": "from typing import List\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort(reverse=True)\n        prefix_sum = [arr[0]]\n        prefix_sum.extend(prefix_sum[-1] + arr[i] for i in range(1, len(arr)))\n        min_value = (target + len(arr) - 1) // len(arr)\n        max_value = arr[0]\n        left = min_value\n        right = max_value\n        while right > left:\n            mid = (right + left) // 2\n            temp_sum = sum(min(arr[i], mid) for i in range(len(arr)))\n            if temp_sum >= target:\n                right = mid\n            else:\n                left = mid + 1\n        sum1 = 0\n        sum2 = 0\n        for i in range(len(arr)):\n            if arr[i] > left:\n                sum1 += left\n                sum2 += left - 1\n            else:\n                sum1 += arr[i]\n                sum2 += arr[i]\n        return left if abs(sum1 - target) <= abs(sum2 - target) else left - 1", "watermarked_code": "from typing import List\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) ->int:\n        arr.sort(reverse=True)\n        prefix_sum = [arr[0]]\n        prefix_sum.extend(prefix_sum[-1] + arr[i] for i in range(1, len(arr)))\n        min_value = (target + len(arr) - 1) // len(arr)\n        max_value = arr[0]\n        left = min_value\n        right = max_value\n        while right > left:\n            mid = (right + left) // 2\n            temp_sum = sum(min(arr[i], mid) for i in range(len(arr)))\n            if temp_sum >= target:\n                right = mid\n            else:\n                left = mid + 1\n        sum1 = 0\n        sum2 = 0\n        for item in arr:\n            if item > left:\n                sum1 += left\n                sum2 += left - 1\n            else:\n                sum1 += item\n                sum2 += item\n        return left if abs(sum1 - target) <= abs(sum2 - target) else left - 1"}
{"generated_code": "from typing import List\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort(reverse=True)\n        prefix_sum = [arr[0]]\n        prefix_sum.extend(prefix_sum[-1] + arr[i] for i in range(1, len(arr)))\n        min_value = (target + len(arr) - 1) // len(arr)\n        max_value = arr[0]\n        left = min_value\n        right = max_value\n        while right > left:\n            mid = (right + left) // 2\n            temp_sum = sum(min(arr[i], mid) for i in range(len(arr)))\n            if temp_sum >= target:\n                right = mid\n            else:\n                left = mid + 1\n        sum1 = 0\n        sum2 = 0\n        for i in range(len(arr)):\n            if arr[i] > left:\n                sum1 += left\n                sum2 += left - 1\n            else:\n                sum1 += arr[i]\n                sum2 += arr[i]\n        return left if abs(sum1 - target) <= abs(sum2 - target) else left - 1", "watermarked_code": "from typing import List\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) ->int:\n        arr.sort(reverse=True)\n        prefix_sum = [arr[0]]\n        prefix_sum.extend(prefix_sum[-1] + arr[i] for i in range(1, len(arr)))\n        min_value = (target + len(arr) - 1) // len(arr)\n        max_value = arr[0]\n        left = min_value\n        right = max_value\n        while right > left:\n            mid = (right + left) // 2\n            temp_sum = sum(min(arr[i], mid) for i in range(len(arr)))\n            if temp_sum >= target:\n                right = mid\n            else:\n                left = mid + 1\n        sum1 = 0\n        sum2 = 0\n        for item in arr:\n            if item > left:\n                sum1 += left\n                sum2 += left - 1\n            else:\n                sum1 += item\n                sum2 += item\n        return left if abs(sum1 - target) <= abs(sum2 - target) else left - 1"}
{"generated_code": "from typing import List\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        def dfs(index, digits, length, carry):\n            if index == length:\n                return carry == 0\n            word = self.words[index]\n            for i in range(len(word)):\n                if word[i] in digits:\n                    continue\n                for j in range(10):\n                    if j == 0 and i == 0 and len(word) > 1:\n                        continue\n                    if j in digits:\n                        continue\n                    digits.add(word[i])\n                    expression = j + carry\n                    if i == len(word) - 1:\n                        if expression % 10 != self.result[length - index - 1]:\n                            digits.remove(word[i])\n                            continue\n                        flag = dfs(index + 1, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    else:\n                        flag = dfs(index, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    digits.remove(word[i])\n            return False\n        self.words = words\n        self.result = [int(x) for x in list(result)][::-1]\n        candidates = set()\n        length = len(words)\n        for word in words:\n            for ch in word:\n                candidates.add(ch)\n        for ch in result:\n            candidates.add(ch)\n        return False if len(candidates) > 10 else dfs(0, set(), length, 0)", "watermarked_code": "from typing import List\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) ->bool:\n        def dfs(index, digits, length, carry):\n            if index == length:\n                return carry == 0\n            word = self.words[index]\n            for i in range(len(word)):\n                if word[i] in digits:\n                    continue\n                for j in range(10):\n                    if j == 0 and i == 0 and len(word) > 1:\n                        continue\n                    if j in digits:\n                        continue\n                    digits.add(word[i])\n                    expression = j + carry\n                    if i == len(word) - 1:\n                        if expression % 10 != self.result[length - index - 1]:\n                            digits.remove(word[i])\n                            continue\n                        flag = dfs(index + 1, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    else:\n                        flag = dfs(index, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    digits.remove(word[i])\n            return False\n        self.words = words\n        self.result = [int(x) for x in list(result)][::-1]\n        candidates = set()\n        length = len(words)\n        for word in words:\n            for ch in word:\n                candidates.add(ch)\n        for ch in result:\n            candidates.add(ch)\n        return False if len(candidates) > 10 else dfs(0, set(), length, 0)"}
{"generated_code": "from typing import List\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        def dfs(index, digits, length, carry):\n            if index == length:\n                return carry == 0\n            word = self.words[index]\n            for i in range(len(word)):\n                if word[i] in digits:\n                    continue\n                for j in range(10):\n                    if j == 0 and i == 0 and len(word) > 1:\n                        continue\n                    if j in digits:\n                        continue\n                    digits.add(word[i])\n                    expression = j + carry\n                    if i == len(word) - 1:\n                        if expression % 10 != self.result[length - index - 1]:\n                            digits.remove(word[i])\n                            continue\n                        flag = dfs(index + 1, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    else:\n                        flag = dfs(index, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    digits.remove(word[i])\n            return False\n        self.words = words\n        self.result = [int(x) for x in list(result)][::-1]\n        candidates = set()\n        length = len(words)\n        for word in words:\n            for ch in word:\n                candidates.add(ch)\n        for ch in result:\n            candidates.add(ch)\n        return False if len(candidates) > 10 else dfs(0, set(), length, 0)", "watermarked_code": "from typing import List\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) ->bool:\n        def dfs(index, digits, length, carry):\n            if index == length:\n                return carry == 0\n            word = self.words[index]\n            for i in range(len(word)):\n                if word[i] in digits:\n                    continue\n                for j in range(10):\n                    if j == 0 and i == 0 and len(word) > 1:\n                        continue\n                    if j in digits:\n                        continue\n                    digits.add(word[i])\n                    expression = j + carry\n                    if i == len(word) - 1:\n                        if expression % 10 != self.result[length - index - 1]:\n                            digits.remove(word[i])\n                            continue\n                        flag = dfs(index + 1, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    else:\n                        flag = dfs(index, digits, length, expression // 10)\n                        if flag:\n                            return True\n                    digits.remove(word[i])\n            return False\n        self.words = words\n        self.result = [int(x) for x in list(result)][::-1]\n        candidates = set()\n        length = len(words)\n        for word in words:\n            for ch in word:\n                candidates.add(ch)\n        for ch in result:\n            candidates.add(ch)\n        return False if len(candidates) > 10 else dfs(0, set(), length, 0)"}
{"generated_code": "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefix_xor = [0]\n        prefix_xor.extend(prefix_xor[-1] ^ num for num in arr)\n        return [(prefix_xor[q[0]] ^ prefix_xor[q[1] + 1]) for q in queries]", "watermarked_code": "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) ->List[int]:\n        prefix_xor = [0]\n        prefix_xor.extend(prefix_xor[-1] ^ num for num in arr)\n        return [(prefix_xor[q[0]] ^ prefix_xor[q[1] + 1]) for q in queries]"}
{"generated_code": "from collections import defaultdict\nfrom typing import List\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = defaultdict(list)\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str,\n            startTime: int, endTime: int) -> List[int]:\n        interval = (60 if freq == 'minute' else 3600 if freq == 'hour' else\n            86400)\n        tweet_times = self.tweets[tweetName]\n        return [sum(startTime <= t <= min(startTime + interval - 1, endTime\n            ) for t in tweet_times) for _ in range(startTime, endTime + 1,\n            interval)]", "watermarked_code": "from collections import defaultdict\nfrom typing import List\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = defaultdict(list)\n    def recordTweet(self, tweetName: str, time: int) ->None:\n        self.tweets[tweetName].append(time)\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str,\n            startTime: int, endTime: int) ->List[int]:\n        interval = (60 if freq == 'minute' else 3600 if freq == 'hour' else\n            86400)\n        tweet_times = self.tweets[tweetName]\n        return [sum(startTime <= t <= min(startTime + interval - 1, endTime\n            ) for t in tweet_times) for _ in range(startTime, endTime + 1,\n            interval)]"}
{"generated_code": "from collections import defaultdict\nfrom typing import List\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = defaultdict(list)\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str,\n            startTime: int, endTime: int) -> List[int]:\n        interval = (60 if freq == 'minute' else 3600 if freq == 'hour' else\n            86400)\n        tweet_times = self.tweets[tweetName]\n        return [sum(startTime <= t <= min(startTime + interval - 1, endTime\n            ) for t in tweet_times) for _ in range(startTime, endTime + 1,\n            interval)]", "watermarked_code": "from collections import defaultdict\nfrom typing import List\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = defaultdict(list)\n    def recordTweet(self, tweetName: str, time: int) ->None:\n        self.tweets[tweetName].append(time)\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str,\n            startTime: int, endTime: int) ->List[int]:\n        interval = (60 if freq == 'minute' else 3600 if freq == 'hour' else\n            86400)\n        tweet_times = self.tweets[tweetName]\n        return [sum(startTime <= t <= min(startTime + interval - 1, endTime\n            ) for t in tweet_times) for _ in range(startTime, endTime + 1,\n            interval)]"}
{"generated_code": "class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int\n            ) -> int:\n        count = 0\n        for num in arr1:\n            flag = all(abs(num - compare_num) > d for compare_num in arr2)\n            if flag:\n                count += 1\n        return count", "watermarked_code": "class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int\n            ) ->int:\n        count = 0\n        for num in arr1:\n            flag = all(abs(num - compare_num) > d for compare_num in arr2)\n            if flag:\n                count += 1\n        return count"}
{"generated_code": "class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int\n            ) -> int:\n        count = 0\n        for num in arr1:\n            flag = all(abs(num - compare_num) > d for compare_num in arr2)\n            if flag:\n                count += 1\n        return count", "watermarked_code": "class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int\n            ) ->int:\n        count = 0\n        for num in arr1:\n            flag = all(abs(num - compare_num) > d for compare_num in arr2)\n            if flag:\n                count += 1\n        return count"}
{"generated_code": "class Solution:\n    def findLucky(self, arr: List[int]) -> int:\n        freq = {}\n        for num in arr:\n            if num not in freq:\n                freq[num] = 1\n            else:\n                freq[num] += 1\n        lucky_nums = [key for key, value in freq.items() if key == value]\n        return -1 if not lucky_nums else max(lucky_nums)", "watermarked_code": "class Solution:\n    def findLucky(self, arr: List[int]) ->int:\n        freq = {}\n        for num in arr:\n            if num not in freq:\n                freq[num] = 1\n            else:\n                freq[num] += 1\n        lucky_nums = [key for key, value in freq.items() if key == value]\n        return max(lucky_nums, default=-1)"}
{"generated_code": "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        freq = {}\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        single_freq = sum(bool(value % 2 != 0) for char, value in freq.items())\n        return False if single_freq > k else len(s) >= k", "watermarked_code": "class Solution:\n    def canConstruct(self, s: str, k: int) ->bool:\n        freq = {}\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        single_freq = sum(value % 2 != 0 for char, value in freq.items())\n        return False if single_freq > k else len(s) >= k"}
{"generated_code": "class Solution:\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int,\n            y1: int, x2: int, y2: int) -> bool:\n        x = max(x1, min(xCenter, x2))\n        y = max(y1, min(yCenter, y2))\n        distance = ((x - xCenter) ** 2 + (y - yCenter) ** 2) ** 0.5\n        return distance <= radius\ns = Solution()\nprint(s.checkOverlap(1, 0, 0, 1, -1, 3, 1))\nprint(s.checkOverlap(1, 1, 1, 1, -3, 2, -1))\nprint(s.checkOverlap(1, 0, 0, -1, 0, 0, 1))", "watermarked_code": "class Solution:\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int,\n            y1: int, x2: int, y2: int) ->bool:\n        x = max(x1, min(xCenter, x2))\n        y = max(y1, min(yCenter, y2))\n        distance = ((x - xCenter) ** 2 + (y - yCenter) ** 2) ** 0.5\n        return distance <= radius\ns = Solution()\nprint(s.checkOverlap(1, 0, 0, 1, -1, 3, 1))\nprint(s.checkOverlap(1, 1, 1, 1, -3, 2, -1))\nprint(s.checkOverlap(1, 0, 0, -1, 0, 0, 1))"}
{"generated_code": "class Solution:\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int,\n            y1: int, x2: int, y2: int) -> bool:\n        x = max(x1, min(xCenter, x2))\n        y = max(y1, min(yCenter, y2))\n        distance = ((x - xCenter) ** 2 + (y - yCenter) ** 2) ** 0.5\n        return distance <= radius\ns = Solution()\nprint(s.checkOverlap(1, 0, 0, 1, -1, 3, 1))\nprint(s.checkOverlap(1, 1, 1, 1, -3, 2, -1))\nprint(s.checkOverlap(1, 0, 0, -1, 0, 0, 1))", "watermarked_code": "class Solution:\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int,\n            y1: int, x2: int, y2: int) ->bool:\n        x = max(x1, min(xCenter, x2))\n        y = max(y1, min(yCenter, y2))\n        distance = ((x - xCenter) ** 2 + (y - yCenter) ** 2) ** 0.5\n        return distance <= radius\ns = Solution()\nprint(s.checkOverlap(1, 0, 0, 1, -1, 3, 1))\nprint(s.checkOverlap(1, 1, 1, 1, -3, 2, -1))\nprint(s.checkOverlap(1, 0, 0, -1, 0, 0, 1))"}
{"generated_code": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        result = ''\n        letter_counts = {'a': a, 'b': b, 'c': c}\n        letters = sorted(letter_counts.keys(), key=lambda x: letter_counts[\n            x], reverse=True)\n        last_1 = last_2 = 0\n        for letter in letters:\n            if letter_counts[letter] == 0:\n                continue\n            if letter_counts[letter] >= 2:\n                result += letter * 2\n                letter_counts[letter] -= 2\n            else:\n                result += letter\n                letter_counts[letter] -= 1\n            last_2, last_1 = last_1, letter\n        return result", "watermarked_code": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) ->str:\n        result = ''\n        letter_counts = {'a': a, 'b': b, 'c': c}\n        letters = sorted(letter_counts.keys(), key=lambda x: letter_counts[\n            x], reverse=True)\n        last_1 = last_2 = 0\n        for letter in letters:\n            if letter_counts[letter] == 0:\n                continue\n            if letter_counts[letter] >= 2:\n                result += letter * 2\n                letter_counts[letter] -= 2\n            else:\n                result += letter\n                letter_counts[letter] -= 1\n            last_2, last_1 = last_1, letter\n        return result"}
{"generated_code": "class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int],\n            queryTime: int) -> int:\n        \"\"\"\n        Return the number of students doing their homework at the given queryTime.\n        \"\"\"\n        return sum(bool(startTime[i] <= queryTime and endTime[i] >=\n            queryTime) for i in range(len(startTime)))", "watermarked_code": "class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int],\n            queryTime: int) ->int:\n        \"\"\"\n        Return the number of students doing their homework at the given queryTime.\n        \"\"\"\n        return sum(startTime[i] <= queryTime and endTime[i] >= queryTime for\n            i in range(len(startTime)))"}
{"generated_code": "class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int],\n            queryTime: int) -> int:\n        \"\"\"\n        Return the number of students doing their homework at the given queryTime.\n        \"\"\"\n        return sum(bool(startTime[i] <= queryTime and endTime[i] >=\n            queryTime) for i in range(len(startTime)))", "watermarked_code": "class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int],\n            queryTime: int) ->int:\n        \"\"\"\n        Return the number of students doing their homework at the given queryTime.\n        \"\"\"\n        return sum(startTime[i] <= queryTime and endTime[i] >= queryTime for\n            i in range(len(startTime)))"}
{"generated_code": "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        \"\"\"\n        Check if target list can be obtained by reversing subarrays of the arr list.\n        Args:\n        target: a list of distinct integers\n        arr: a list of integers with same length as target\n        Returns:\n        A boolean indicating whether target can be obtained by reversing subarrays of arr.\n        \"\"\"\n        target.sort()\n        arr.sort()\n        return target == arr", "watermarked_code": "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) ->bool:\n        \"\"\"\n        Check if target list can be obtained by reversing subarrays of the arr list.\n        Args:\n        target: a list of distinct integers\n        arr: a list of integers with same length as target\n        Returns:\n        A boolean indicating whether target can be obtained by reversing subarrays of arr.\n        \"\"\"\n        target.sort()\n        arr.sort()\n        return target == arr"}
{"generated_code": "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n:\n            int, target: int) -> int:\n        dp = [[([float('inf')] * target) for _ in range(n)] for _ in range(m)]\n        for j in range(n):\n            if houses[0] == j + 1:\n                dp[0][j][0] = 0\n            elif houses[0] == 0:\n                dp[0][j][0] = cost[0][j]\n        for i in range(1, m):\n            for j in range(n):\n                for k in range(target):\n                    if houses[i] not in [0, j + 1]:\n                        continue\n                    case1 = dp[i - 1][j][k] + cost[i][j] if j + 1 != houses[i\n                        ] else dp[i - 1][j][k]\n                    if k > 0:\n                        for p in range(n):\n                            case2 = dp[i - 1][p][k - 1] + cost[i][j\n                                ] if j + 1 == houses[i\n                                ] or p + 1 == j + 1 else float('inf')\n                            dp[i][j][k] = min(dp[i][j][k], min(case1, case2))\n                    else:\n                        dp[i][j][k] = case1\n        ans = float('inf')\n        for j in range(n):\n            ans = min(ans, dp[-1][j][target - 1])\n        return ans if ans != float('inf') else -1", "watermarked_code": "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n:\n            int, target: int) ->int:\n        dp = [[([float('inf')] * target) for _ in range(n)] for _ in range(m)]\n        for j in range(n):\n            if houses[0] == j + 1:\n                dp[0][j][0] = 0\n            elif houses[0] == 0:\n                dp[0][j][0] = cost[0][j]\n        for i in range(1, m):\n            for j in range(n):\n                for k in range(target):\n                    if houses[i] not in [0, j + 1]:\n                        continue\n                    case1 = dp[i - 1][j][k] + cost[i][j] if j + 1 != houses[i\n                        ] else dp[i - 1][j][k]\n                    if k > 0:\n                        for p in range(n):\n                            case2 = dp[i - 1][p][k - 1] + cost[i][j\n                                ] if j + 1 == houses[i\n                                ] or p + 1 == j + 1 else float('inf')\n                            dp[i][j][k] = min(dp[i][j][k], min(case1, case2))\n                    else:\n                        dp[i][j][k] = case1\n        ans = float('inf')\n        for j in range(n):\n            ans = min(ans, dp[-1][j][target - 1])\n        return ans if ans != float('inf') else -1"}
{"generated_code": "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n:\n            int, target: int) -> int:\n        dp = [[([float('inf')] * target) for _ in range(n)] for _ in range(m)]\n        for j in range(n):\n            if houses[0] == j + 1:\n                dp[0][j][0] = 0\n            elif houses[0] == 0:\n                dp[0][j][0] = cost[0][j]\n        for i in range(1, m):\n            for j in range(n):\n                for k in range(target):\n                    if houses[i] not in [0, j + 1]:\n                        continue\n                    case1 = dp[i - 1][j][k] + cost[i][j] if j + 1 != houses[i\n                        ] else dp[i - 1][j][k]\n                    if k > 0:\n                        for p in range(n):\n                            case2 = dp[i - 1][p][k - 1] + cost[i][j\n                                ] if j + 1 == houses[i\n                                ] or p + 1 == j + 1 else float('inf')\n                            dp[i][j][k] = min(dp[i][j][k], min(case1, case2))\n                    else:\n                        dp[i][j][k] = case1\n        ans = float('inf')\n        for j in range(n):\n            ans = min(ans, dp[-1][j][target - 1])\n        return ans if ans != float('inf') else -1", "watermarked_code": "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n:\n            int, target: int) ->int:\n        dp = [[([float('inf')] * target) for _ in range(n)] for _ in range(m)]\n        for j in range(n):\n            if houses[0] == j + 1:\n                dp[0][j][0] = 0\n            elif houses[0] == 0:\n                dp[0][j][0] = cost[0][j]\n        for i in range(1, m):\n            for j in range(n):\n                for k in range(target):\n                    if houses[i] not in [0, j + 1]:\n                        continue\n                    case1 = dp[i - 1][j][k] + cost[i][j] if j + 1 != houses[i\n                        ] else dp[i - 1][j][k]\n                    if k > 0:\n                        for p in range(n):\n                            case2 = dp[i - 1][p][k - 1] + cost[i][j\n                                ] if j + 1 == houses[i\n                                ] or p + 1 == j + 1 else float('inf')\n                            dp[i][j][k] = min(dp[i][j][k], min(case1, case2))\n                    else:\n                        dp[i][j][k] = case1\n        ans = float('inf')\n        for j in range(n):\n            ans = min(ans, dp[-1][j][target - 1])\n        return ans if ans != float('inf') else -1"}
{"generated_code": "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        running_sum = 0\n        start = 0\n        end = 0\n        min_length = float('inf')\n        min_lengths = []\n        length = 0\n        while end < len(arr):\n            running_sum += arr[end]\n            while running_sum > target:\n                running_sum -= arr[start]\n                start += 1\n            if running_sum == target:\n                length = end - start + 1\n                if min_length > length:\n                    min_length = length\n                    min_lengths.append(min_length)\n                    if len(min_lengths) > 2:\n                        min_lengths.pop(0)\n                running_sum -= arr[start]\n                start += 1\n            end += 1\n        return -1 if len(min_lengths) < 2 else sum(min_lengths)", "watermarked_code": "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) ->int:\n        running_sum = 0\n        start = 0\n        min_length = float('inf')\n        min_lengths = []\n        length = 0\n        for end in range(len(arr)):\n            running_sum += arr[end]\n            while running_sum > target:\n                running_sum -= arr[start]\n                start += 1\n            if running_sum == target:\n                length = end - start + 1\n                if min_length > length:\n                    min_length = length\n                    min_lengths.append(min_length)\n                    if len(min_lengths) > 2:\n                        min_lengths.pop(0)\n                running_sum -= arr[start]\n                start += 1\n        return -1 if len(min_lengths) < 2 else sum(min_lengths)"}
{"generated_code": "from typing import List\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        full_lakes = {}\n        ans = [-1] * n\n        for i in range(n):\n            if rains[i] > 0:\n                lake = rains[i]\n                if lake in full_lakes:\n                    j = full_lakes[lake]\n                    dry_day = self.find_dry_day(full_lakes, j, i)\n                    if dry_day == -1:\n                        return []\n                    else:\n                        ans[dry_day] = lake\n                full_lakes[lake] = i\n            elif full_lakes:\n                j = min(full_lakes.values())\n                ans[i] = rains[j]\n                del full_lakes[rains[j]]\n        return ans\n    def find_dry_day(self, full_lakes, start, end):\n        days = set(range(start + 1, end))\n        for lake in full_lakes:\n            if full_lakes[lake] in days:\n                return -1\n        return min(days)", "watermarked_code": "from typing import List\nclass Solution:\n    def avoidFlood(self, rains: List[int]) ->List[int]:\n        n = len(rains)\n        full_lakes = {}\n        ans = [-1] * n\n        for i in range(n):\n            if rains[i] > 0:\n                lake = rains[i]\n                if lake in full_lakes:\n                    j = full_lakes[lake]\n                    dry_day = self.find_dry_day(full_lakes, j, i)\n                    if dry_day == -1:\n                        return []\n                    else:\n                        ans[dry_day] = lake\n                full_lakes[lake] = i\n            elif full_lakes:\n                j = min(full_lakes.values())\n                ans[i] = rains[j]\n                del full_lakes[rains[j]]\n        return ans\n    def find_dry_day(self, full_lakes, start, end):\n        days = set(range(start + 1, end))\n        for lake in full_lakes:\n            if full_lakes[lake] in days:\n                return -1\n        return min(days)"}
{"generated_code": "class Solution:\n    def numSplits(self, s: str) -> int:\n        left, right = set(), set()\n        left_count, right_count = [], []\n        for c in s:\n            if c not in right:\n                right.add(c)\n                right_count.append(len(right))\n            if c not in left:\n                left.add(c)\n                left_count.append(len(left))\n        return sum(bool(left_count[i] == right_count[-i - 2]) for i in\n            range(len(left_count) - 1))", "watermarked_code": "class Solution:\n    def numSplits(self, s: str) ->int:\n        left, right = set(), set()\n        left_count, right_count = [], []\n        for c in s:\n            if c not in right:\n                right.add(c)\n                right_count.append(len(right))\n            if c not in left:\n                left.add(c)\n                left_count.append(len(left))\n        return sum(left_count[i] == right_count[-i - 2] for i in range(len(\n            left_count) - 1))"}
{"generated_code": "from typing import List\nclass Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[\n            int]:\n        in_degree = [0] * n\n        for u, v in edges:\n            in_degree[v] += 1\n        return [i for i in range(n) if in_degree[i] == 0]\nsol = Solution()\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(sol.findSmallestSetOfVertices(n, edges))\nn = 5\nedges = [[0, 1], [2, 1], [3, 1], [1, 4], [2, 4]]\nprint(sol.findSmallestSetOfVertices(n, edges))", "watermarked_code": "from typing import List\nclass Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) ->List[\n            int]:\n        in_degree = [0] * n\n        for u, v in edges:\n            in_degree[v] += 1\n        return [i for i in range(n) if in_degree[i] == 0]\nsol = Solution()\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(sol.findSmallestSetOfVertices(n, edges))\nn = 5\nedges = [[0, 1], [2, 1], [3, 1], [1, 4], [2, 4]]\nprint(sol.findSmallestSetOfVertices(n, edges))"}
{"generated_code": "from typing import List\nclass Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[\n            int]:\n        in_degree = [0] * n\n        for u, v in edges:\n            in_degree[v] += 1\n        return [i for i in range(n) if in_degree[i] == 0]\nsol = Solution()\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(sol.findSmallestSetOfVertices(n, edges))\nn = 5\nedges = [[0, 1], [2, 1], [3, 1], [1, 4], [2, 4]]\nprint(sol.findSmallestSetOfVertices(n, edges))", "watermarked_code": "from typing import List\nclass Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) ->List[\n            int]:\n        in_degree = [0] * n\n        for u, v in edges:\n            in_degree[v] += 1\n        return [i for i in range(n) if in_degree[i] == 0]\nsol = Solution()\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(sol.findSmallestSetOfVertices(n, edges))\nn = 5\nedges = [[0, 1], [2, 1], [3, 1], [1, 4], [2, 4]]\nprint(sol.findSmallestSetOfVertices(n, edges))"}
{"generated_code": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def hasAdjacentCellsSameValue(i, j):\n            value = grid[i][j]\n            if i > 0 and grid[i - 1][j] == value:\n                return True\n            if j > 0 and grid[i][j - 1] == value:\n                return True\n            if i < m - 1 and grid[i + 1][j] == value:\n                return True\n            return j < n - 1 and grid[i][j + 1] == value\n        def dfs(i, j, parent_i, parent_j, visited):\n            visited[i][j] = True\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if (x == parent_i and y == parent_j or x < 0 or x >= m or y <\n                    0 or n <= y or grid[x][y] != grid[i][j]):\n                    continue\n                if visited[x][y]:\n                    return True\n                if dfs(x, y, i, j, visited):\n                    return True\n            return False\n        m, n = len(grid), len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j] and hasAdjacentCellsSameValue(i, j\n                        ) and dfs(i, j, -1, -1, visited):\n                    return True\n        return False", "watermarked_code": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) ->bool:\n        def hasAdjacentCellsSameValue(i, j):\n            value = grid[i][j]\n            if i > 0 and grid[i - 1][j] == value:\n                return True\n            if j > 0 and grid[i][j - 1] == value:\n                return True\n            if i < m - 1 and grid[i + 1][j] == value:\n                return True\n            return j < n - 1 and grid[i][j + 1] == value\n        def dfs(i, j, parent_i, parent_j, visited):\n            visited[i][j] = True\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if (x == parent_i and y == parent_j or x < 0 or x >= m or y <\n                    0 or n <= y or grid[x][y] != grid[i][j]):\n                    continue\n                if visited[x][y]:\n                    return True\n                if dfs(x, y, i, j, visited):\n                    return True\n            return False\n        m, n = len(grid), len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j] and hasAdjacentCellsSameValue(i, j\n                        ) and dfs(i, j, -1, -1, visited):\n                    return True\n        return False"}
{"generated_code": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def hasAdjacentCellsSameValue(i, j):\n            value = grid[i][j]\n            if i > 0 and grid[i - 1][j] == value:\n                return True\n            if j > 0 and grid[i][j - 1] == value:\n                return True\n            if i < m - 1 and grid[i + 1][j] == value:\n                return True\n            return j < n - 1 and grid[i][j + 1] == value\n        def dfs(i, j, parent_i, parent_j, visited):\n            visited[i][j] = True\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if (x == parent_i and y == parent_j or x < 0 or x >= m or y <\n                    0 or n <= y or grid[x][y] != grid[i][j]):\n                    continue\n                if visited[x][y]:\n                    return True\n                if dfs(x, y, i, j, visited):\n                    return True\n            return False\n        m, n = len(grid), len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j] and hasAdjacentCellsSameValue(i, j\n                        ) and dfs(i, j, -1, -1, visited):\n                    return True\n        return False", "watermarked_code": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) ->bool:\n        def hasAdjacentCellsSameValue(i, j):\n            value = grid[i][j]\n            if i > 0 and grid[i - 1][j] == value:\n                return True\n            if j > 0 and grid[i][j - 1] == value:\n                return True\n            if i < m - 1 and grid[i + 1][j] == value:\n                return True\n            return j < n - 1 and grid[i][j + 1] == value\n        def dfs(i, j, parent_i, parent_j, visited):\n            visited[i][j] = True\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if (x == parent_i and y == parent_j or x < 0 or x >= m or y <\n                    0 or n <= y or grid[x][y] != grid[i][j]):\n                    continue\n                if visited[x][y]:\n                    return True\n                if dfs(x, y, i, j, visited):\n                    return True\n            return False\n        m, n = len(grid), len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j] and hasAdjacentCellsSameValue(i, j\n                        ) and dfs(i, j, -1, -1, visited):\n                    return True\n        return False"}
{"generated_code": "from typing import List\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        n = len(piles) // 3\n        return sum(piles[i * 2 + 1] for i in range(n))", "watermarked_code": "from typing import List\nclass Solution:\n    def maxCoins(self, piles: List[int]) ->int:\n        piles.sort(reverse=True)\n        n = len(piles) // 3\n        return sum(piles[i * 2 + 1] for i in range(n))"}
{"generated_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost:\n            int, runningCost: int) -> int:\n        waiting = 0\n        rotations = 0\n        maxProfit = 0\n        totalProfit = 0\n        for i in range(len(customers)):\n            waiting += customers[i]\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        while waiting > 0:\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        return -1 if maxProfit == 0 else res", "watermarked_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost:\n            int, runningCost: int) ->int:\n        waiting = 0\n        rotations = 0\n        maxProfit = 0\n        totalProfit = 0\n        for customer in customers:\n            waiting += customer\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        while waiting > 0:\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        return -1 if maxProfit == 0 else res"}
{"generated_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost:\n            int, runningCost: int) -> int:\n        waiting = 0\n        rotations = 0\n        maxProfit = 0\n        totalProfit = 0\n        for i in range(len(customers)):\n            waiting += customers[i]\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        while waiting > 0:\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        return -1 if maxProfit == 0 else res", "watermarked_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost:\n            int, runningCost: int) ->int:\n        waiting = 0\n        rotations = 0\n        maxProfit = 0\n        totalProfit = 0\n        for customer in customers:\n            waiting += customer\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        while waiting > 0:\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        return -1 if maxProfit == 0 else res"}
{"generated_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost:\n            int, runningCost: int) -> int:\n        waiting = 0\n        rotations = 0\n        maxProfit = 0\n        totalProfit = 0\n        for i in range(len(customers)):\n            waiting += customers[i]\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        while waiting > 0:\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        return -1 if maxProfit == 0 else res", "watermarked_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost:\n            int, runningCost: int) ->int:\n        waiting = 0\n        rotations = 0\n        maxProfit = 0\n        totalProfit = 0\n        for customer in customers:\n            waiting += customer\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        while waiting > 0:\n            boarded = min(waiting, 4)\n            waiting -= boarded\n            totalProfit += boardingCost * boarded - runningCost\n            rotations += 1\n            if maxProfit > totalProfit:\n                maxProfit = totalProfit\n                res = rotations\n        return -1 if maxProfit == 0 else res"}
{"generated_code": "class Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r:\n            List[int]) -> List[bool]:\n        results = []\n        for i in range(len(l)):\n            start = l[i]\n            end = r[i]\n            subarray = nums[start:end + 1]\n            subarray.sort()\n            if len(subarray) < 2:\n                results.append(False)\n            else:\n                difference = subarray[1] - subarray[0]\n                valid = all(subarray[j] - subarray[j - 1] == difference for\n                    j in range(2, len(subarray)))\n                results.append(valid)\n        return results", "watermarked_code": "class Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r:\n            List[int]) ->List[bool]:\n        results = []\n        for i in range(len(l)):\n            start = l[i]\n            end = r[i]\n            subarray = nums[start:end + 1]\n            subarray.sort()\n            if len(subarray) < 2:\n                results.append(False)\n            else:\n                difference = subarray[1] - subarray[0]\n                valid = all(subarray[j] - subarray[j - 1] == difference for\n                    j in range(2, len(subarray)))\n                results.append(valid)\n        return results"}
{"generated_code": "class Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r:\n            List[int]) -> List[bool]:\n        results = []\n        for i in range(len(l)):\n            start = l[i]\n            end = r[i]\n            subarray = nums[start:end + 1]\n            subarray.sort()\n            if len(subarray) < 2:\n                results.append(False)\n            else:\n                difference = subarray[1] - subarray[0]\n                valid = all(subarray[j] - subarray[j - 1] == difference for\n                    j in range(2, len(subarray)))\n                results.append(valid)\n        return results", "watermarked_code": "class Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r:\n            List[int]) ->List[bool]:\n        results = []\n        for i in range(len(l)):\n            start = l[i]\n            end = r[i]\n            subarray = nums[start:end + 1]\n            subarray.sort()\n            if len(subarray) < 2:\n                results.append(False)\n            else:\n                difference = subarray[1] - subarray[0]\n                valid = all(subarray[j] - subarray[j - 1] == difference for\n                    j in range(2, len(subarray)))\n                results.append(valid)\n        return results"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        rows, cols = len(heights), len(heights[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(effort):\n            queue = [(0, 0)]\n            visited = {(0, 0)}\n            while queue:\n                i, j = queue.pop(0)\n                if i == rows - 1 and j == cols - 1:\n                    return True\n                for di, dj in directions:\n                    ni, nj = di + i, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and (ni, nj\n                        ) not in visited and abs(heights[ni][nj] - heights[\n                            i][j]) <= effort:\n                        visited.add((ni, nj))\n                        queue.append((ni, nj))\n            return False\n        left, right = 0, 10 ** 6\n        while right > left:\n            mid = (right + left) // 2\n            if bfs(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) ->int:\n        rows, cols = len(heights), len(heights[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(effort):\n            queue = [(0, 0)]\n            visited = {(0, 0)}\n            while queue:\n                i, j = queue.pop(0)\n                if i == rows - 1 and j == cols - 1:\n                    return True\n                for di, dj in directions:\n                    ni, nj = di + i, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and (ni, nj\n                        ) not in visited and abs(heights[ni][nj] - heights[\n                            i][j]) <= effort:\n                        visited.add((ni, nj))\n                        queue.append((ni, nj))\n            return False\n        left, right = 0, 10 ** 6\n        while right > left:\n            mid = (right + left) // 2\n            if bfs(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        rows, cols = len(heights), len(heights[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(effort):\n            queue = [(0, 0)]\n            visited = {(0, 0)}\n            while queue:\n                i, j = queue.pop(0)\n                if i == rows - 1 and j == cols - 1:\n                    return True\n                for di, dj in directions:\n                    ni, nj = di + i, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and (ni, nj\n                        ) not in visited and abs(heights[ni][nj] - heights[\n                            i][j]) <= effort:\n                        visited.add((ni, nj))\n                        queue.append((ni, nj))\n            return False\n        left, right = 0, 10 ** 6\n        while right > left:\n            mid = (right + left) // 2\n            if bfs(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) ->int:\n        rows, cols = len(heights), len(heights[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(effort):\n            queue = [(0, 0)]\n            visited = {(0, 0)}\n            while queue:\n                i, j = queue.pop(0)\n                if i == rows - 1 and j == cols - 1:\n                    return True\n                for di, dj in directions:\n                    ni, nj = di + i, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and (ni, nj\n                        ) not in visited and abs(heights[ni][nj] - heights[\n                            i][j]) <= effort:\n                        visited.add((ni, nj))\n                        queue.append((ni, nj))\n            return False\n        left, right = 0, 10 ** 6\n        while right > left:\n            mid = (right + left) // 2\n            if bfs(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        rows, cols = len(heights), len(heights[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(effort):\n            queue = [(0, 0)]\n            visited = {(0, 0)}\n            while queue:\n                i, j = queue.pop(0)\n                if i == rows - 1 and j == cols - 1:\n                    return True\n                for di, dj in directions:\n                    ni, nj = di + i, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and (ni, nj\n                        ) not in visited and abs(heights[ni][nj] - heights[\n                            i][j]) <= effort:\n                        visited.add((ni, nj))\n                        queue.append((ni, nj))\n            return False\n        left, right = 0, 10 ** 6\n        while right > left:\n            mid = (right + left) // 2\n            if bfs(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) ->int:\n        rows, cols = len(heights), len(heights[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(effort):\n            queue = [(0, 0)]\n            visited = {(0, 0)}\n            while queue:\n                i, j = queue.pop(0)\n                if i == rows - 1 and j == cols - 1:\n                    return True\n                for di, dj in directions:\n                    ni, nj = di + i, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and (ni, nj\n                        ) not in visited and abs(heights[ni][nj] - heights[\n                            i][j]) <= effort:\n                        visited.add((ni, nj))\n                        queue.append((ni, nj))\n            return False\n        left, right = 0, 10 ** 6\n        while right > left:\n            mid = (right + left) // 2\n            if bfs(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}
{"generated_code": "from math import comb\nclass Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        row, col = destination[0], destination[1]\n        total_steps = col + row\n        res = ''\n        for _ in range(total_steps):\n            if row == 0:\n                res += 'H' * col\n                break\n            if col == 0:\n                res += 'V' * row\n                break\n            comb_h = comb(col + row - 1, col - 1)\n            comb_v = comb(col + row - 1, row - 1)\n            if k <= comb_h:\n                res += 'H'\n                col -= 1\n            else:\n                res += 'V'\n                row -= 1\n                k -= comb_h\n        return res", "watermarked_code": "from math import comb\nclass Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) ->str:\n        row, col = destination[0], destination[1]\n        total_steps = col + row\n        res = ''\n        for _ in range(total_steps):\n            if row == 0:\n                res += 'H' * col\n                break\n            if col == 0:\n                res += 'V' * row\n                break\n            comb_h = comb(col + row - 1, col - 1)\n            comb_v = comb(col + row - 1, row - 1)\n            if k <= comb_h:\n                res += 'H'\n                col -= 1\n            else:\n                res += 'V'\n                row -= 1\n                k -= comb_h\n        return res"}
{"generated_code": "from math import comb\nclass Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        row, col = destination[0], destination[1]\n        total_steps = col + row\n        res = ''\n        for _ in range(total_steps):\n            if row == 0:\n                res += 'H' * col\n                break\n            if col == 0:\n                res += 'V' * row\n                break\n            comb_h = comb(col + row - 1, col - 1)\n            comb_v = comb(col + row - 1, row - 1)\n            if k <= comb_h:\n                res += 'H'\n                col -= 1\n            else:\n                res += 'V'\n                row -= 1\n                k -= comb_h\n        return res", "watermarked_code": "from math import comb\nclass Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) ->str:\n        row, col = destination[0], destination[1]\n        total_steps = col + row\n        res = ''\n        for _ in range(total_steps):\n            if row == 0:\n                res += 'H' * col\n                break\n            if col == 0:\n                res += 'V' * row\n                break\n            comb_h = comb(col + row - 1, col - 1)\n            comb_v = comb(col + row - 1, row - 1)\n            if k <= comb_h:\n                res += 'H'\n                col -= 1\n            else:\n                res += 'V'\n                row -= 1\n                k -= comb_h\n        return res"}
{"generated_code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int,\n            extrovertsCount: int) -> int:\n        cell_combinations = [(i, self.getCellHappiness(i, m, n)) for i in\n            range(n * m)]\n        cell_combinations.sort(key=lambda x: x[1], reverse=True)\n        grid = [[None for _ in range(n)] for _ in range(m)]\n        for _ in range(introvertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'I'\n        for _ in range(extrovertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'E'\n        happiness = 0\n        for i in range(m):\n            for j in range(n):\n                person_happiness = self.getPersonHappiness(i, j, grid, m, n)\n                happiness += person_happiness\n        return happiness\n    def getPersonHappiness(self, row, col, grid, m, n):\n        person_type = grid[row][col]\n        neighbors = []\n        if row > 0:\n            neighbors.append(grid[row - 1][col])\n        if col > 0:\n            neighbors.append(grid[row][col - 1])\n        if row < m - 1:\n            neighbors.append(grid[row + 1][col])\n        if col < n - 1:\n            neighbors.append(grid[row][col + 1])\n        if person_type == 'I':\n            happiness = 120\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness -= 30\n                elif neighbor == 'E':\n                    happiness -= 60\n        elif person_type == 'E':\n            happiness = 40\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness += 20\n                elif neighbor == 'E':\n                    happiness += 40\n        else:\n            happiness = 0\n        return happiness\n    def getCellHappiness(self, cell, m, n):\n        row = cell // n\n        col = cell % n\n        row_happiness = 80 if row in [0, m - 1] else 120\n        col_happiness = 80 if col in [0, n - 1] else 120\n        return col_happiness + row_happiness - 2 * 20", "watermarked_code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int,\n            extrovertsCount: int) ->int:\n        cell_combinations = [(i, self.getCellHappiness(i, m, n)) for i in\n            range(n * m)]\n        cell_combinations.sort(key=lambda x: x[1], reverse=True)\n        grid = [[None for _ in range(n)] for _ in range(m)]\n        for _ in range(introvertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'I'\n        for _ in range(extrovertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'E'\n        happiness = 0\n        for i in range(m):\n            for j in range(n):\n                person_happiness = self.getPersonHappiness(i, j, grid, m, n)\n                happiness += person_happiness\n        return happiness\n    def getPersonHappiness(self, row, col, grid, m, n):\n        person_type = grid[row][col]\n        neighbors = []\n        if row > 0:\n            neighbors.append(grid[row - 1][col])\n        if col > 0:\n            neighbors.append(grid[row][col - 1])\n        if row < m - 1:\n            neighbors.append(grid[row + 1][col])\n        if col < n - 1:\n            neighbors.append(grid[row][col + 1])\n        if person_type == 'I':\n            happiness = 120\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness -= 30\n                elif neighbor == 'E':\n                    happiness -= 60\n        elif person_type == 'E':\n            happiness = 40\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness += 20\n                elif neighbor == 'E':\n                    happiness += 40\n        else:\n            happiness = 0\n        return happiness\n    def getCellHappiness(self, cell, m, n):\n        row = cell // n\n        col = cell % n\n        row_happiness = 80 if row in [0, m - 1] else 120\n        col_happiness = 80 if col in [0, n - 1] else 120\n        return col_happiness + row_happiness - 2 * 20"}
{"generated_code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int,\n            extrovertsCount: int) -> int:\n        cell_combinations = [(i, self.getCellHappiness(i, m, n)) for i in\n            range(n * m)]\n        cell_combinations.sort(key=lambda x: x[1], reverse=True)\n        grid = [[None for _ in range(n)] for _ in range(m)]\n        for _ in range(introvertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'I'\n        for _ in range(extrovertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'E'\n        happiness = 0\n        for i in range(m):\n            for j in range(n):\n                person_happiness = self.getPersonHappiness(i, j, grid, m, n)\n                happiness += person_happiness\n        return happiness\n    def getPersonHappiness(self, row, col, grid, m, n):\n        person_type = grid[row][col]\n        neighbors = []\n        if row > 0:\n            neighbors.append(grid[row - 1][col])\n        if col > 0:\n            neighbors.append(grid[row][col - 1])\n        if row < m - 1:\n            neighbors.append(grid[row + 1][col])\n        if col < n - 1:\n            neighbors.append(grid[row][col + 1])\n        if person_type == 'I':\n            happiness = 120\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness -= 30\n                elif neighbor == 'E':\n                    happiness -= 60\n        elif person_type == 'E':\n            happiness = 40\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness += 20\n                elif neighbor == 'E':\n                    happiness += 40\n        else:\n            happiness = 0\n        return happiness\n    def getCellHappiness(self, cell, m, n):\n        row = cell // n\n        col = cell % n\n        row_happiness = 80 if row in [0, m - 1] else 120\n        col_happiness = 80 if col in [0, n - 1] else 120\n        return col_happiness + row_happiness - 2 * 20", "watermarked_code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int,\n            extrovertsCount: int) ->int:\n        cell_combinations = [(i, self.getCellHappiness(i, m, n)) for i in\n            range(n * m)]\n        cell_combinations.sort(key=lambda x: x[1], reverse=True)\n        grid = [[None for _ in range(n)] for _ in range(m)]\n        for _ in range(introvertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'I'\n        for _ in range(extrovertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'E'\n        happiness = 0\n        for i in range(m):\n            for j in range(n):\n                person_happiness = self.getPersonHappiness(i, j, grid, m, n)\n                happiness += person_happiness\n        return happiness\n    def getPersonHappiness(self, row, col, grid, m, n):\n        person_type = grid[row][col]\n        neighbors = []\n        if row > 0:\n            neighbors.append(grid[row - 1][col])\n        if col > 0:\n            neighbors.append(grid[row][col - 1])\n        if row < m - 1:\n            neighbors.append(grid[row + 1][col])\n        if col < n - 1:\n            neighbors.append(grid[row][col + 1])\n        if person_type == 'I':\n            happiness = 120\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness -= 30\n                elif neighbor == 'E':\n                    happiness -= 60\n        elif person_type == 'E':\n            happiness = 40\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness += 20\n                elif neighbor == 'E':\n                    happiness += 40\n        else:\n            happiness = 0\n        return happiness\n    def getCellHappiness(self, cell, m, n):\n        row = cell // n\n        col = cell % n\n        row_happiness = 80 if row in [0, m - 1] else 120\n        col_happiness = 80 if col in [0, n - 1] else 120\n        return col_happiness + row_happiness - 2 * 20"}
{"generated_code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int,\n            extrovertsCount: int) -> int:\n        cell_combinations = [(i, self.getCellHappiness(i, m, n)) for i in\n            range(n * m)]\n        cell_combinations.sort(key=lambda x: x[1], reverse=True)\n        grid = [[None for _ in range(n)] for _ in range(m)]\n        for _ in range(introvertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'I'\n        for _ in range(extrovertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'E'\n        happiness = 0\n        for i in range(m):\n            for j in range(n):\n                person_happiness = self.getPersonHappiness(i, j, grid, m, n)\n                happiness += person_happiness\n        return happiness\n    def getPersonHappiness(self, row, col, grid, m, n):\n        person_type = grid[row][col]\n        neighbors = []\n        if row > 0:\n            neighbors.append(grid[row - 1][col])\n        if col > 0:\n            neighbors.append(grid[row][col - 1])\n        if row < m - 1:\n            neighbors.append(grid[row + 1][col])\n        if col < n - 1:\n            neighbors.append(grid[row][col + 1])\n        if person_type == 'I':\n            happiness = 120\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness -= 30\n                elif neighbor == 'E':\n                    happiness -= 60\n        elif person_type == 'E':\n            happiness = 40\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness += 20\n                elif neighbor == 'E':\n                    happiness += 40\n        else:\n            happiness = 0\n        return happiness\n    def getCellHappiness(self, cell, m, n):\n        row = cell // n\n        col = cell % n\n        row_happiness = 80 if row in [0, m - 1] else 120\n        col_happiness = 80 if col in [0, n - 1] else 120\n        return col_happiness + row_happiness - 2 * 20", "watermarked_code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int,\n            extrovertsCount: int) ->int:\n        cell_combinations = [(i, self.getCellHappiness(i, m, n)) for i in\n            range(n * m)]\n        cell_combinations.sort(key=lambda x: x[1], reverse=True)\n        grid = [[None for _ in range(n)] for _ in range(m)]\n        for _ in range(introvertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'I'\n        for _ in range(extrovertsCount):\n            cell = cell_combinations.pop(0)[0]\n            row = cell // n\n            col = cell % n\n            grid[row][col] = 'E'\n        happiness = 0\n        for i in range(m):\n            for j in range(n):\n                person_happiness = self.getPersonHappiness(i, j, grid, m, n)\n                happiness += person_happiness\n        return happiness\n    def getPersonHappiness(self, row, col, grid, m, n):\n        person_type = grid[row][col]\n        neighbors = []\n        if row > 0:\n            neighbors.append(grid[row - 1][col])\n        if col > 0:\n            neighbors.append(grid[row][col - 1])\n        if row < m - 1:\n            neighbors.append(grid[row + 1][col])\n        if col < n - 1:\n            neighbors.append(grid[row][col + 1])\n        if person_type == 'I':\n            happiness = 120\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness -= 30\n                elif neighbor == 'E':\n                    happiness -= 60\n        elif person_type == 'E':\n            happiness = 40\n            for neighbor in neighbors:\n                if neighbor == 'I':\n                    happiness += 20\n                elif neighbor == 'E':\n                    happiness += 40\n        else:\n            happiness = 0\n        return happiness\n    def getCellHappiness(self, cell, m, n):\n        row = cell // n\n        col = cell % n\n        row_happiness = 80 if row in [0, m - 1] else 120\n        col_happiness = 80 if col in [0, n - 1] else 120\n        return col_happiness + row_happiness - 2 * 20"}
{"generated_code": "from typing import List\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        string1 = ''.join(word1)\n        string2 = ''.join(word2)\n        return string1 == string2", "watermarked_code": "from typing import List\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) ->bool:\n        string1 = ''.join(word1)\n        string2 = ''.join(word2)\n        return string1 == string2"}
{"generated_code": "class Solution:\n    def findBall(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        output = [(-1) for _ in range(n)]\n        for i in range(n):\n            j, curr = i, 0\n            while m > curr:\n                if grid[curr][j] == 1:\n                    if j == n - 1 or grid[curr][j + 1] == -1:\n                        break\n                    j += 1\n                elif j == 0 or grid[curr][j - 1] == 1:\n                    break\n                else:\n                    j -= 1\n                curr += 1\n            output[i] = j if curr == m else -1\n        return output", "watermarked_code": "class Solution:\n    def findBall(self, grid: List[List[int]]) ->List[int]:\n        m, n = len(grid), len(grid[0])\n        output = [(-1) for _ in range(n)]\n        for i in range(n):\n            j, curr = i, 0\n            while m > curr:\n                if grid[curr][j] == 1:\n                    if j == n - 1 or grid[curr][j + 1] == -1:\n                        break\n                    j += 1\n                elif j == 0 or grid[curr][j - 1] == 1:\n                    break\n                else:\n                    j -= 1\n                curr += 1\n            output[i] = j if curr == m else -1\n        return output"}
{"generated_code": "class Solution:\n    def minimumLength(self, s: str) -> int:\n        l, r = 0, len(s) - 1\n        while r > l:\n            if s[l] != s[r]:\n                return len(s[l:r + 1])\n            while r > l and s[l] == s[l + 1]:\n                l += 1\n            while r > l and s[r] == s[r - 1]:\n                r -= 1\n            l += 1\n            r -= 1\n        return 1 if l == r else 0", "watermarked_code": "class Solution:\n    def minimumLength(self, s: str) ->int:\n        l, r = 0, len(s) - 1\n        while r > l:\n            if s[l] != s[r]:\n                return len(s[l:r + 1])\n            while r > l and s[l] == s[l + 1]:\n                l += 1\n            while r > l and s[r] == s[r - 1]:\n                r -= 1\n            l += 1\n            r -= 1\n        return 1 if l == r else 0"}
{"generated_code": "class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\n        def countBagsSize(x):\n            res = 0\n            for num in nums:\n                if x > num:\n                    res += num // x - 1 if num % x == 0 else num // x\n            return res\n        left, right = 1, max(nums)\n        while right > left:\n            mid = (right + left) // 2\n            if countBagsSize(mid) > maxOperations:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "watermarked_code": "class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) ->int:\n        def countBagsSize(x):\n            res = 0\n            for num in nums:\n                if x > num:\n                    res += num // x - 1 if num % x == 0 else num // x\n            return res\n        left, right = 1, max(nums)\n        while right > left:\n            mid = (right + left) // 2\n            if countBagsSize(mid) > maxOperations:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}
{"generated_code": "class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\n        def countBagsSize(x):\n            res = 0\n            for num in nums:\n                if x > num:\n                    res += num // x - 1 if num % x == 0 else num // x\n            return res\n        left, right = 1, max(nums)\n        while right > left:\n            mid = (right + left) // 2\n            if countBagsSize(mid) > maxOperations:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "watermarked_code": "class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) ->int:\n        def countBagsSize(x):\n            res = 0\n            for num in nums:\n                if x > num:\n                    res += num // x - 1 if num % x == 0 else num // x\n            return res\n        left, right = 1, max(nums)\n        while right > left:\n            mid = (right + left) // 2\n            if countBagsSize(mid) > maxOperations:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}
{"generated_code": "class Solution:\n    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str\n            ) -> int:\n        if ruleKey == 'color':\n            index = 1\n        elif ruleKey == 'type':\n            index = 0\n        else:\n            index = 2\n        return sum(bool(item[index] == ruleValue) for item in items)", "watermarked_code": "class Solution:\n    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str\n            ) ->int:\n        if ruleKey == 'color':\n            index = 1\n        elif ruleKey == 'type':\n            index = 0\n        else:\n            index = 2\n        return sum(item[index] == ruleValue for item in items)"}
{"generated_code": "class Solution:\n    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str\n            ) -> int:\n        if ruleKey == 'color':\n            index = 1\n        elif ruleKey == 'type':\n            index = 0\n        else:\n            index = 2\n        return sum(bool(item[index] == ruleValue) for item in items)", "watermarked_code": "class Solution:\n    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str\n            ) ->int:\n        if ruleKey == 'color':\n            index = 1\n        elif ruleKey == 'type':\n            index = 0\n        else:\n            index = 2\n        return sum(item[index] == ruleValue for item in items)"}
{"generated_code": "class Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        cnt = [Counter(nums[i::k]) for i in range(k)]\n        for j in range(k):\n            s = sum(val for val in cnt[j].values())\n            for i in range(n):\n                dp[i] = s - cnt[j][nums[i]] if k > i else s - cnt[j][nums[i]\n                    ] + dp[i - k]\n                s += 1 - cnt[j][(k + i) % n]\n        return n - max(dp)", "watermarked_code": "class Solution:\n    def minChanges(self, nums: List[int], k: int) ->int:\n        n = len(nums)\n        dp = [0] * n\n        cnt = [Counter(nums[i::k]) for i in range(k)]\n        for j in range(k):\n            s = sum(cnt[j].values())\n            for i in range(n):\n                dp[i] = s - cnt[j][nums[i]] if k > i else s - cnt[j][nums[i]\n                    ] + dp[i - k]\n                s += 1 - cnt[j][(k + i) % n]\n        return n - max(dp)"}
{"generated_code": "class Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        cnt = [Counter(nums[i::k]) for i in range(k)]\n        for j in range(k):\n            s = sum(val for val in cnt[j].values())\n            for i in range(n):\n                dp[i] = s - cnt[j][nums[i]] if k > i else s - cnt[j][nums[i]\n                    ] + dp[i - k]\n                s += 1 - cnt[j][(k + i) % n]\n        return n - max(dp)", "watermarked_code": "class Solution:\n    def minChanges(self, nums: List[int], k: int) ->int:\n        n = len(nums)\n        dp = [0] * n\n        cnt = [Counter(nums[i::k]) for i in range(k)]\n        for j in range(k):\n            s = sum(cnt[j].values())\n            for i in range(n):\n                dp[i] = s - cnt[j][nums[i]] if k > i else s - cnt[j][nums[i]\n                    ] + dp[i - k]\n                s += 1 - cnt[j][(k + i) % n]\n        return n - max(dp)"}
{"generated_code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(x) for x in nums]\n        def custom_sort(x, y):\n            return int(x + y) - int(x + y)\n        nums.sort(key=cmp_to_key(custom_sort))\n        return '0' if nums[0] == '0' else ''.join(nums)", "watermarked_code": "class Solution:\n    def largestNumber(self, nums: List[int]) ->str:\n        nums = [str(x) for x in nums]\n        def custom_sort(x, y):\n            return int(x + y) - int(x + y)\n        nums.sort(key=cmp_to_key(custom_sort))\n        return '0' if nums[0] == '0' else ''.join(nums)"}
{"generated_code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(x) for x in nums]\n        def custom_sort(x, y):\n            return int(x + y) - int(x + y)\n        nums.sort(key=cmp_to_key(custom_sort))\n        return '0' if nums[0] == '0' else ''.join(nums)", "watermarked_code": "class Solution:\n    def largestNumber(self, nums: List[int]) ->str:\n        nums = [str(x) for x in nums]\n        def custom_sort(x, y):\n            return int(x + y) - int(x + y)\n        nums.sort(key=cmp_to_key(custom_sort))\n        return '0' if nums[0] == '0' else ''.join(nums)"}
{"generated_code": "class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n        self.timeToLive = timeToLive\n        self.tokenStore = {}\n    def generate(self, tokenId: str, currentTime: int) -> None:\n        self.tokenStore[tokenId] = currentTime\n    def renew(self, tokenId: str, currentTime: int) -> None:\n        if tokenId in self.tokenStore and self.tokenStore[tokenId\n                ] + self.timeToLive > currentTime:\n            self.tokenStore[tokenId] = currentTime\n    def countUnexpiredTokens(self, currentTime: int) -> int:\n        return sum(bool(self.tokenStore[tokenId] + self.timeToLive >\n            currentTime) for tokenId in self.tokenStore)\nauth_manager = AuthenticationManager(5)\nauth_manager.renew('aaa', 1)\nauth_manager.generate('aaa', 2)\nauth_manager.countUnexpiredTokens(6)\nauth_manager.generate('bbb', 7)\nauth_manager.renew('aaa', 8)\nauth_manager.renew('bbb', 10)\nauth_manager.countUnexpiredTokens(15)", "watermarked_code": "class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n        self.timeToLive = timeToLive\n        self.tokenStore = {}\n    def generate(self, tokenId: str, currentTime: int) ->None:\n        self.tokenStore[tokenId] = currentTime\n    def renew(self, tokenId: str, currentTime: int) ->None:\n        if tokenId in self.tokenStore and self.tokenStore[tokenId\n                ] + self.timeToLive > currentTime:\n            self.tokenStore[tokenId] = currentTime\n    def countUnexpiredTokens(self, currentTime: int) ->int:\n        return sum(self.tokenStore[tokenId] + self.timeToLive > currentTime for\n            tokenId in self.tokenStore)\nauth_manager = AuthenticationManager(5)\nauth_manager.renew('aaa', 1)\nauth_manager.generate('aaa', 2)\nauth_manager.countUnexpiredTokens(6)\nauth_manager.generate('bbb', 7)\nauth_manager.renew('aaa', 8)\nauth_manager.renew('bbb', 10)\nauth_manager.countUnexpiredTokens(15)"}
{"generated_code": "class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n        self.timeToLive = timeToLive\n        self.tokenStore = {}\n    def generate(self, tokenId: str, currentTime: int) -> None:\n        self.tokenStore[tokenId] = currentTime\n    def renew(self, tokenId: str, currentTime: int) -> None:\n        if tokenId in self.tokenStore and self.tokenStore[tokenId\n                ] + self.timeToLive > currentTime:\n            self.tokenStore[tokenId] = currentTime\n    def countUnexpiredTokens(self, currentTime: int) -> int:\n        return sum(bool(self.tokenStore[tokenId] + self.timeToLive >\n            currentTime) for tokenId in self.tokenStore)\nauth_manager = AuthenticationManager(5)\nauth_manager.renew('aaa', 1)\nauth_manager.generate('aaa', 2)\nauth_manager.countUnexpiredTokens(6)\nauth_manager.generate('bbb', 7)\nauth_manager.renew('aaa', 8)\nauth_manager.renew('bbb', 10)\nauth_manager.countUnexpiredTokens(15)", "watermarked_code": "class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n        self.timeToLive = timeToLive\n        self.tokenStore = {}\n    def generate(self, tokenId: str, currentTime: int) ->None:\n        self.tokenStore[tokenId] = currentTime\n    def renew(self, tokenId: str, currentTime: int) ->None:\n        if tokenId in self.tokenStore and self.tokenStore[tokenId\n                ] + self.timeToLive > currentTime:\n            self.tokenStore[tokenId] = currentTime\n    def countUnexpiredTokens(self, currentTime: int) ->int:\n        return sum(self.tokenStore[tokenId] + self.timeToLive > currentTime for\n            tokenId in self.tokenStore)\nauth_manager = AuthenticationManager(5)\nauth_manager.renew('aaa', 1)\nauth_manager.generate('aaa', 2)\nauth_manager.countUnexpiredTokens(6)\nauth_manager.generate('bbb', 7)\nauth_manager.renew('aaa', 8)\nauth_manager.renew('bbb', 10)\nauth_manager.countUnexpiredTokens(15)"}
{"generated_code": "class Solution:\n    def squareIsWhite(self, coordinates: str) -> bool:\n        return (ord(coordinates[0]) + int(coordinates[1])) % 2 != 0", "watermarked_code": "class Solution:\n    def squareIsWhite(self, coordinates: str) ->bool:\n        return (ord(coordinates[0]) + int(coordinates[1])) % 2 != 0"}
{"generated_code": "class Solution:\n    def replaceDigits(self, s: str) -> str:\n        return ''.join(chr(ord(s[i - 1]) + int(s[i])) if s[i].isdigit() else\n            s[i] for i in range(len(s)))", "watermarked_code": "class Solution:\n    def replaceDigits(self, s: str) ->str:\n        return ''.join(chr(ord(s[i - 1]) + int(s[i])) if s[i].isdigit() else\n            s[i] for i in range(len(s)))"}
{"generated_code": "class Solution:\n    def checkZeroOnes(self, s: str) -> bool:\n        longest_1, longest_0 = 0, 0\n        curr_1, curr_0 = 0, 0\n        prev_char = ''\n        for char in s:\n            if char == '0':\n                if prev_char == '0':\n                    curr_0 += 1\n                else:\n                    curr_0 = 1\n                longest_0 = max(longest_0, curr_0)\n            elif char == '1':\n                if prev_char == '1':\n                    curr_1 += 1\n                else:\n                    curr_1 = 1\n                longest_1 = max(longest_1, curr_1)\n            prev_char = char\n        return longest_1 > longest_0", "watermarked_code": "class Solution:\n    def checkZeroOnes(self, s: str) ->bool:\n        longest_1, longest_0 = 0, 0\n        curr_1, curr_0 = 0, 0\n        prev_char = ''\n        for char in s:\n            if char == '0':\n                if prev_char == '0':\n                    curr_0 += 1\n                else:\n                    curr_0 = 1\n                longest_0 = max(longest_0, curr_0)\n            elif char == '1':\n                if prev_char == '1':\n                    curr_1 += 1\n                else:\n                    curr_1 = 1\n                longest_1 = max(longest_1, curr_1)\n            prev_char = char\n        return longest_1 > longest_0"}
{"generated_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        def time_taken(speed):\n            time = 0\n            for d in dist[:-1]:\n                time += d // speed + (d % speed != 0)\n            time += dist[-1] / speed\n            return time\n        left, right = 1, int(10000000.0)\n        while right >= left:\n            mid = (right + left) // 2\n            time = time_taken(mid)\n            if hour >= time:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1 if left > int(10000000.0) else left", "watermarked_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) ->int:\n        def time_taken(speed):\n            time = 0\n            for d in dist[:-1]:\n                time += d // speed + (d % speed != 0)\n            time += dist[-1] / speed\n            return time\n        left, right = 1, int(10000000.0)\n        while right >= left:\n            mid = (right + left) // 2\n            time = time_taken(mid)\n            if hour >= time:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1 if left > int(10000000.0) else left"}
{"generated_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        def time_taken(speed):\n            time = 0\n            for d in dist[:-1]:\n                time += d // speed + (d % speed != 0)\n            time += dist[-1] / speed\n            return time\n        left, right = 1, int(10000000.0)\n        while right >= left:\n            mid = (right + left) // 2\n            time = time_taken(mid)\n            if hour >= time:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1 if left > int(10000000.0) else left", "watermarked_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) ->int:\n        def time_taken(speed):\n            time = 0\n            for d in dist[:-1]:\n                time += d // speed + (d % speed != 0)\n            time += dist[-1] / speed\n            return time\n        left, right = 1, int(10000000.0)\n        while right >= left:\n            mid = (right + left) // 2\n            time = time_taken(mid)\n            if hour >= time:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1 if left > int(10000000.0) else left"}
{"generated_code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        reachable_indices = set([0])\n        max_reachable_idx = 0\n        for i in range(n):\n            if max_reachable_idx > i:\n                return False\n            if s[i] == '0':\n                for j in range(max(minJump + i, max_reachable_idx + 1), min\n                        (maxJump + i + 1, n)):\n                    if s[j] == '0':\n                        reachable_indices.add(j)\n                max_reachable_idx = max(max_reachable_idx, maxJump + i)\n        return n - 1 in reachable_indices", "watermarked_code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) ->bool:\n        n = len(s)\n        reachable_indices = {0}\n        max_reachable_idx = 0\n        for i in range(n):\n            if max_reachable_idx > i:\n                return False\n            if s[i] == '0':\n                for j in range(max(minJump + i, max_reachable_idx + 1), min\n                        (maxJump + i + 1, n)):\n                    if s[j] == '0':\n                        reachable_indices.add(j)\n                max_reachable_idx = max(max_reachable_idx, maxJump + i)\n        return n - 1 in reachable_indices"}
{"generated_code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        reachable_indices = set([0])\n        max_reachable_idx = 0\n        for i in range(n):\n            if max_reachable_idx > i:\n                return False\n            if s[i] == '0':\n                for j in range(max(minJump + i, max_reachable_idx + 1), min\n                        (maxJump + i + 1, n)):\n                    if s[j] == '0':\n                        reachable_indices.add(j)\n                max_reachable_idx = max(max_reachable_idx, maxJump + i)\n        return n - 1 in reachable_indices", "watermarked_code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) ->bool:\n        n = len(s)\n        reachable_indices = {0}\n        max_reachable_idx = 0\n        for i in range(n):\n            if max_reachable_idx > i:\n                return False\n            if s[i] == '0':\n                for j in range(max(minJump + i, max_reachable_idx + 1), min\n                        (maxJump + i + 1, n)):\n                    if s[j] == '0':\n                        reachable_indices.add(j)\n                max_reachable_idx = max(max_reachable_idx, maxJump + i)\n        return n - 1 in reachable_indices"}
{"generated_code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        reachable_indices = set([0])\n        max_reachable_idx = 0\n        for i in range(n):\n            if max_reachable_idx > i:\n                return False\n            if s[i] == '0':\n                for j in range(max(minJump + i, max_reachable_idx + 1), min\n                        (maxJump + i + 1, n)):\n                    if s[j] == '0':\n                        reachable_indices.add(j)\n                max_reachable_idx = max(max_reachable_idx, maxJump + i)\n        return n - 1 in reachable_indices", "watermarked_code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) ->bool:\n        n = len(s)\n        reachable_indices = {0}\n        max_reachable_idx = 0\n        for i in range(n):\n            if max_reachable_idx > i:\n                return False\n            if s[i] == '0':\n                for j in range(max(minJump + i, max_reachable_idx + 1), min\n                        (maxJump + i + 1, n)):\n                    if s[j] == '0':\n                        reachable_indices.add(j)\n                max_reachable_idx = max(max_reachable_idx, maxJump + i)\n        return n - 1 in reachable_indices"}
{"generated_code": "class Solution:\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:\n        def is_possible(num_skips):\n            time, skips = 0, 0\n            for d in dist[:-1]:\n                t = math.ceil(d / speed)\n                time += t\n                skips += int(time > hoursBefore)\n                if num_skips > skips:\n                    return False\n                if time + skips > hoursBefore:\n                    return False\n            time += dist[-1] / speed\n            return time <= hoursBefore\n        left, right = 0, len(dist)\n        while right > left:\n            mid = (right + left) // 2\n            if is_possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return -1 if not is_possible(left) else left", "watermarked_code": "class Solution:\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) ->int:\n        def is_possible(num_skips):\n            time, skips = 0, 0\n            for d in dist[:-1]:\n                t = math.ceil(d / speed)\n                time += t\n                skips += int(time > hoursBefore)\n                if num_skips > skips:\n                    return False\n                if time + skips > hoursBefore:\n                    return False\n            time += dist[-1] / speed\n            return time <= hoursBefore\n        left, right = 0, len(dist)\n        while right > left:\n            mid = (right + left) // 2\n            if is_possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left if is_possible(left) else -1"}
{"generated_code": "class Solution:\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:\n        def is_possible(num_skips):\n            time, skips = 0, 0\n            for d in dist[:-1]:\n                t = math.ceil(d / speed)\n                time += t\n                skips += int(time > hoursBefore)\n                if num_skips > skips:\n                    return False\n                if time + skips > hoursBefore:\n                    return False\n            time += dist[-1] / speed\n            return time <= hoursBefore\n        left, right = 0, len(dist)\n        while right > left:\n            mid = (right + left) // 2\n            if is_possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return -1 if not is_possible(left) else left", "watermarked_code": "class Solution:\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) ->int:\n        def is_possible(num_skips):\n            time, skips = 0, 0\n            for d in dist[:-1]:\n                t = math.ceil(d / speed)\n                time += t\n                skips += int(time > hoursBefore)\n                if num_skips > skips:\n                    return False\n                if time + skips > hoursBefore:\n                    return False\n            time += dist[-1] / speed\n            return time <= hoursBefore\n        left, right = 0, len(dist)\n        while right > left:\n            mid = (right + left) // 2\n            if is_possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left if is_possible(left) else -1"}
{"generated_code": "class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_size = 1\n        for k in range(2, min(m, n) + 1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    magic_sum = sum(grid[r][j:j + k] for r in range(i, k + i))\n                    if all(sum(grid[r][j:j + k]) == magic_sum for r in\n                            range(i, k + i)) and all(sum(grid[r][c]) ==\n                            magic_sum for c in range(j, j + k)) and sum(grid[r +\n                            i][j + r] for r in range(k)) == magic_sum and sum(\n                            grid[r + i][j + k - 1 - r] for r in range(k)\n                    ) == magic_sum:\n                        max_size = max(max_size, k)\n        return max_size", "watermarked_code": "class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) ->int:\n        m, n = len(grid), len(grid[0])\n        max_size = 1\n        for k in range(2, min(m, n) + 1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    magic_sum = sum(grid[r][j:j + k] for r in range(i, k + i))\n                    if all(sum(grid[r][j:j + k]) == magic_sum for r in\n                            range(i, k + i)) and all(sum(grid[r][c]) ==\n                            magic_sum for c in range(j, j + k)) and sum(grid[r +\n                            i][j + r] for r in range(k)) == magic_sum and sum(\n                            grid[r + i][j + k - 1 - r] for r in range(k)\n                            ) == magic_sum:\n                        max_size = max(max_size, k)\n        return max_size"}
{"generated_code": "class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_size = 1\n        for k in range(2, min(m, n) + 1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    magic_sum = sum(grid[r][j:j + k] for r in range(i, k + i))\n                    if all(sum(grid[r][j:j + k]) == magic_sum for r in\n                            range(i, k + i)) and all(sum(grid[r][c]) ==\n                            magic_sum for c in range(j, j + k)) and sum(grid[r +\n                            i][j + r] for r in range(k)) == magic_sum and sum(\n                            grid[r + i][j + k - 1 - r] for r in range(k)\n                    ) == magic_sum:\n                        max_size = max(max_size, k)\n        return max_size", "watermarked_code": "class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) ->int:\n        m, n = len(grid), len(grid[0])\n        max_size = 1\n        for k in range(2, min(m, n) + 1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    magic_sum = sum(grid[r][j:j + k] for r in range(i, k + i))\n                    if all(sum(grid[r][j:j + k]) == magic_sum for r in\n                            range(i, k + i)) and all(sum(grid[r][c]) ==\n                            magic_sum for c in range(j, j + k)) and sum(grid[r +\n                            i][j + r] for r in range(k)) == magic_sum and sum(\n                            grid[r + i][j + k - 1 - r] for r in range(k)\n                            ) == magic_sum:\n                        max_size = max(max_size, k)\n        return max_size"}
{"generated_code": "class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_size = 1\n        for k in range(2, min(m, n) + 1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    magic_sum = sum(grid[r][j:j + k] for r in range(i, k + i))\n                    if all(sum(grid[r][j:j + k]) == magic_sum for r in\n                            range(i, k + i)) and all(sum(grid[r][c]) ==\n                            magic_sum for c in range(j, j + k)) and sum(grid[r +\n                            i][j + r] for r in range(k)) == magic_sum and sum(\n                            grid[r + i][j + k - 1 - r] for r in range(k)\n                    ) == magic_sum:\n                        max_size = max(max_size, k)\n        return max_size", "watermarked_code": "class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) ->int:\n        m, n = len(grid), len(grid[0])\n        max_size = 1\n        for k in range(2, min(m, n) + 1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    magic_sum = sum(grid[r][j:j + k] for r in range(i, k + i))\n                    if all(sum(grid[r][j:j + k]) == magic_sum for r in\n                            range(i, k + i)) and all(sum(grid[r][c]) ==\n                            magic_sum for c in range(j, j + k)) and sum(grid[r +\n                            i][j + r] for r in range(k)) == magic_sum and sum(\n                            grid[r + i][j + k - 1 - r] for r in range(k)\n                            ) == magic_sum:\n                        max_size = max(max_size, k)\n        return max_size"}
{"generated_code": "from typing import List\nclass Solution:\n    def makeEqual(self, words: List[str]) -> bool:\n        freq = {}\n        for word in words:\n            for char in word:\n                if char in freq:\n                    freq[char] += 1\n                else:\n                    freq[char] = 1\n        return all(value % len(words) == 0 for char, value in freq.items())", "watermarked_code": "from typing import List\nclass Solution:\n    def makeEqual(self, words: List[str]) ->bool:\n        freq = {}\n        for word in words:\n            for char in word:\n                if char in freq:\n                    freq[char] += 1\n                else:\n                    freq[char] = 1\n        return all(value % len(words) == 0 for char, value in freq.items())"}
{"generated_code": "class Solution:\n    def sumGame(self, num: str) -> bool:\n        first_half_sum = 0\n        second_half_sum = 0\n        for i in range(len(num)):\n            if i < len(num) // 2:\n                first_half_sum += 4.5 if num[i] == '?' else int(num[i])\n            else:\n                second_half_sum += 4.5 if num[i] == '?' else int(num[i])\n        if first_half_sum == second_half_sum:\n            return False\n        first_half_unknowns = num[:len(num) // 2].count('?')\n        second_half_unknowns = num[len(num) // 2:].count('?')\n        if first_half_unknowns == second_half_unknowns:\n            return True\n        return first_half_unknowns > second_half_unknowns\n        return False", "watermarked_code": "class Solution:\n    def sumGame(self, num: str) ->bool:\n        first_half_sum = 0\n        second_half_sum = 0\n        for i in range(len(num)):\n            if i < len(num) // 2:\n                first_half_sum += 4.5 if num[i] == '?' else int(num[i])\n            else:\n                second_half_sum += 4.5 if num[i] == '?' else int(num[i])\n        if first_half_sum == second_half_sum:\n            return False\n        first_half_unknowns = num[:len(num) // 2].count('?')\n        second_half_unknowns = num[len(num) // 2:].count('?')\n        if first_half_unknowns == second_half_unknowns:\n            return True\n        return first_half_unknowns > second_half_unknowns"}
{"generated_code": "class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees:\n            List[int]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        n = len(passingFees)\n        dp = [([float('inf')] * (maxTime + 1)) for _ in range(n)]\n        dp[0][0] = passingFees[0]\n        for t in range(maxTime):\n            for u in range(n):\n                if dp[u][t] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if w + t <= maxTime:\n                        dp[v][w + t] = min(dp[v][w + t], dp[u][t] +\n                            passingFees[v])\n        return -1 if dp[n - 1][maxTime] == float('inf') else dp[n - 1][maxTime]", "watermarked_code": "class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees:\n            List[int]) ->int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        n = len(passingFees)\n        dp = [([float('inf')] * (maxTime + 1)) for _ in range(n)]\n        dp[0][0] = passingFees[0]\n        for t in range(maxTime):\n            for u in range(n):\n                if dp[u][t] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if w + t <= maxTime:\n                        dp[v][w + t] = min(dp[v][w + t], dp[u][t] +\n                            passingFees[v])\n        return -1 if dp[n - 1][maxTime] == float('inf') else dp[n - 1][maxTime]"}
{"generated_code": "class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees:\n            List[int]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        n = len(passingFees)\n        dp = [([float('inf')] * (maxTime + 1)) for _ in range(n)]\n        dp[0][0] = passingFees[0]\n        for t in range(maxTime):\n            for u in range(n):\n                if dp[u][t] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if w + t <= maxTime:\n                        dp[v][w + t] = min(dp[v][w + t], dp[u][t] +\n                            passingFees[v])\n        return -1 if dp[n - 1][maxTime] == float('inf') else dp[n - 1][maxTime]", "watermarked_code": "class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees:\n            List[int]) ->int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        n = len(passingFees)\n        dp = [([float('inf')] * (maxTime + 1)) for _ in range(n)]\n        dp[0][0] = passingFees[0]\n        for t in range(maxTime):\n            for u in range(n):\n                if dp[u][t] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if w + t <= maxTime:\n                        dp[v][w + t] = min(dp[v][w + t], dp[u][t] +\n                            passingFees[v])\n        return -1 if dp[n - 1][maxTime] == float('inf') else dp[n - 1][maxTime]"}
{"generated_code": "class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees:\n            List[int]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        n = len(passingFees)\n        dp = [([float('inf')] * (maxTime + 1)) for _ in range(n)]\n        dp[0][0] = passingFees[0]\n        for t in range(maxTime):\n            for u in range(n):\n                if dp[u][t] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if w + t <= maxTime:\n                        dp[v][w + t] = min(dp[v][w + t], dp[u][t] +\n                            passingFees[v])\n        return -1 if dp[n - 1][maxTime] == float('inf') else dp[n - 1][maxTime]", "watermarked_code": "class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees:\n            List[int]) ->int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        n = len(passingFees)\n        dp = [([float('inf')] * (maxTime + 1)) for _ in range(n)]\n        dp[0][0] = passingFees[0]\n        for t in range(maxTime):\n            for u in range(n):\n                if dp[u][t] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if w + t <= maxTime:\n                        dp[v][w + t] = min(dp[v][w + t], dp[u][t] +\n                            passingFees[v])\n        return -1 if dp[n - 1][maxTime] == float('inf') else dp[n - 1][maxTime]"}
{"generated_code": "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.freq = 0\nclass Trie:\n    def __init__(self, values):\n        self.root = TrieNode(-1)\n        self.values = values\n        self.n = len(values)\n        self.log_n = -1\n        while 1 << self.log_n + 1 <= self.n:\n            self.log_n += 1\n        self.parents = [-1] * self.n\n        for v in range(1, self.n):\n            p = parents[v]\n            self.parents[v] = self.root if p == -1 else values[p]\n        self.max_bits = []\n        node = self.root\n        for _ in range(self.log_n, -1, -1):\n            next_node = node.children.get(1)\n            if next_node is None:\n                next_node = TrieNode(1)\n                node.children[1] = next_node\n            node = next_node\n            self.max_bits.append(node)\n    def findBest(self, u, val):\n        curr_node = self.values[u]\n        for i, max_bit in enumerate(self.max_bits):\n            mask = 1 << i\n            if val & mask:\n                next_node = curr_node.children.get(0)\n            else:\n                next_node = curr_node.children.get(1)\n            curr_node = (max_bit if next_node is None or next_node.freq == \n                0 else next_node)\n        return val ^ curr_node.val\nclass Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]\n            ) -> List[int]:\n        n = len(parents)\n        values = [TrieNode(i) for i in range(n)]\n        root = None\n        for i in range(n):\n            p = parents[i]\n            if p == -1:\n                root = values[i]\n            else:\n                values[p].children[i] = values[i]\n        trie = Trie(values)\n        trie.root.freq = n\n        return [trie.findBest(node, val) for node, val in queries]", "watermarked_code": "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.freq = 0\nclass Trie:\n    def __init__(self, values):\n        self.root = TrieNode(-1)\n        self.values = values\n        self.n = len(values)\n        self.log_n = -1\n        while 1 << self.log_n + 1 <= self.n:\n            self.log_n += 1\n        self.parents = [-1] * self.n\n        for v in range(1, self.n):\n            p = parents[v]\n            self.parents[v] = self.root if p == -1 else values[p]\n        self.max_bits = []\n        node = self.root\n        for _ in range(self.log_n, -1, -1):\n            next_node = node.children.get(1)\n            if next_node is None:\n                next_node = TrieNode(1)\n                node.children[1] = next_node\n            node = next_node\n            self.max_bits.append(node)\n    def findBest(self, u, val):\n        curr_node = self.values[u]\n        for i, max_bit in enumerate(self.max_bits):\n            mask = 1 << i\n            if val & mask:\n                next_node = curr_node.children.get(0)\n            else:\n                next_node = curr_node.children.get(1)\n            curr_node = (max_bit if next_node is None or next_node.freq == \n                0 else next_node)\n        return val ^ curr_node.val\nclass Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]\n            ) ->List[int]:\n        n = len(parents)\n        values = [TrieNode(i) for i in range(n)]\n        root = None\n        for i in range(n):\n            p = parents[i]\n            if p == -1:\n                root = values[i]\n            else:\n                values[p].children[i] = values[i]\n        trie = Trie(values)\n        trie.root.freq = n\n        return [trie.findBest(node, val) for node, val in queries]"}
{"generated_code": "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.freq = 0\nclass Trie:\n    def __init__(self, values):\n        self.root = TrieNode(-1)\n        self.values = values\n        self.n = len(values)\n        self.log_n = -1\n        while 1 << self.log_n + 1 <= self.n:\n            self.log_n += 1\n        self.parents = [-1] * self.n\n        for v in range(1, self.n):\n            p = parents[v]\n            self.parents[v] = self.root if p == -1 else values[p]\n        self.max_bits = []\n        node = self.root\n        for _ in range(self.log_n, -1, -1):\n            next_node = node.children.get(1)\n            if next_node is None:\n                next_node = TrieNode(1)\n                node.children[1] = next_node\n            node = next_node\n            self.max_bits.append(node)\n    def findBest(self, u, val):\n        curr_node = self.values[u]\n        for i, max_bit in enumerate(self.max_bits):\n            mask = 1 << i\n            if val & mask:\n                next_node = curr_node.children.get(0)\n            else:\n                next_node = curr_node.children.get(1)\n            curr_node = (max_bit if next_node is None or next_node.freq == \n                0 else next_node)\n        return val ^ curr_node.val\nclass Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]\n            ) -> List[int]:\n        n = len(parents)\n        values = [TrieNode(i) for i in range(n)]\n        root = None\n        for i in range(n):\n            p = parents[i]\n            if p == -1:\n                root = values[i]\n            else:\n                values[p].children[i] = values[i]\n        trie = Trie(values)\n        trie.root.freq = n\n        return [trie.findBest(node, val) for node, val in queries]", "watermarked_code": "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.freq = 0\nclass Trie:\n    def __init__(self, values):\n        self.root = TrieNode(-1)\n        self.values = values\n        self.n = len(values)\n        self.log_n = -1\n        while 1 << self.log_n + 1 <= self.n:\n            self.log_n += 1\n        self.parents = [-1] * self.n\n        for v in range(1, self.n):\n            p = parents[v]\n            self.parents[v] = self.root if p == -1 else values[p]\n        self.max_bits = []\n        node = self.root\n        for _ in range(self.log_n, -1, -1):\n            next_node = node.children.get(1)\n            if next_node is None:\n                next_node = TrieNode(1)\n                node.children[1] = next_node\n            node = next_node\n            self.max_bits.append(node)\n    def findBest(self, u, val):\n        curr_node = self.values[u]\n        for i, max_bit in enumerate(self.max_bits):\n            mask = 1 << i\n            if val & mask:\n                next_node = curr_node.children.get(0)\n            else:\n                next_node = curr_node.children.get(1)\n            curr_node = (max_bit if next_node is None or next_node.freq == \n                0 else next_node)\n        return val ^ curr_node.val\nclass Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]\n            ) ->List[int]:\n        n = len(parents)\n        values = [TrieNode(i) for i in range(n)]\n        root = None\n        for i in range(n):\n            p = parents[i]\n            if p == -1:\n                root = values[i]\n            else:\n                values[p].children[i] = values[i]\n        trie = Trie(values)\n        trie.root.freq = n\n        return [trie.findBest(node, val) for node, val in queries]"}
{"generated_code": "class Solution:\n    def isThree(self, n: int) -> bool:\n        count = sum(bool(n % i == 0) for i in range(1, n + 1))\n        return count == 3\nsol = Solution()\nprint(sol.isThree(2))\nprint(sol.isThree(4))", "watermarked_code": "class Solution:\n    def isThree(self, n: int) ->bool:\n        count = sum(n % i == 0 for i in range(1, n + 1))\n        return count == 3\nsol = Solution()\nprint(sol.isThree(2))\nprint(sol.isThree(4))"}
{"generated_code": "class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int,\n            color: str) -> bool:\n        def goodLine(line: List[str], c: str) -> bool:\n            if c not in line:\n                return False\n            i = line.index(c)\n            if i > 3 or len(line) - i > 5:\n                return False\n            window = line[max(0, i - 3):min(len(line), i + 4)]\n            return ''.join(window).count(c) == 3 and '.' not in window\n        line = [cell for cell in board[rMove] if cell != '.']\n        if goodLine(line, color):\n            return True\n        line = [board[i][cMove] for i in range(8) if board[i][cMove] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, cMove), cMove - min(rMove, cMove)\n        end_r, end_c = rMove + min(7 - rMove, 7 - cMove), cMove + min(7 -\n            rMove, 7 - cMove)\n        line = [board[start_r + i][start_c + i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c + i] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, 7 - cMove), cMove + min(rMove,\n            7 - cMove)\n        end_r, end_c = rMove + min(7 - rMove, cMove), cMove - min(7 - rMove,\n            cMove)\n        line = [board[start_r + i][start_c - i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c - i] != '.']\n        return bool(goodLine(line, color))", "watermarked_code": "class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int,\n            color: str) ->bool:\n        def goodLine(line: List[str], c: str) ->bool:\n            if c not in line:\n                return False\n            i = line.index(c)\n            if i > 3 or len(line) - i > 5:\n                return False\n            window = line[max(0, i - 3):min(len(line), i + 4)]\n            return ''.join(window).count(c) == 3 and '.' not in window\n        line = [cell for cell in board[rMove] if cell != '.']\n        if goodLine(line, color):\n            return True\n        line = [board[i][cMove] for i in range(8) if board[i][cMove] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, cMove), cMove - min(rMove, cMove)\n        end_r, end_c = rMove + min(7 - rMove, 7 - cMove), cMove + min(7 -\n            rMove, 7 - cMove)\n        line = [board[start_r + i][start_c + i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c + i] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, 7 - cMove), cMove + min(rMove,\n            7 - cMove)\n        end_r, end_c = rMove + min(7 - rMove, cMove), cMove - min(7 - rMove,\n            cMove)\n        line = [board[start_r + i][start_c - i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c - i] != '.']\n        return bool(goodLine(line, color))"}
{"generated_code": "class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int,\n            color: str) -> bool:\n        def goodLine(line: List[str], c: str) -> bool:\n            if c not in line:\n                return False\n            i = line.index(c)\n            if i > 3 or len(line) - i > 5:\n                return False\n            window = line[max(0, i - 3):min(len(line), i + 4)]\n            return ''.join(window).count(c) == 3 and '.' not in window\n        line = [cell for cell in board[rMove] if cell != '.']\n        if goodLine(line, color):\n            return True\n        line = [board[i][cMove] for i in range(8) if board[i][cMove] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, cMove), cMove - min(rMove, cMove)\n        end_r, end_c = rMove + min(7 - rMove, 7 - cMove), cMove + min(7 -\n            rMove, 7 - cMove)\n        line = [board[start_r + i][start_c + i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c + i] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, 7 - cMove), cMove + min(rMove,\n            7 - cMove)\n        end_r, end_c = rMove + min(7 - rMove, cMove), cMove - min(7 - rMove,\n            cMove)\n        line = [board[start_r + i][start_c - i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c - i] != '.']\n        return bool(goodLine(line, color))", "watermarked_code": "class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int,\n            color: str) ->bool:\n        def goodLine(line: List[str], c: str) ->bool:\n            if c not in line:\n                return False\n            i = line.index(c)\n            if i > 3 or len(line) - i > 5:\n                return False\n            window = line[max(0, i - 3):min(len(line), i + 4)]\n            return ''.join(window).count(c) == 3 and '.' not in window\n        line = [cell for cell in board[rMove] if cell != '.']\n        if goodLine(line, color):\n            return True\n        line = [board[i][cMove] for i in range(8) if board[i][cMove] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, cMove), cMove - min(rMove, cMove)\n        end_r, end_c = rMove + min(7 - rMove, 7 - cMove), cMove + min(7 -\n            rMove, 7 - cMove)\n        line = [board[start_r + i][start_c + i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c + i] != '.']\n        if goodLine(line, color):\n            return True\n        start_r, start_c = rMove - min(rMove, 7 - cMove), cMove + min(rMove,\n            7 - cMove)\n        end_r, end_c = rMove + min(7 - rMove, cMove), cMove - min(7 - rMove,\n            cMove)\n        line = [board[start_r + i][start_c - i] for i in range(end_r -\n            start_r + 1) if board[start_r + i][start_c - i] != '.']\n        return bool(goodLine(line, color))"}
{"generated_code": "from typing import List\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]\n            ) -> int:\n        def can_cross(day):\n            grid = [([0] * col) for _ in range(row)]\n            for i in range(day):\n                r, c = cells[i]\n                grid[r - 1][c - 1] = 1\n            queue = [(0, c) for c in range(col) if grid[0][c] == 0]\n            while queue:\n                r, c = queue.pop(0)\n                if r == row - 1:\n                    return True\n                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nr, nc = r + dr, dc + c\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        queue.append((nr, nc))\n            return False\n        left, right = 0, len(cells) - 1\n        while right > left:\n            mid = (right + left + 1) // 2\n            if can_cross(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left + 1", "watermarked_code": "from typing import List\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]\n            ) ->int:\n        def can_cross(day):\n            grid = [([0] * col) for _ in range(row)]\n            for i in range(day):\n                r, c = cells[i]\n                grid[r - 1][c - 1] = 1\n            queue = [(0, c) for c in range(col) if grid[0][c] == 0]\n            while queue:\n                r, c = queue.pop(0)\n                if r == row - 1:\n                    return True\n                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nr, nc = r + dr, dc + c\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        queue.append((nr, nc))\n            return False\n        left, right = 0, len(cells) - 1\n        while right > left:\n            mid = (right + left + 1) // 2\n            if can_cross(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left + 1"}
{"generated_code": "from typing import List\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]\n            ) -> int:\n        def can_cross(day):\n            grid = [([0] * col) for _ in range(row)]\n            for i in range(day):\n                r, c = cells[i]\n                grid[r - 1][c - 1] = 1\n            queue = [(0, c) for c in range(col) if grid[0][c] == 0]\n            while queue:\n                r, c = queue.pop(0)\n                if r == row - 1:\n                    return True\n                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nr, nc = r + dr, dc + c\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        queue.append((nr, nc))\n            return False\n        left, right = 0, len(cells) - 1\n        while right > left:\n            mid = (right + left + 1) // 2\n            if can_cross(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left + 1", "watermarked_code": "from typing import List\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]\n            ) ->int:\n        def can_cross(day):\n            grid = [([0] * col) for _ in range(row)]\n            for i in range(day):\n                r, c = cells[i]\n                grid[r - 1][c - 1] = 1\n            queue = [(0, c) for c in range(col) if grid[0][c] == 0]\n            while queue:\n                r, c = queue.pop(0)\n                if r == row - 1:\n                    return True\n                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nr, nc = r + dr, dc + c\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        queue.append((nr, nc))\n            return False\n        left, right = 0, len(cells) - 1\n        while right > left:\n            mid = (right + left + 1) // 2\n            if can_cross(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left + 1"}
{"generated_code": "from typing import List\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]\n            ) -> int:\n        def can_cross(day):\n            grid = [([0] * col) for _ in range(row)]\n            for i in range(day):\n                r, c = cells[i]\n                grid[r - 1][c - 1] = 1\n            queue = [(0, c) for c in range(col) if grid[0][c] == 0]\n            while queue:\n                r, c = queue.pop(0)\n                if r == row - 1:\n                    return True\n                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nr, nc = r + dr, dc + c\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        queue.append((nr, nc))\n            return False\n        left, right = 0, len(cells) - 1\n        while right > left:\n            mid = (right + left + 1) // 2\n            if can_cross(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left + 1", "watermarked_code": "from typing import List\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]\n            ) ->int:\n        def can_cross(day):\n            grid = [([0] * col) for _ in range(row)]\n            for i in range(day):\n                r, c = cells[i]\n                grid[r - 1][c - 1] = 1\n            queue = [(0, c) for c in range(col) if grid[0][c] == 0]\n            while queue:\n                r, c = queue.pop(0)\n                if r == row - 1:\n                    return True\n                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nr, nc = r + dr, dc + c\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        queue.append((nr, nc))\n            return False\n        left, right = 0, len(cells) - 1\n        while right > left:\n            mid = (right + left + 1) // 2\n            if can_cross(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left + 1"}
{"generated_code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[\n            List[int]]:\n        if n * m != len(original):\n            return []\n        return [original[i:n + i] for i in range(0, len(original), n)]", "watermarked_code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) ->List[\n            List[int]]:\n        if n * m != len(original):\n            return []\n        return [original[i:n + i] for i in range(0, len(original), n)]"}
{"generated_code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[\n            List[int]]:\n        if n * m != len(original):\n            return []\n        return [original[i:n + i] for i in range(0, len(original), n)]", "watermarked_code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) ->List[\n            List[int]]:\n        if n * m != len(original):\n            return []\n        return [original[i:n + i] for i in range(0, len(original), n)]"}
{"generated_code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[\n            List[int]]:\n        if n * m != len(original):\n            return []\n        return [original[i:n + i] for i in range(0, len(original), n)]", "watermarked_code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) ->List[\n            List[int]]:\n        if n * m != len(original):\n            return []\n        return [original[i:n + i] for i in range(0, len(original), n)]"}
{"generated_code": "class Solution:\n    def waysToPartition(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        left_sum = [0] * n\n        right_sum = [0] * n\n        left_sum[0] = nums[0]\n        for i in range(1, n):\n            left_sum[i] = left_sum[i - 1] + nums[i]\n        right_sum[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + nums[i]\n        prefix_sum = left_sum[n - 1]\n        max_count = sum(bool(left_sum[i] == right_sum[i + 1]) for i in\n            range(n - 1))\n        for i in range(n):\n            new_val = k - nums[i]\n            new_prefix_sum = prefix_sum + new_val\n            left_sum_val = left_sum[i - 1] if i > 0 else 0\n            right_sum_val = right_sum[i + 1] if i < n - 1 else 0\n            if new_prefix_sum == right_sum_val + left_sum_val:\n                max_count = max(max_count, 1) if i == n - 1 else max(max_count,\n                    2)\n            else:\n                if i == n - 1:\n                    continue\n                if (new_prefix_sum > right_sum_val + left_sum_val and \n                    left_sum_val < new_prefix_sum < right_sum_val):\n                    max_count = max(max_count, 1)\n        return max_count", "watermarked_code": "class Solution:\n    def waysToPartition(self, nums: List[int], k: int) ->int:\n        n = len(nums)\n        left_sum = [0] * n\n        right_sum = [0] * n\n        left_sum[0] = nums[0]\n        for i in range(1, n):\n            left_sum[i] = left_sum[i - 1] + nums[i]\n        right_sum[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + nums[i]\n        prefix_sum = left_sum[n - 1]\n        max_count = sum(left_sum[i] == right_sum[i + 1] for i in range(n - 1))\n        for i in range(n):\n            new_val = k - nums[i]\n            new_prefix_sum = prefix_sum + new_val\n            left_sum_val = left_sum[i - 1] if i > 0 else 0\n            right_sum_val = right_sum[i + 1] if i < n - 1 else 0\n            if new_prefix_sum == right_sum_val + left_sum_val:\n                max_count = max(max_count, 1) if i == n - 1 else max(max_count,\n                    2)\n            else:\n                if i == n - 1:\n                    continue\n                if (new_prefix_sum > right_sum_val + left_sum_val and \n                    left_sum_val < new_prefix_sum < right_sum_val):\n                    max_count = max(max_count, 1)\n        return max_count"}
{"generated_code": "class Solution:\n    def waysToPartition(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        left_sum = [0] * n\n        right_sum = [0] * n\n        left_sum[0] = nums[0]\n        for i in range(1, n):\n            left_sum[i] = left_sum[i - 1] + nums[i]\n        right_sum[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + nums[i]\n        prefix_sum = left_sum[n - 1]\n        max_count = sum(bool(left_sum[i] == right_sum[i + 1]) for i in\n            range(n - 1))\n        for i in range(n):\n            new_val = k - nums[i]\n            new_prefix_sum = prefix_sum + new_val\n            left_sum_val = left_sum[i - 1] if i > 0 else 0\n            right_sum_val = right_sum[i + 1] if i < n - 1 else 0\n            if new_prefix_sum == right_sum_val + left_sum_val:\n                max_count = max(max_count, 1) if i == n - 1 else max(max_count,\n                    2)\n            else:\n                if i == n - 1:\n                    continue\n                if (new_prefix_sum > right_sum_val + left_sum_val and \n                    left_sum_val < new_prefix_sum < right_sum_val):\n                    max_count = max(max_count, 1)\n        return max_count", "watermarked_code": "class Solution:\n    def waysToPartition(self, nums: List[int], k: int) ->int:\n        n = len(nums)\n        left_sum = [0] * n\n        right_sum = [0] * n\n        left_sum[0] = nums[0]\n        for i in range(1, n):\n            left_sum[i] = left_sum[i - 1] + nums[i]\n        right_sum[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + nums[i]\n        prefix_sum = left_sum[n - 1]\n        max_count = sum(left_sum[i] == right_sum[i + 1] for i in range(n - 1))\n        for i in range(n):\n            new_val = k - nums[i]\n            new_prefix_sum = prefix_sum + new_val\n            left_sum_val = left_sum[i - 1] if i > 0 else 0\n            right_sum_val = right_sum[i + 1] if i < n - 1 else 0\n            if new_prefix_sum == right_sum_val + left_sum_val:\n                max_count = max(max_count, 1) if i == n - 1 else max(max_count,\n                    2)\n            else:\n                if i == n - 1:\n                    continue\n                if (new_prefix_sum > right_sum_val + left_sum_val and \n                    left_sum_val < new_prefix_sum < right_sum_val):\n                    max_count = max(max_count, 1)\n        return max_count"}
{"generated_code": "class Solution:\n    def stoneGameIX(self, stones: List[int]) -> bool:\n        mods = [0, 0, 0]\n        for i in stones:\n            mods[i % 3] += 1\n        if mods[0] == 0:\n            return False\n        if abs(mods[1] - mods[2]) < 2:\n            return True\n        if mods[1] > mods[2]:\n            return canWin(mods[0], mods[1] - 1, mods[2])\n        else:\n            return canWin(mods[0], mods[1], mods[2] - 1)\n    def canWin(a, b, c):\n        return (a % 2 != 0 or b % 2 != 0 or c % 2 != 0) and (a % 2 != 1 or \n            b % 2 != 1 or c % 2 != 1)", "watermarked_code": "class Solution:\n    def stoneGameIX(self, stones: List[int]) ->bool:\n        mods = [0, 0, 0]\n        for i in stones:\n            mods[i % 3] += 1\n        if mods[0] == 0:\n            return False\n        if abs(mods[1] - mods[2]) < 2:\n            return True\n        if mods[1] > mods[2]:\n            return canWin(mods[0], mods[1] - 1, mods[2])\n        else:\n            return canWin(mods[0], mods[1], mods[2] - 1)\n    def canWin(self, b, c):\n        return (self % 2 != 0 or b % 2 != 0 or c % 2 != 0) and (self % 2 !=\n            1 or b % 2 != 1 or c % 2 != 1)"}
{"generated_code": "class Solution:\n    def winnerOfGame(self, colors: str) -> bool:\n        a_count = [0] * len(colors)\n        b_count = [0] * len(colors)\n        for i in range(1, len(colors) - 1):\n            if colors[i] == 'A' and colors[i - 1] == 'A' and colors[i + 1\n                    ] == 'A':\n                a_count[i] = a_count[i - 1] + 1\n            else:\n                a_count[i] = a_count[i - 1]\n            if colors[i] == 'B' and colors[i - 1] == 'B' and colors[i + 1\n                    ] == 'B':\n                b_count[i] = b_count[i - 1] + 1\n            else:\n                b_count[i] = b_count[i - 1]\n        alice_moves = [(a_count[i] - a_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'A']\n        if sum(alice_moves) > 0:\n            return True\n        bob_moves = [(b_count[i] - b_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'B']\n        return False", "watermarked_code": "class Solution:\n    def winnerOfGame(self, colors: str) ->bool:\n        a_count = [0] * len(colors)\n        b_count = [0] * len(colors)\n        for i in range(1, len(colors) - 1):\n            if colors[i] == 'A' and colors[i - 1] == 'A' and colors[i + 1\n                    ] == 'A':\n                a_count[i] = a_count[i - 1] + 1\n            else:\n                a_count[i] = a_count[i - 1]\n            if colors[i] == 'B' and colors[i - 1] == 'B' and colors[i + 1\n                    ] == 'B':\n                b_count[i] = b_count[i - 1] + 1\n            else:\n                b_count[i] = b_count[i - 1]\n        alice_moves = [(a_count[i] - a_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'A']\n        if sum(alice_moves) > 0:\n            return True\n        bob_moves = [(b_count[i] - b_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'B']\n        return False"}
{"generated_code": "class Solution:\n    def winnerOfGame(self, colors: str) -> bool:\n        a_count = [0] * len(colors)\n        b_count = [0] * len(colors)\n        for i in range(1, len(colors) - 1):\n            if colors[i] == 'A' and colors[i - 1] == 'A' and colors[i + 1\n                    ] == 'A':\n                a_count[i] = a_count[i - 1] + 1\n            else:\n                a_count[i] = a_count[i - 1]\n            if colors[i] == 'B' and colors[i - 1] == 'B' and colors[i + 1\n                    ] == 'B':\n                b_count[i] = b_count[i - 1] + 1\n            else:\n                b_count[i] = b_count[i - 1]\n        alice_moves = [(a_count[i] - a_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'A']\n        if sum(alice_moves) > 0:\n            return True\n        bob_moves = [(b_count[i] - b_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'B']\n        return False", "watermarked_code": "class Solution:\n    def winnerOfGame(self, colors: str) ->bool:\n        a_count = [0] * len(colors)\n        b_count = [0] * len(colors)\n        for i in range(1, len(colors) - 1):\n            if colors[i] == 'A' and colors[i - 1] == 'A' and colors[i + 1\n                    ] == 'A':\n                a_count[i] = a_count[i - 1] + 1\n            else:\n                a_count[i] = a_count[i - 1]\n            if colors[i] == 'B' and colors[i - 1] == 'B' and colors[i + 1\n                    ] == 'B':\n                b_count[i] = b_count[i - 1] + 1\n            else:\n                b_count[i] = b_count[i - 1]\n        alice_moves = [(a_count[i] - a_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'A']\n        if sum(alice_moves) > 0:\n            return True\n        bob_moves = [(b_count[i] - b_count[i - 1]) for i in range(1, len(\n            colors) - 1) if colors[i] == 'B']\n        return False"}
{"generated_code": "class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int\n            ) -> int:\n        import heapq\n        def count_pairs(val):\n            count = 0\n            j = len(nums2) - 1\n            for i in range(len(nums1)):\n                while j >= 0 and nums1[i] * nums2[j] > val:\n                    j -= 1\n                count += j + 1\n            return count\n        left = nums1[0] * nums2[0]\n        right = nums1[-1] * nums2[-1]\n        while right >= left:\n            mid = (right + left) // 2\n            if count_pairs(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans", "watermarked_code": "class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int\n            ) ->int:\n        import heapq\n        def count_pairs(val):\n            count = 0\n            j = len(nums2) - 1\n            for i in range(len(nums1)):\n                while j >= 0 and nums1[i] * nums2[j] > val:\n                    j -= 1\n                count += j + 1\n            return count\n        left = nums1[0] * nums2[0]\n        right = nums1[-1] * nums2[-1]\n        while right >= left:\n            mid = (right + left) // 2\n            if count_pairs(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans"}
{"generated_code": "class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int\n            ) -> int:\n        import heapq\n        def count_pairs(val):\n            count = 0\n            j = len(nums2) - 1\n            for i in range(len(nums1)):\n                while j >= 0 and nums1[i] * nums2[j] > val:\n                    j -= 1\n                count += j + 1\n            return count\n        left = nums1[0] * nums2[0]\n        right = nums1[-1] * nums2[-1]\n        while right >= left:\n            mid = (right + left) // 2\n            if count_pairs(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans", "watermarked_code": "class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int\n            ) ->int:\n        import heapq\n        def count_pairs(val):\n            count = 0\n            j = len(nums2) - 1\n            for i in range(len(nums1)):\n                while j >= 0 and nums1[i] * nums2[j] > val:\n                    j -= 1\n                count += j + 1\n            return count\n        left = nums1[0] * nums2[0]\n        right = nums1[-1] * nums2[-1]\n        while right >= left:\n            mid = (right + left) // 2\n            if count_pairs(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans"}
{"generated_code": "class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int\n            ) -> int:\n        import heapq\n        def count_pairs(val):\n            count = 0\n            j = len(nums2) - 1\n            for i in range(len(nums1)):\n                while j >= 0 and nums1[i] * nums2[j] > val:\n                    j -= 1\n                count += j + 1\n            return count\n        left = nums1[0] * nums2[0]\n        right = nums1[-1] * nums2[-1]\n        while right >= left:\n            mid = (right + left) // 2\n            if count_pairs(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans", "watermarked_code": "class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int\n            ) ->int:\n        import heapq\n        def count_pairs(val):\n            count = 0\n            j = len(nums2) - 1\n            for i in range(len(nums1)):\n                while j >= 0 and nums1[i] * nums2[j] > val:\n                    j -= 1\n                count += j + 1\n            return count\n        left = nums1[0] * nums2[0]\n        right = nums1[-1] * nums2[-1]\n        while right >= left:\n            mid = (right + left) // 2\n            if count_pairs(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans"}
{"generated_code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        st_map = {}\n        for i in range(len(s)):\n            if s[i] in st_map:\n                if st_map[s[i]] != t[i]:\n                    return False\n            elif t[i] in st_map.values():\n                return False\n            else:\n                st_map[s[i]] = t[i]\n        return True", "watermarked_code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) ->bool:\n        if len(s) != len(t):\n            return False\n        st_map = {}\n        for i in range(len(s)):\n            if s[i] in st_map:\n                if st_map[s[i]] != t[i]:\n                    return False\n            elif t[i] in st_map.values():\n                return False\n            else:\n                st_map[s[i]] = t[i]\n        return True"}
{"generated_code": "class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]],\n            maxTime: int) -> int:\n        adjacency_list = [[] for _ in range(len(values))]\n        for edge in edges:\n            adjacency_list[edge[0]].append((edge[1], edge[2]))\n            adjacency_list[edge[1]].append((edge[0], edge[2]))\n        visited = [False] * len(values)\n        visited[0] = True\n        queue = [(0, values[0], 0)]\n        max_quality = 0\n        while queue:\n            node, curr_quality, curr_time = queue.pop(0)\n            if maxTime >= curr_time:\n                if node == 0:\n                    max_quality = max(max_quality, curr_quality)\n                for neighbor, time in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, curr_quality + values[\n                            neighbor], time + curr_time))\n            visited[node] = False\n        return max_quality", "watermarked_code": "class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]],\n            maxTime: int) ->int:\n        adjacency_list = [[] for _ in range(len(values))]\n        for edge in edges:\n            adjacency_list[edge[0]].append((edge[1], edge[2]))\n            adjacency_list[edge[1]].append((edge[0], edge[2]))\n        visited = [False] * len(values)\n        visited[0] = True\n        queue = [(0, values[0], 0)]\n        max_quality = 0\n        while queue:\n            node, curr_quality, curr_time = queue.pop(0)\n            if maxTime >= curr_time:\n                if node == 0:\n                    max_quality = max(max_quality, curr_quality)\n                for neighbor, time in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, curr_quality + values[\n                            neighbor], time + curr_time))\n            visited[node] = False\n        return max_quality"}
{"generated_code": "class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]],\n            maxTime: int) -> int:\n        adjacency_list = [[] for _ in range(len(values))]\n        for edge in edges:\n            adjacency_list[edge[0]].append((edge[1], edge[2]))\n            adjacency_list[edge[1]].append((edge[0], edge[2]))\n        visited = [False] * len(values)\n        visited[0] = True\n        queue = [(0, values[0], 0)]\n        max_quality = 0\n        while queue:\n            node, curr_quality, curr_time = queue.pop(0)\n            if maxTime >= curr_time:\n                if node == 0:\n                    max_quality = max(max_quality, curr_quality)\n                for neighbor, time in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, curr_quality + values[\n                            neighbor], time + curr_time))\n            visited[node] = False\n        return max_quality", "watermarked_code": "class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]],\n            maxTime: int) ->int:\n        adjacency_list = [[] for _ in range(len(values))]\n        for edge in edges:\n            adjacency_list[edge[0]].append((edge[1], edge[2]))\n            adjacency_list[edge[1]].append((edge[0], edge[2]))\n        visited = [False] * len(values)\n        visited[0] = True\n        queue = [(0, values[0], 0)]\n        max_quality = 0\n        while queue:\n            node, curr_quality, curr_time = queue.pop(0)\n            if maxTime >= curr_time:\n                if node == 0:\n                    max_quality = max(max_quality, curr_quality)\n                for neighbor, time in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, curr_quality + values[\n                            neighbor], time + curr_time))\n            visited[node] = False\n        return max_quality"}
{"generated_code": "class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]],\n            maxTime: int) -> int:\n        adjacency_list = [[] for _ in range(len(values))]\n        for edge in edges:\n            adjacency_list[edge[0]].append((edge[1], edge[2]))\n            adjacency_list[edge[1]].append((edge[0], edge[2]))\n        visited = [False] * len(values)\n        visited[0] = True\n        queue = [(0, values[0], 0)]\n        max_quality = 0\n        while queue:\n            node, curr_quality, curr_time = queue.pop(0)\n            if maxTime >= curr_time:\n                if node == 0:\n                    max_quality = max(max_quality, curr_quality)\n                for neighbor, time in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, curr_quality + values[\n                            neighbor], time + curr_time))\n            visited[node] = False\n        return max_quality", "watermarked_code": "class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]],\n            maxTime: int) ->int:\n        adjacency_list = [[] for _ in range(len(values))]\n        for edge in edges:\n            adjacency_list[edge[0]].append((edge[1], edge[2]))\n            adjacency_list[edge[1]].append((edge[0], edge[2]))\n        visited = [False] * len(values)\n        visited[0] = True\n        queue = [(0, values[0], 0)]\n        max_quality = 0\n        while queue:\n            node, curr_quality, curr_time = queue.pop(0)\n            if maxTime >= curr_time:\n                if node == 0:\n                    max_quality = max(max_quality, curr_quality)\n                for neighbor, time in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, curr_quality + values[\n                            neighbor], time + curr_time))\n            visited[node] = False\n        return max_quality"}
{"generated_code": "class Solution:\n    def minimumBuckets(self, hamsters: str) -> int:\n        n = len(hamsters)\n        empty_spaces = hamsters.count('.')\n        if empty_spaces == 0:\n            return 0\n        if empty_spaces < hamsters.count('H') or 'H' not in hamsters:\n            return -1\n        buckets_needed = 0\n        i = 0\n        while n > i:\n            if hamsters[i] == 'H':\n                i += 1\n                continue\n            left = i - 1\n            right = i + 1\n            while left >= 0 and hamsters[left] != 'H':\n                left -= 1\n            while n > right and hamsters[right] != 'H':\n                right += 1\n            if left == -1 and right == n:\n                return -1\n            buckets_needed += 1\n            i = (right + 1 if left == -1 or n > right and i - left > right -\n                i else left + 1)\n        return buckets_needed", "watermarked_code": "class Solution:\n    def minimumBuckets(self, hamsters: str) ->int:\n        n = len(hamsters)\n        empty_spaces = hamsters.count('.')\n        if empty_spaces == 0:\n            return 0\n        if empty_spaces < hamsters.count('H') or 'H' not in hamsters:\n            return -1\n        buckets_needed = 0\n        i = 0\n        while n > i:\n            if hamsters[i] == 'H':\n                i += 1\n                continue\n            left = i - 1\n            right = i + 1\n            while left >= 0 and hamsters[left] != 'H':\n                left -= 1\n            while n > right and hamsters[right] != 'H':\n                right += 1\n            if left == -1 and right == n:\n                return -1\n            buckets_needed += 1\n            i = (right + 1 if left == -1 or n > right and i - left > right -\n                i else left + 1)\n        return buckets_needed"}
{"generated_code": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        start = end = 0\n        min_len = float('inf')\n        current_sum = 0\n        while end < len(nums):\n            current_sum += nums[end]\n            while target <= current_sum:\n                min_len = min(min_len, end - start + 1)\n                current_sum -= nums[start]\n                start += 1\n            end += 1\n        return 0 if min_len == float('inf') else min_len", "watermarked_code": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) ->int:\n        start = end = 0\n        min_len = float('inf')\n        current_sum = 0\n        while end < len(nums):\n            current_sum += nums[end]\n            while target <= current_sum:\n                min_len = min(min_len, end - start + 1)\n                current_sum -= nums[start]\n                start += 1\n            end += 1\n        return 0 if min_len == float('inf') else min_len"}
{"generated_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def getDirections(self, root: Optional[TreeNode], startValue: int,\n            destValue: int) -> str:\n        self.s = None\n        self.t = None\n        def findNodes(root):\n            if root is None:\n                return False\n            if root.val == startValue:\n                self.s = root\n            elif root.val == destValue:\n                self.t = root\n            left = findNodes(root.left)\n            right = findNodes(root.right)\n            return left or right\n        findNodes(root)\n        def findLCA(root, p, q):\n            if root is None or root.val == p.val or root.val == q.val:\n                return root\n            left = findLCA(root.left, p, q)\n            right = findLCA(root.right, p, q)\n            return (root if left is not None and right is not None else \n                left or right)\n        lca = findLCA(root, self.s, self.t)\n        def findPath(root, target, path):\n            if root is None:\n                return False\n            if root.val == target.val:\n                return True\n            path.append('L')\n            if findPath(root.left, target, path):\n                return True\n            path.pop()\n            path.append('R')\n            if findPath(root.right, target, path):\n                return True\n            path.pop()\n            return False\n        s_path = []\n        t_path = []\n        findPath(lca, self.s, s_path)\n        findPath(lca, self.t, t_path)\n        return ''.join(['U' for i in range(len(s_path) - 1)]) + ''.join(\n            reversed(s_path[:-1])) + t_path", "watermarked_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def getDirections(self, root: Optional[TreeNode], startValue: int,\n            destValue: int) ->str:\n        self.s = None\n        self.t = None\n        def findNodes(root):\n            if root is None:\n                return False\n            if root.val == startValue:\n                self.s = root\n            elif root.val == destValue:\n                self.t = root\n            left = findNodes(root.left)\n            right = findNodes(root.right)\n            return left or right\n        findNodes(root)\n        def findLCA(root, p, q):\n            if root is None or root.val == p.val or root.val == q.val:\n                return root\n            left = findLCA(root.left, p, q)\n            right = findLCA(root.right, p, q)\n            return (root if left is not None and right is not None else \n                left or right)\n        lca = findLCA(root, self.s, self.t)\n        def findPath(root, target, path):\n            if root is None:\n                return False\n            if root.val == target.val:\n                return True\n            path.append('L')\n            if findPath(root.left, target, path):\n                return True\n            path.pop()\n            path.append('R')\n            if findPath(root.right, target, path):\n                return True\n            path.pop()\n            return False\n        s_path = []\n        t_path = []\n        findPath(lca, self.s, s_path)\n        findPath(lca, self.t, t_path)\n        return ''.join(['U' for i in range(len(s_path) - 1)]) + ''.join(\n            reversed(s_path[:-1])) + t_path"}
{"generated_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def getDirections(self, root: Optional[TreeNode], startValue: int,\n            destValue: int) -> str:\n        self.s = None\n        self.t = None\n        def findNodes(root):\n            if root is None:\n                return False\n            if root.val == startValue:\n                self.s = root\n            elif root.val == destValue:\n                self.t = root\n            left = findNodes(root.left)\n            right = findNodes(root.right)\n            return left or right\n        findNodes(root)\n        def findLCA(root, p, q):\n            if root is None or root.val == p.val or root.val == q.val:\n                return root\n            left = findLCA(root.left, p, q)\n            right = findLCA(root.right, p, q)\n            return (root if left is not None and right is not None else \n                left or right)\n        lca = findLCA(root, self.s, self.t)\n        def findPath(root, target, path):\n            if root is None:\n                return False\n            if root.val == target.val:\n                return True\n            path.append('L')\n            if findPath(root.left, target, path):\n                return True\n            path.pop()\n            path.append('R')\n            if findPath(root.right, target, path):\n                return True\n            path.pop()\n            return False\n        s_path = []\n        t_path = []\n        findPath(lca, self.s, s_path)\n        findPath(lca, self.t, t_path)\n        return ''.join(['U' for i in range(len(s_path) - 1)]) + ''.join(\n            reversed(s_path[:-1])) + t_path", "watermarked_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def getDirections(self, root: Optional[TreeNode], startValue: int,\n            destValue: int) ->str:\n        self.s = None\n        self.t = None\n        def findNodes(root):\n            if root is None:\n                return False\n            if root.val == startValue:\n                self.s = root\n            elif root.val == destValue:\n                self.t = root\n            left = findNodes(root.left)\n            right = findNodes(root.right)\n            return left or right\n        findNodes(root)\n        def findLCA(root, p, q):\n            if root is None or root.val == p.val or root.val == q.val:\n                return root\n            left = findLCA(root.left, p, q)\n            right = findLCA(root.right, p, q)\n            return (root if left is not None and right is not None else \n                left or right)\n        lca = findLCA(root, self.s, self.t)\n        def findPath(root, target, path):\n            if root is None:\n                return False\n            if root.val == target.val:\n                return True\n            path.append('L')\n            if findPath(root.left, target, path):\n                return True\n            path.pop()\n            path.append('R')\n            if findPath(root.right, target, path):\n                return True\n            path.pop()\n            return False\n        s_path = []\n        t_path = []\n        findPath(lca, self.s, s_path)\n        findPath(lca, self.t, t_path)\n        return ''.join(['U' for i in range(len(s_path) - 1)]) + ''.join(\n            reversed(s_path[:-1])) + t_path"}
{"generated_code": "class Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        stack = []\n        for i in range(len(locked)):\n            if locked[i] == '0':\n                if s[i] == '(':\n                    stack.append('(')\n                elif s[i] == ')' and len(stack) > 0:\n                    stack.pop()\n                else:\n                    s = s[:i] + '(' + s[i + 1:]\n                    stack.append('(')\n        return not stack and self.isValid(s)\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack:\n                stack.pop()\n            else:\n                return False\n        return not stack", "watermarked_code": "class Solution:\n    def canBeValid(self, s: str, locked: str) ->bool:\n        stack = []\n        for i in range(len(locked)):\n            if locked[i] == '0':\n                if s[i] == '(':\n                    stack.append('(')\n                elif s[i] == ')' and len(stack) > 0:\n                    stack.pop()\n                else:\n                    s = f'{s[:i]}({s[i + 1:]}'\n                    stack.append('(')\n        return not stack and self.isValid(s)\n    def isValid(self, s: str) ->bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack:\n                stack.pop()\n            else:\n                return False\n        return not stack"}
{"generated_code": "class Solution:\n    def isSameAfterReversals(self, num: int) -> bool:\n        reversed1 = str(num)[::-1]\n        reversed2 = int(reversed1[::-1])\n        return reversed2 == num\nsol = Solution()\nprint(sol.isSameAfterReversals(526))\nprint(sol.isSameAfterReversals(1800))\nprint(sol.isSameAfterReversals(0))", "watermarked_code": "class Solution:\n    def isSameAfterReversals(self, num: int) ->bool:\n        reversed1 = str(num)[::-1]\n        reversed2 = int(reversed1[::-1])\n        return reversed2 == num\nsol = Solution()\nprint(sol.isSameAfterReversals(526))\nprint(sol.isSameAfterReversals(1800))\nprint(sol.isSameAfterReversals(0))"}
{"generated_code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int,\n            stampWidth: int) -> bool:\n        n, m = len(grid), len(grid[0])\n        def is_feasible(r, c):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] not in [0, -1]:\n                        return False\n            return True\n        def stamp_it(r, c, k):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] != k:\n                        grid[r + i][j + c] = -1\n        flag = True\n        while flag:\n            flag = False\n            for i in range(n - stampHeight + 1):\n                for j in range(m - stampWidth + 1):\n                    if is_feasible(i, j):\n                        flag = True\n                        stamp_it(i, j, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    return False\n        return True", "watermarked_code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int,\n            stampWidth: int) ->bool:\n        n, m = len(grid), len(grid[0])\n        def is_feasible(r, c):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] not in [0, -1]:\n                        return False\n            return True\n        def stamp_it(r, c, k):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] != k:\n                        grid[r + i][j + c] = -1\n        flag = True\n        while flag:\n            flag = False\n            for i in range(n - stampHeight + 1):\n                for j in range(m - stampWidth + 1):\n                    if is_feasible(i, j):\n                        flag = True\n                        stamp_it(i, j, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    return False\n        return True"}
{"generated_code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int,\n            stampWidth: int) -> bool:\n        n, m = len(grid), len(grid[0])\n        def is_feasible(r, c):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] not in [0, -1]:\n                        return False\n            return True\n        def stamp_it(r, c, k):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] != k:\n                        grid[r + i][j + c] = -1\n        flag = True\n        while flag:\n            flag = False\n            for i in range(n - stampHeight + 1):\n                for j in range(m - stampWidth + 1):\n                    if is_feasible(i, j):\n                        flag = True\n                        stamp_it(i, j, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    return False\n        return True", "watermarked_code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int,\n            stampWidth: int) ->bool:\n        n, m = len(grid), len(grid[0])\n        def is_feasible(r, c):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] not in [0, -1]:\n                        return False\n            return True\n        def stamp_it(r, c, k):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] != k:\n                        grid[r + i][j + c] = -1\n        flag = True\n        while flag:\n            flag = False\n            for i in range(n - stampHeight + 1):\n                for j in range(m - stampWidth + 1):\n                    if is_feasible(i, j):\n                        flag = True\n                        stamp_it(i, j, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    return False\n        return True"}
{"generated_code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int,\n            stampWidth: int) -> bool:\n        n, m = len(grid), len(grid[0])\n        def is_feasible(r, c):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] not in [0, -1]:\n                        return False\n            return True\n        def stamp_it(r, c, k):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] != k:\n                        grid[r + i][j + c] = -1\n        flag = True\n        while flag:\n            flag = False\n            for i in range(n - stampHeight + 1):\n                for j in range(m - stampWidth + 1):\n                    if is_feasible(i, j):\n                        flag = True\n                        stamp_it(i, j, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    return False\n        return True", "watermarked_code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int,\n            stampWidth: int) ->bool:\n        n, m = len(grid), len(grid[0])\n        def is_feasible(r, c):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] not in [0, -1]:\n                        return False\n            return True\n        def stamp_it(r, c, k):\n            for i in range(stampHeight):\n                for j in range(stampWidth):\n                    if grid[r + i][j + c] != k:\n                        grid[r + i][j + c] = -1\n        flag = True\n        while flag:\n            flag = False\n            for i in range(n - stampHeight + 1):\n                for j in range(m - stampWidth + 1):\n                    if is_feasible(i, j):\n                        flag = True\n                        stamp_it(i, j, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    return False\n        return True"}
{"generated_code": "class Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        ones = nums.count(1)\n        if ones in [0, 1]:\n            return 0\n        ones_encountered = 0\n        min_swaps = float('inf')\n        j = 0\n        for i in range(len(nums)):\n            if nums[j] == 1:\n                ones_encountered += 1\n            if ones_encountered == ones:\n                while nums[i] == 0 or i == 0 and nums[-1] == 0:\n                    if i == j:\n                        break\n                    i = (i + 1) % len(nums)\n                min_swaps = min(min_swaps, (j - i + 1) % len(nums))\n            j = (j + 1) % len(nums)\n        return -1 if min_swaps == float('inf') else min_swaps", "watermarked_code": "class Solution:\n    def minSwaps(self, nums: List[int]) ->int:\n        ones = nums.count(1)\n        if ones in {0, 1}:\n            return 0\n        ones_encountered = 0\n        min_swaps = float('inf')\n        j = 0\n        for i in range(len(nums)):\n            if nums[j] == 1:\n                ones_encountered += 1\n            if ones_encountered == ones:\n                while (nums[i] == 0 or i == 0 and nums[-1] == 0) and i != j:\n                    i = (i + 1) % len(nums)\n                min_swaps = min(min_swaps, (j - i + 1) % len(nums))\n            j = (j + 1) % len(nums)\n        return -1 if min_swaps == float('inf') else min_swaps"}
{"generated_code": "class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        num_counts = {}\n        for num in nums:\n            if num not in num_counts:\n                num_counts[num] = 0\n            num_counts[num] += 1\n        return [num for num, count in num_counts.items() if count == 1 and \n            num - 1 not in num_counts and num + 1 not in num_counts]", "watermarked_code": "class Solution:\n    def findLonely(self, nums: List[int]) ->List[int]:\n        num_counts = {}\n        for num in nums:\n            if num not in num_counts:\n                num_counts[num] = 0\n            num_counts[num] += 1\n        return [num for num, count in num_counts.items() if count == 1 and \n            num - 1 not in num_counts and num + 1 not in num_counts]"}
{"generated_code": "class Bitset:\n    def __init__(self, size: int):\n        self.size = size\n        self.bits = 0\n    def fix(self, idx: int) -> None:\n        mask = 1 << idx\n        self.bits |= mask\n    def unfix(self, idx: int) -> None:\n        mask = 1 << idx\n        self.bits &= ~mask\n    def flip(self) -> None:\n        self.bits = ~self.bits\n    def all(self) -> bool:\n        return self.bits == (1 << self.size) - 1\n    def one(self) -> bool:\n        return self.bits != 0\n    def count(self) -> int:\n        count = 0\n        while self.bits > 0:\n            count += self.bits & 1\n            self.bits >>= 1\n        return count\n    def toString(self) -> str:\n        return ''.join('1' if self.bits & 1 << i else '0' for i in range(\n            self.size))", "watermarked_code": "class Bitset:\n    def __init__(self, size: int):\n        self.size = size\n        self.bits = 0\n    def fix(self, idx: int) ->None:\n        mask = 1 << idx\n        self.bits |= mask\n    def unfix(self, idx: int) ->None:\n        mask = 1 << idx\n        self.bits &= ~mask\n    def flip(self) ->None:\n        self.bits = ~self.bits\n    def all(self) ->bool:\n        return self.bits == (1 << self.size) - 1\n    def one(self) ->bool:\n        return self.bits != 0\n    def count(self) ->int:\n        count = 0\n        while self.bits > 0:\n            count += self.bits & 1\n            self.bits >>= 1\n        return count\n    def toString(self) ->str:\n        return ''.join('1' if self.bits & 1 << i else '0' for i in range(\n            self.size))"}
{"generated_code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(set(nums)) < len(nums)", "watermarked_code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) ->bool:\n        return len(set(nums)) < len(nums)"}
{"generated_code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        count = sum(freq[num] * (freq[num] - 1) // 2 for num, value in freq\n            .items() if value > 1 and num % k == 0)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j] and j * i % k == 0:\n                    count += 1\n        return count", "watermarked_code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) ->int:\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        count = sum(freq[num] * (freq[num] - 1) // 2 for num, value in freq\n            .items() if value > 1 and num % k == 0)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j] and j * i % k == 0:\n                    count += 1\n        return count"}
{"generated_code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        count = sum(freq[num] * (freq[num] - 1) // 2 for num, value in freq\n            .items() if value > 1 and num % k == 0)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j] and j * i % k == 0:\n                    count += 1\n        return count", "watermarked_code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) ->int:\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        count = sum(freq[num] * (freq[num] - 1) // 2 for num, value in freq\n            .items() if value > 1 and num % k == 0)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j] and j * i % k == 0:\n                    count += 1\n        return count"}
{"generated_code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        freq_s = {}\n        freq_t = {}\n        for char in s:\n            freq_s[char] = freq_s.get(char, 0) + 1\n        for char in t:\n            freq_t[char] = freq_t.get(char, 0) + 1\n        steps = sum(value if char not in freq_t else max(0, freq_s[char] -\n            freq_t[char]) for char, value in freq_s.items())\n        for char, value_ in freq_t.items():\n            steps += value_ if char not in freq_s else max(0, freq_t[char] -\n                freq_s[char])\n        return steps // 2", "watermarked_code": "class Solution:\n    def minSteps(self, s: str, t: str) ->int:\n        freq_s = {}\n        freq_t = {}\n        for char in s:\n            freq_s[char] = freq_s.get(char, 0) + 1\n        for char in t:\n            freq_t[char] = freq_t.get(char, 0) + 1\n        steps = sum(value if char not in freq_t else max(0, freq_s[char] -\n            freq_t[char]) for char, value in freq_s.items())\n        for char, value_ in freq_t.items():\n            steps += value_ if char not in freq_s else max(0, freq_t[char] -\n                freq_s[char])\n        return steps // 2"}
{"generated_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[\n            TreeNode]:\n        dic = {}\n        for parent, child, is_left in descriptions:\n            parent_node = dic.get(parent, TreeNode(parent))\n            child_node = dic.get(child, TreeNode(child))\n            if is_left:\n                parent_node.left = child_node\n            else:\n                parent_node.right = child_node\n            dic[parent] = parent_node\n            dic[child] = child_node\n        return next((val for key, val in dic.items() if not hasattr(val,\n            'parent')), None)", "watermarked_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) ->Optional[\n            TreeNode]:\n        dic = {}\n        for parent, child, is_left in descriptions:\n            parent_node = dic.get(parent, TreeNode(parent))\n            child_node = dic.get(child, TreeNode(child))\n            if is_left:\n                parent_node.left = child_node\n            else:\n                parent_node.right = child_node\n            dic[parent] = parent_node\n            dic[child] = child_node\n        return next((val for key, val in dic.items() if not hasattr(val,\n            'parent')), None)"}
{"generated_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[\n            TreeNode]:\n        dic = {}\n        for parent, child, is_left in descriptions:\n            parent_node = dic.get(parent, TreeNode(parent))\n            child_node = dic.get(child, TreeNode(child))\n            if is_left:\n                parent_node.left = child_node\n            else:\n                parent_node.right = child_node\n            dic[parent] = parent_node\n            dic[child] = child_node\n        return next((val for key, val in dic.items() if not hasattr(val,\n            'parent')), None)", "watermarked_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) ->Optional[\n            TreeNode]:\n        dic = {}\n        for parent, child, is_left in descriptions:\n            parent_node = dic.get(parent, TreeNode(parent))\n            child_node = dic.get(child, TreeNode(child))\n            if is_left:\n                parent_node.left = child_node\n            else:\n                parent_node.right = child_node\n            dic[parent] = parent_node\n            dic[child] = child_node\n        return next((val for key, val in dic.items() if not hasattr(val,\n            'parent')), None)"}
{"generated_code": "class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[\n            List[int]]) -> int:\n        artifact_coords = set()\n        for artifact in artifacts:\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_coords.add((i, j))\n        excavated_coords = set()\n        for cell in dig:\n            excavated_coords.add(tuple(cell))\n        artifact_dict = {}\n        for artifact in artifacts:\n            artifact_set = set()\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_set.add((i, j))\n            artifact_dict[tuple(artifact)] = artifact_set\n        return sum(bool(value.issubset(excavated_coords)) for artifact,\n            value in artifact_dict.items())", "watermarked_code": "class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[\n            List[int]]) ->int:\n        artifact_coords = set()\n        for artifact in artifacts:\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_coords.add((i, j))\n        excavated_coords = {tuple(cell) for cell in dig}\n        artifact_dict = {}\n        for artifact in artifacts:\n            artifact_set = set()\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_set.add((i, j))\n            artifact_dict[tuple(artifact)] = artifact_set\n        return sum(bool(value.issubset(excavated_coords)) for artifact,\n            value in artifact_dict.items())"}
{"generated_code": "class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[\n            List[int]]) -> int:\n        artifact_coords = set()\n        for artifact in artifacts:\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_coords.add((i, j))\n        excavated_coords = set()\n        for cell in dig:\n            excavated_coords.add(tuple(cell))\n        artifact_dict = {}\n        for artifact in artifacts:\n            artifact_set = set()\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_set.add((i, j))\n            artifact_dict[tuple(artifact)] = artifact_set\n        return sum(bool(value.issubset(excavated_coords)) for artifact,\n            value in artifact_dict.items())", "watermarked_code": "class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[\n            List[int]]) ->int:\n        artifact_coords = set()\n        for artifact in artifacts:\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_coords.add((i, j))\n        excavated_coords = {tuple(cell) for cell in dig}\n        artifact_dict = {}\n        for artifact in artifacts:\n            artifact_set = set()\n            for i in range(artifact[0], artifact[2] + 1):\n                for j in range(artifact[1], artifact[3] + 1):\n                    artifact_set.add((i, j))\n            artifact_dict[tuple(artifact)] = artifact_set\n        return sum(bool(value.issubset(excavated_coords)) for artifact,\n            value in artifact_dict.items())"}
{"generated_code": "class Solution:\n    def maximumTop(self, nums: List[int], k: int) -> int:\n        stack = []\n        n = len(nums)\n        i = 0\n        ans = 0\n        while n > i and k > 0:\n            if stack and stack[-1] < nums[i]:\n                ans = stack.pop()\n                k -= 1\n            else:\n                stack.append(nums[i])\n                i += 1\n        while k > 0 and stack:\n            ans = stack.pop()\n            k -= 1\n        return -1 if k > 0 else ans", "watermarked_code": "class Solution:\n    def maximumTop(self, nums: List[int], k: int) ->int:\n        stack = []\n        n = len(nums)\n        i = 0\n        ans = 0\n        while n > i and k > 0:\n            if stack and stack[-1] < nums[i]:\n                ans = stack.pop()\n                k -= 1\n            else:\n                stack.append(nums[i])\n                i += 1\n        while k > 0 and stack:\n            ans = stack.pop()\n            k -= 1\n        return -1 if k > 0 else ans"}
{"generated_code": "class Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        return all(value % 2 == 0 for key, value in freq.items())", "watermarked_code": "class Solution:\n    def divideArray(self, nums: List[int]) ->bool:\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        return all(value % 2 == 0 for key, value in freq.items())"}
{"generated_code": "from typing import List\nclass Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List\n            [str]):\n        self.encryption_map = {}\n        self.decryption_map = {}\n        for i in range(len(keys)):\n            self.encryption_map[keys[i]] = values[i]\n            if values[i] not in self.decryption_map:\n                self.decryption_map[values[i]] = set()\n            self.decryption_map[values[i]].add(keys[i])\n        self.valid_words = set(dictionary)\n    def encrypt(self, word1: str) -> str:\n        encrypted_word = ''\n        for c in word1:\n            if c in self.encryption_map:\n                encrypted_word += self.encryption_map[c]\n            else:\n                return ''\n        return encrypted_word\n    def decrypt(self, word2: str) -> int:\n        possible_words = ['']\n        for i in range(0, len(word2), 2):\n            s = word2[i:i + 2]\n            curr_word_set = set()\n            for curr_word in possible_words:\n                if s in self.decryption_map:\n                    curr_word_set |= set(c + curr_word for c in self.\n                        decryption_map[s])\n                else:\n                    curr_word_set.add(curr_word)\n            possible_words = curr_word_set\n        return sum(bool(possible_word in self.valid_words) for\n            possible_word in possible_words)", "watermarked_code": "from typing import List\nclass Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List\n            [str]):\n        self.encryption_map = {}\n        self.decryption_map = {}\n        for i in range(len(keys)):\n            self.encryption_map[keys[i]] = values[i]\n            if values[i] not in self.decryption_map:\n                self.decryption_map[values[i]] = set()\n            self.decryption_map[values[i]].add(keys[i])\n        self.valid_words = set(dictionary)\n    def encrypt(self, word1: str) ->str:\n        encrypted_word = ''\n        for c in word1:\n            if c in self.encryption_map:\n                encrypted_word += self.encryption_map[c]\n            else:\n                return ''\n        return encrypted_word\n    def decrypt(self, word2: str) ->int:\n        possible_words = ['']\n        for i in range(0, len(word2), 2):\n            s = word2[i:i + 2]\n            curr_word_set = set()\n            for curr_word in possible_words:\n                if s in self.decryption_map:\n                    curr_word_set |= set(c + curr_word for c in self.\n                        decryption_map[s])\n                else:\n                    curr_word_set.add(curr_word)\n            possible_words = curr_word_set\n        return sum(bool(possible_word in self.valid_words) for\n            possible_word in possible_words)"}
{"generated_code": "from typing import List\nclass Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List\n            [str]):\n        self.encryption_map = {}\n        self.decryption_map = {}\n        for i in range(len(keys)):\n            self.encryption_map[keys[i]] = values[i]\n            if values[i] not in self.decryption_map:\n                self.decryption_map[values[i]] = set()\n            self.decryption_map[values[i]].add(keys[i])\n        self.valid_words = set(dictionary)\n    def encrypt(self, word1: str) -> str:\n        encrypted_word = ''\n        for c in word1:\n            if c in self.encryption_map:\n                encrypted_word += self.encryption_map[c]\n            else:\n                return ''\n        return encrypted_word\n    def decrypt(self, word2: str) -> int:\n        possible_words = ['']\n        for i in range(0, len(word2), 2):\n            s = word2[i:i + 2]\n            curr_word_set = set()\n            for curr_word in possible_words:\n                if s in self.decryption_map:\n                    curr_word_set |= set(c + curr_word for c in self.\n                        decryption_map[s])\n                else:\n                    curr_word_set.add(curr_word)\n            possible_words = curr_word_set\n        return sum(bool(possible_word in self.valid_words) for\n            possible_word in possible_words)", "watermarked_code": "from typing import List\nclass Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List\n            [str]):\n        self.encryption_map = {}\n        self.decryption_map = {}\n        for i in range(len(keys)):\n            self.encryption_map[keys[i]] = values[i]\n            if values[i] not in self.decryption_map:\n                self.decryption_map[values[i]] = set()\n            self.decryption_map[values[i]].add(keys[i])\n        self.valid_words = set(dictionary)\n    def encrypt(self, word1: str) ->str:\n        encrypted_word = ''\n        for c in word1:\n            if c in self.encryption_map:\n                encrypted_word += self.encryption_map[c]\n            else:\n                return ''\n        return encrypted_word\n    def decrypt(self, word2: str) ->int:\n        possible_words = ['']\n        for i in range(0, len(word2), 2):\n            s = word2[i:i + 2]\n            curr_word_set = set()\n            for curr_word in possible_words:\n                if s in self.decryption_map:\n                    curr_word_set |= set(c + curr_word for c in self.\n                        decryption_map[s])\n                else:\n                    curr_word_set.add(curr_word)\n            possible_words = curr_word_set\n        return sum(bool(possible_word in self.valid_words) for\n            possible_word in possible_words)"}
{"generated_code": "from typing import List\nclass Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List\n            [str]):\n        self.encryption_map = {}\n        self.decryption_map = {}\n        for i in range(len(keys)):\n            self.encryption_map[keys[i]] = values[i]\n            if values[i] not in self.decryption_map:\n                self.decryption_map[values[i]] = set()\n            self.decryption_map[values[i]].add(keys[i])\n        self.valid_words = set(dictionary)\n    def encrypt(self, word1: str) -> str:\n        encrypted_word = ''\n        for c in word1:\n            if c in self.encryption_map:\n                encrypted_word += self.encryption_map[c]\n            else:\n                return ''\n        return encrypted_word\n    def decrypt(self, word2: str) -> int:\n        possible_words = ['']\n        for i in range(0, len(word2), 2):\n            s = word2[i:i + 2]\n            curr_word_set = set()\n            for curr_word in possible_words:\n                if s in self.decryption_map:\n                    curr_word_set |= set(c + curr_word for c in self.\n                        decryption_map[s])\n                else:\n                    curr_word_set.add(curr_word)\n            possible_words = curr_word_set\n        return sum(bool(possible_word in self.valid_words) for\n            possible_word in possible_words)", "watermarked_code": "from typing import List\nclass Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List\n            [str]):\n        self.encryption_map = {}\n        self.decryption_map = {}\n        for i in range(len(keys)):\n            self.encryption_map[keys[i]] = values[i]\n            if values[i] not in self.decryption_map:\n                self.decryption_map[values[i]] = set()\n            self.decryption_map[values[i]].add(keys[i])\n        self.valid_words = set(dictionary)\n    def encrypt(self, word1: str) ->str:\n        encrypted_word = ''\n        for c in word1:\n            if c in self.encryption_map:\n                encrypted_word += self.encryption_map[c]\n            else:\n                return ''\n        return encrypted_word\n    def decrypt(self, word2: str) ->int:\n        possible_words = ['']\n        for i in range(0, len(word2), 2):\n            s = word2[i:i + 2]\n            curr_word_set = set()\n            for curr_word in possible_words:\n                if s in self.decryption_map:\n                    curr_word_set |= set(c + curr_word for c in self.\n                        decryption_map[s])\n                else:\n                    curr_word_set.add(curr_word)\n            possible_words = curr_word_set\n        return sum(bool(possible_word in self.valid_words) for\n            possible_word in possible_words)"}
{"generated_code": "from typing import List\nclass Solution:\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\n        def gcd(a: int, b: int) -> int:\n            return a if b == 0 else gcd(b, a % b)\n        def count_points(l: int, r: int) -> int:\n            points = 0\n            for i in range(l, r + 1):\n                for j in range(l, r + 1):\n                    if gcd(i, j) == 1:\n                        points += 1\n            return points\n        def is_inside_circle(x: int, y: int, center_x: int, center_y: int,\n                radius: int) -> bool:\n            return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n        points_set = set()\n        for circle in circles:\n            center_x, center_y, radius = circle[0], circle[1], circle[2]\n            l = center_x - radius\n            r = center_x + radius\n            for x in range(l, r + 1):\n                for y in range(center_y - radius, radius + center_y + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n            l = center_y - radius\n            r = radius + center_y\n            for y in range(l, r + 1):\n                for x in range(center_x - radius, center_x + radius + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n        points_count = 0\n        for point in points_set:\n            points_count += count_points(point[0] - 50, point[0] + 50\n                ) * count_points(point[1] - 50, point[1] + 50)\n        return points_count", "watermarked_code": "from typing import List\nclass Solution:\n    def countLatticePoints(self, circles: List[List[int]]) ->int:\n        def gcd(a: int, b: int) ->int:\n            return a if b == 0 else gcd(b, a % b)\n        def count_points(l: int, r: int) ->int:\n            points = 0\n            for i in range(l, r + 1):\n                for j in range(l, r + 1):\n                    if gcd(i, j) == 1:\n                        points += 1\n            return points\n        def is_inside_circle(x: int, y: int, center_x: int, center_y: int,\n                radius: int) ->bool:\n            return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n        points_set = set()\n        for circle in circles:\n            center_x, center_y, radius = circle[0], circle[1], circle[2]\n            l = center_x - radius\n            r = center_x + radius\n            for x in range(l, r + 1):\n                for y in range(center_y - radius, radius + center_y + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n            l = center_y - radius\n            r = radius + center_y\n            for y in range(l, r + 1):\n                for x in range(center_x - radius, center_x + radius + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n        points_count = 0\n        for point in points_set:\n            points_count += count_points(point[0] - 50, point[0] + 50\n                ) * count_points(point[1] - 50, point[1] + 50)\n        return points_count"}
{"generated_code": "from typing import List\nclass Solution:\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\n        def gcd(a: int, b: int) -> int:\n            return a if b == 0 else gcd(b, a % b)\n        def count_points(l: int, r: int) -> int:\n            points = 0\n            for i in range(l, r + 1):\n                for j in range(l, r + 1):\n                    if gcd(i, j) == 1:\n                        points += 1\n            return points\n        def is_inside_circle(x: int, y: int, center_x: int, center_y: int,\n                radius: int) -> bool:\n            return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n        points_set = set()\n        for circle in circles:\n            center_x, center_y, radius = circle[0], circle[1], circle[2]\n            l = center_x - radius\n            r = center_x + radius\n            for x in range(l, r + 1):\n                for y in range(center_y - radius, radius + center_y + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n            l = center_y - radius\n            r = radius + center_y\n            for y in range(l, r + 1):\n                for x in range(center_x - radius, center_x + radius + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n        points_count = 0\n        for point in points_set:\n            points_count += count_points(point[0] - 50, point[0] + 50\n                ) * count_points(point[1] - 50, point[1] + 50)\n        return points_count", "watermarked_code": "from typing import List\nclass Solution:\n    def countLatticePoints(self, circles: List[List[int]]) ->int:\n        def gcd(a: int, b: int) ->int:\n            return a if b == 0 else gcd(b, a % b)\n        def count_points(l: int, r: int) ->int:\n            points = 0\n            for i in range(l, r + 1):\n                for j in range(l, r + 1):\n                    if gcd(i, j) == 1:\n                        points += 1\n            return points\n        def is_inside_circle(x: int, y: int, center_x: int, center_y: int,\n                radius: int) ->bool:\n            return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n        points_set = set()\n        for circle in circles:\n            center_x, center_y, radius = circle[0], circle[1], circle[2]\n            l = center_x - radius\n            r = center_x + radius\n            for x in range(l, r + 1):\n                for y in range(center_y - radius, radius + center_y + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n            l = center_y - radius\n            r = radius + center_y\n            for y in range(l, r + 1):\n                for x in range(center_x - radius, center_x + radius + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n        points_count = 0\n        for point in points_set:\n            points_count += count_points(point[0] - 50, point[0] + 50\n                ) * count_points(point[1] - 50, point[1] + 50)\n        return points_count"}
{"generated_code": "from typing import List\nclass Solution:\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\n        def gcd(a: int, b: int) -> int:\n            return a if b == 0 else gcd(b, a % b)\n        def count_points(l: int, r: int) -> int:\n            points = 0\n            for i in range(l, r + 1):\n                for j in range(l, r + 1):\n                    if gcd(i, j) == 1:\n                        points += 1\n            return points\n        def is_inside_circle(x: int, y: int, center_x: int, center_y: int,\n                radius: int) -> bool:\n            return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n        points_set = set()\n        for circle in circles:\n            center_x, center_y, radius = circle[0], circle[1], circle[2]\n            l = center_x - radius\n            r = center_x + radius\n            for x in range(l, r + 1):\n                for y in range(center_y - radius, radius + center_y + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n            l = center_y - radius\n            r = radius + center_y\n            for y in range(l, r + 1):\n                for x in range(center_x - radius, center_x + radius + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n        points_count = 0\n        for point in points_set:\n            points_count += count_points(point[0] - 50, point[0] + 50\n                ) * count_points(point[1] - 50, point[1] + 50)\n        return points_count", "watermarked_code": "from typing import List\nclass Solution:\n    def countLatticePoints(self, circles: List[List[int]]) ->int:\n        def gcd(a: int, b: int) ->int:\n            return a if b == 0 else gcd(b, a % b)\n        def count_points(l: int, r: int) ->int:\n            points = 0\n            for i in range(l, r + 1):\n                for j in range(l, r + 1):\n                    if gcd(i, j) == 1:\n                        points += 1\n            return points\n        def is_inside_circle(x: int, y: int, center_x: int, center_y: int,\n                radius: int) ->bool:\n            return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n        points_set = set()\n        for circle in circles:\n            center_x, center_y, radius = circle[0], circle[1], circle[2]\n            l = center_x - radius\n            r = center_x + radius\n            for x in range(l, r + 1):\n                for y in range(center_y - radius, radius + center_y + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n            l = center_y - radius\n            r = radius + center_y\n            for y in range(l, r + 1):\n                for x in range(center_x - radius, center_x + radius + 1):\n                    if is_inside_circle(x, y, center_x, center_y, radius):\n                        points_set.add((x, y))\n        points_count = 0\n        for point in points_set:\n            points_count += count_points(point[0] - 50, point[0] + 50\n                ) * count_points(point[1] - 50, point[1] + 50)\n        return points_count"}
{"generated_code": "class Solution:\n    def countDistinct(self, nums: List[int], k: int, p: int) -> int:\n        count = 0\n        mod_count = {(0): 1}\n        distinct_subs = set()\n        for i in range(len(nums)):\n            mods = 0\n            for j in range(i, len(nums)):\n                mods += nums[j] % p == 0\n                if k > mods:\n                    break\n                if (i, j) not in distinct_subs:\n                    count += 1\n                    distinct_subs.add((i, j))\n                if mods in mod_count:\n                    mod_count[mods] += 1\n                else:\n                    mod_count[mods] = 1\n        return sum(mod_count[i] * (mod_count[i] - 1) // 2 for i in range(k +\n            1) if i in mod_count)", "watermarked_code": "class Solution:\n    def countDistinct(self, nums: List[int], k: int, p: int) ->int:\n        count = 0\n        mod_count = {(0): 1}\n        distinct_subs = set()\n        for i in range(len(nums)):\n            mods = 0\n            for j in range(i, len(nums)):\n                mods += nums[j] % p == 0\n                if k > mods:\n                    break\n                if (i, j) not in distinct_subs:\n                    count += 1\n                    distinct_subs.add((i, j))\n                if mods in mod_count:\n                    mod_count[mods] += 1\n                else:\n                    mod_count[mods] = 1\n        return sum(mod_count[i] * (mod_count[i] - 1) // 2 for i in range(k +\n            1) if i in mod_count)"}
{"generated_code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix = [0] * n\n        for i in range(n):\n            prefix[i] = nums[i] if i == 0 else prefix[i - 1] + nums[i]\n        res = 0\n        for i in range(n - 2):\n            left_sum = prefix[i]\n            l, r = i + 1, n - 2\n            while r >= l:\n                mid = (r + l) // 2\n                mid_sum = prefix[mid] - prefix[i]\n                right_sum = prefix[n - 1] - prefix[mid]\n                if mid_sum >= left_sum and mid_sum <= right_sum:\n                    res += 1\n                    break\n                elif mid_sum < left_sum:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return res % (10 ** 9 + 7)", "watermarked_code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) ->int:\n        n = len(nums)\n        prefix = [0] * n\n        for i in range(n):\n            prefix[i] = nums[i] if i == 0 else prefix[i - 1] + nums[i]\n        res = 0\n        for i in range(n - 2):\n            left_sum = prefix[i]\n            l, r = i + 1, n - 2\n            while r >= l:\n                mid = (r + l) // 2\n                mid_sum = prefix[mid] - prefix[i]\n                right_sum = prefix[n - 1] - prefix[mid]\n                if mid_sum >= left_sum and mid_sum <= right_sum:\n                    res += 1\n                    break\n                elif mid_sum < left_sum:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return res % (10 ** 9 + 7)"}
{"generated_code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix = [0] * n\n        for i in range(n):\n            prefix[i] = nums[i] if i == 0 else prefix[i - 1] + nums[i]\n        res = 0\n        for i in range(n - 2):\n            left_sum = prefix[i]\n            l, r = i + 1, n - 2\n            while r >= l:\n                mid = (r + l) // 2\n                mid_sum = prefix[mid] - prefix[i]\n                right_sum = prefix[n - 1] - prefix[mid]\n                if mid_sum >= left_sum and mid_sum <= right_sum:\n                    res += 1\n                    break\n                elif mid_sum < left_sum:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return res % (10 ** 9 + 7)", "watermarked_code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) ->int:\n        n = len(nums)\n        prefix = [0] * n\n        for i in range(n):\n            prefix[i] = nums[i] if i == 0 else prefix[i - 1] + nums[i]\n        res = 0\n        for i in range(n - 2):\n            left_sum = prefix[i]\n            l, r = i + 1, n - 2\n            while r >= l:\n                mid = (r + l) // 2\n                mid_sum = prefix[mid] - prefix[i]\n                right_sum = prefix[n - 1] - prefix[mid]\n                if mid_sum >= left_sum and mid_sum <= right_sum:\n                    res += 1\n                    break\n                elif mid_sum < left_sum:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return res % (10 ** 9 + 7)"}
{"generated_code": "class Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        table = {}\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        for index, letter in enumerate(key):\n            if letter not in table and letter in alphabet:\n                table[letter] = alphabet[index]\n        return ''.join(' ' if letter == ' ' else table[letter] for letter in\n            message)", "watermarked_code": "class Solution:\n    def decodeMessage(self, key: str, message: str) ->str:\n        table = {}\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        for index, letter in enumerate(key):\n            if letter not in table and letter in alphabet:\n                table[letter] = alphabet[index]\n        return ''.join(' ' if letter == ' ' else table[letter] for letter in\n            message)"}
{"generated_code": "class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int,\n            k2: int) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_diff = sum(diff)\n        if k1 == 0 and k2 == 0:\n            return total_diff ** 2\n        diff.sort(reverse=True)\n        for i in range(min(n, k2 + k1)):\n            if diff[i] == 0:\n                break\n            elif k1 > 0 and nums1[diff.index(diff[i])] >= nums2[diff.index(\n                    diff[i])]:\n                nums1[diff.index(diff[i])] -= 1\n                k1 -= 1\n            else:\n                nums2[diff.index(diff[i])] -= 1\n                k2 -= 1\n            diff[i] = abs(nums1[diff.index(diff[i])] - nums2[diff.index(\n                diff[i])])\n        return sum(d ** 2 for d in diff)", "watermarked_code": "class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int,\n            k2: int) ->int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_diff = sum(diff)\n        if k1 == 0 and k2 == 0:\n            return total_diff ** 2\n        diff.sort(reverse=True)\n        for i in range(min(n, k2 + k1)):\n            if diff[i] == 0:\n                break\n            elif k1 > 0 and nums1[diff.index(diff[i])] >= nums2[diff.index(\n                    diff[i])]:\n                nums1[diff.index(diff[i])] -= 1\n                k1 -= 1\n            else:\n                nums2[diff.index(diff[i])] -= 1\n                k2 -= 1\n            diff[i] = abs(nums1[diff.index(diff[i])] - nums2[diff.index(\n                diff[i])])\n        return sum(d ** 2 for d in diff)"}
{"generated_code": "class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int,\n            k2: int) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_diff = sum(diff)\n        if k1 == 0 and k2 == 0:\n            return total_diff ** 2\n        diff.sort(reverse=True)\n        for i in range(min(n, k2 + k1)):\n            if diff[i] == 0:\n                break\n            elif k1 > 0 and nums1[diff.index(diff[i])] >= nums2[diff.index(\n                    diff[i])]:\n                nums1[diff.index(diff[i])] -= 1\n                k1 -= 1\n            else:\n                nums2[diff.index(diff[i])] -= 1\n                k2 -= 1\n            diff[i] = abs(nums1[diff.index(diff[i])] - nums2[diff.index(\n                diff[i])])\n        return sum(d ** 2 for d in diff)", "watermarked_code": "class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int,\n            k2: int) ->int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_diff = sum(diff)\n        if k1 == 0 and k2 == 0:\n            return total_diff ** 2\n        diff.sort(reverse=True)\n        for i in range(min(n, k2 + k1)):\n            if diff[i] == 0:\n                break\n            elif k1 > 0 and nums1[diff.index(diff[i])] >= nums2[diff.index(\n                    diff[i])]:\n                nums1[diff.index(diff[i])] -= 1\n                k1 -= 1\n            else:\n                nums2[diff.index(diff[i])] -= 1\n                k2 -= 1\n            diff[i] = abs(nums1[diff.index(diff[i])] - nums2[diff.index(\n                diff[i])])\n        return sum(d ** 2 for d in diff)"}
{"generated_code": "class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int,\n            k2: int) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_diff = sum(diff)\n        if k1 == 0 and k2 == 0:\n            return total_diff ** 2\n        diff.sort(reverse=True)\n        for i in range(min(n, k2 + k1)):\n            if diff[i] == 0:\n                break\n            elif k1 > 0 and nums1[diff.index(diff[i])] >= nums2[diff.index(\n                    diff[i])]:\n                nums1[diff.index(diff[i])] -= 1\n                k1 -= 1\n            else:\n                nums2[diff.index(diff[i])] -= 1\n                k2 -= 1\n            diff[i] = abs(nums1[diff.index(diff[i])] - nums2[diff.index(\n                diff[i])])\n        return sum(d ** 2 for d in diff)", "watermarked_code": "class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int,\n            k2: int) ->int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_diff = sum(diff)\n        if k1 == 0 and k2 == 0:\n            return total_diff ** 2\n        diff.sort(reverse=True)\n        for i in range(min(n, k2 + k1)):\n            if diff[i] == 0:\n                break\n            elif k1 > 0 and nums1[diff.index(diff[i])] >= nums2[diff.index(\n                    diff[i])]:\n                nums1[diff.index(diff[i])] -= 1\n                k1 -= 1\n            else:\n                nums2[diff.index(diff[i])] -= 1\n                k2 -= 1\n            diff[i] = abs(nums1[diff.index(diff[i])] - nums2[diff.index(\n                diff[i])])\n        return sum(d ** 2 for d in diff)"}
{"generated_code": "class Solution:\n    def bestHand(self, ranks: List[int], suits: List[str]) -> str:\n        rank_freq = {}\n        for rank in ranks:\n            if rank in rank_freq:\n                rank_freq[rank] += 1\n            else:\n                rank_freq[rank] = 1\n        if len(set(suits)) == 1:\n            return 'Flush'\n        for rank, value in rank_freq.items():\n            if value == 3:\n                return 'Three of a Kind'\n        pairs = sum(bool(value_ == 2) for rank, value_ in rank_freq.items())\n        return 'Pair' if pairs == 1 else 'High Card'", "watermarked_code": "class Solution:\n    def bestHand(self, ranks: List[int], suits: List[str]) ->str:\n        rank_freq = {}\n        for rank in ranks:\n            if rank in rank_freq:\n                rank_freq[rank] += 1\n            else:\n                rank_freq[rank] = 1\n        if len(set(suits)) == 1:\n            return 'Flush'\n        for value in rank_freq.values():\n            if value == 3:\n                return 'Three of a Kind'\n        pairs = sum(value_ == 2 for rank, value_ in rank_freq.items())\n        return 'Pair' if pairs == 1 else 'High Card'"}
{"generated_code": "from typing import List\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        freq = {}\n        for t in tasks:\n            freq[t] = freq.get(t, 0) + 1\n        tasks_sorted = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n        count = 0\n        for _ in range(len(tasks)):\n            if tasks_sorted:\n                t, f = tasks_sorted.pop(0)\n                count += 1\n                f -= 1\n                for _ in range(space - 1):\n                    if not tasks_sorted or tasks_sorted[0][1] <= 0:\n                        break\n                    count += 1\n                    tasks_sorted[0] = tasks_sorted[0][0], tasks_sorted[0][1\n                        ] - 1\n                if f > 0:\n                    tasks_sorted.append((t, f))\n            else:\n                count += space\n        return count", "watermarked_code": "from typing import List\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) ->int:\n        freq = {}\n        for t in tasks:\n            freq[t] = freq.get(t, 0) + 1\n        tasks_sorted = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n        count = 0\n        for _ in range(len(tasks)):\n            if tasks_sorted:\n                t, f = tasks_sorted.pop(0)\n                count += 1\n                f -= 1\n                for _ in range(space - 1):\n                    if not tasks_sorted or tasks_sorted[0][1] <= 0:\n                        break\n                    count += 1\n                    tasks_sorted[0] = tasks_sorted[0][0], tasks_sorted[0][1\n                        ] - 1\n                if f > 0:\n                    tasks_sorted.append((t, f))\n            else:\n                count += space\n        return count"}
{"generated_code": "from typing import List\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]],\n            colConditions: List[List[int]]) -> List[List[int]]:\n        rows = {}\n        cols = {}\n        for idx, above_below in enumerate(rowConditions):\n            above, below = above_below\n            if below not in rows:\n                rows[below] = set()\n            rows[below].add(above)\n        for idx, lr in enumerate(colConditions):\n            left, right = lr\n            if right not in cols:\n                cols[right] = set()\n            cols[right].add(left)\n        if rows and next(iter(rows)) == 1:\n            q = list(rows[1])\n            for i in range(1, k + 1):\n                if i not in rows or i not in q:\n                    q.append(i)\n            matrix = [([0] * k) for _ in range(k)]\n            for i, item in enumerate(q):\n                matrix[0][i] = item\n        elif cols and next(iter(cols)) == 1:\n            q = list(cols[1])\n            for i in range(1, k + 1):\n                if i not in cols or i not in q:\n                    q.append(i)\n            matrix = [([0] * k) for _ in range(k)]\n            for i, item in enumerate(q):\n                matrix[i][0] = item\n        else:\n            matrix = [([0] * k) for _ in range(k)]\n        for rtop, rbottoms in rows.items():\n            tops = list(rbottoms)\n            tops.sort()\n            takeSmaller = rtop != 1\n            q = [i for i in range(1, k + 1) if i not in rows]\n            for t in tops:\n                if takeSmaller:\n                    q.append(t)\n                takeSmaller = not takeSmaller\n            row_to_fill = matrix[rtop - 1]\n            for i, qi in enumerate(q):\n                row_to_fill[i] = qi\n        for cleft, crights in cols.items():\n            rights = list(crights)\n            rights.sort()\n            takeSmaller = cleft != 1\n            q = [i for i in range(1, k + 1) if i not in cols]\n            for r in rights:\n                if takeSmaller:\n                    q.append(r)\n                takeSmaller = not takeSmaller\n            col_to_fill = [matrix[i][cleft - 1] for i in range(k)]\n            for i, qi in enumerate(q):\n                col_to_fill[i] = qi\n        return matrix if matrix.count([0] * k) == 0 else []", "watermarked_code": "from typing import List\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]],\n            colConditions: List[List[int]]) ->List[List[int]]:\n        rows = {}\n        cols = {}\n        for idx, above_below in enumerate(rowConditions):\n            above, below = above_below\n            if below not in rows:\n                rows[below] = set()\n            rows[below].add(above)\n        for idx, lr in enumerate(colConditions):\n            left, right = lr\n            if right not in cols:\n                cols[right] = set()\n            cols[right].add(left)\n        matrix = [([0] * k) for _ in range(k)]\n        if rows and next(iter(rows)) == 1:\n            q = list(rows[1])\n            for i in range(1, k + 1):\n                if i not in rows or i not in q:\n                    q.append(i)\n            for i, item in enumerate(q):\n                matrix[0][i] = item\n        elif cols and next(iter(cols)) == 1:\n            q = list(cols[1])\n            for i in range(1, k + 1):\n                if i not in cols or i not in q:\n                    q.append(i)\n            for i, item in enumerate(q):\n                matrix[i][0] = item\n        for rtop, rbottoms in rows.items():\n            tops = sorted(rbottoms)\n            takeSmaller = rtop != 1\n            q = [i for i in range(1, k + 1) if i not in rows]\n            for t in tops:\n                if takeSmaller:\n                    q.append(t)\n                takeSmaller = not takeSmaller\n            row_to_fill = matrix[rtop - 1]\n            for i, qi in enumerate(q):\n                row_to_fill[i] = qi\n        for cleft, crights in cols.items():\n            rights = sorted(crights)\n            takeSmaller = cleft != 1\n            q = [i for i in range(1, k + 1) if i not in cols]\n            for r in rights:\n                if takeSmaller:\n                    q.append(r)\n                takeSmaller = not takeSmaller\n            col_to_fill = [matrix[i][cleft - 1] for i in range(k)]\n            for i, qi in enumerate(q):\n                col_to_fill[i] = qi\n        return matrix if matrix.count([0] * k) == 0 else []"}
{"generated_code": "from typing import List\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]],\n            colConditions: List[List[int]]) -> List[List[int]]:\n        rows = {}\n        cols = {}\n        for idx, above_below in enumerate(rowConditions):\n            above, below = above_below\n            if below not in rows:\n                rows[below] = set()\n            rows[below].add(above)\n        for idx, lr in enumerate(colConditions):\n            left, right = lr\n            if right not in cols:\n                cols[right] = set()\n            cols[right].add(left)\n        if rows and next(iter(rows)) == 1:\n            q = list(rows[1])\n            for i in range(1, k + 1):\n                if i not in rows or i not in q:\n                    q.append(i)\n            matrix = [([0] * k) for _ in range(k)]\n            for i, item in enumerate(q):\n                matrix[0][i] = item\n        elif cols and next(iter(cols)) == 1:\n            q = list(cols[1])\n            for i in range(1, k + 1):\n                if i not in cols or i not in q:\n                    q.append(i)\n            matrix = [([0] * k) for _ in range(k)]\n            for i, item in enumerate(q):\n                matrix[i][0] = item\n        else:\n            matrix = [([0] * k) for _ in range(k)]\n        for rtop, rbottoms in rows.items():\n            tops = list(rbottoms)\n            tops.sort()\n            takeSmaller = rtop != 1\n            q = [i for i in range(1, k + 1) if i not in rows]\n            for t in tops:\n                if takeSmaller:\n                    q.append(t)\n                takeSmaller = not takeSmaller\n            row_to_fill = matrix[rtop - 1]\n            for i, qi in enumerate(q):\n                row_to_fill[i] = qi\n        for cleft, crights in cols.items():\n            rights = list(crights)\n            rights.sort()\n            takeSmaller = cleft != 1\n            q = [i for i in range(1, k + 1) if i not in cols]\n            for r in rights:\n                if takeSmaller:\n                    q.append(r)\n                takeSmaller = not takeSmaller\n            col_to_fill = [matrix[i][cleft - 1] for i in range(k)]\n            for i, qi in enumerate(q):\n                col_to_fill[i] = qi\n        return matrix if matrix.count([0] * k) == 0 else []", "watermarked_code": "from typing import List\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]],\n            colConditions: List[List[int]]) ->List[List[int]]:\n        rows = {}\n        cols = {}\n        for idx, above_below in enumerate(rowConditions):\n            above, below = above_below\n            if below not in rows:\n                rows[below] = set()\n            rows[below].add(above)\n        for idx, lr in enumerate(colConditions):\n            left, right = lr\n            if right not in cols:\n                cols[right] = set()\n            cols[right].add(left)\n        matrix = [([0] * k) for _ in range(k)]\n        if rows and next(iter(rows)) == 1:\n            q = list(rows[1])\n            for i in range(1, k + 1):\n                if i not in rows or i not in q:\n                    q.append(i)\n            for i, item in enumerate(q):\n                matrix[0][i] = item\n        elif cols and next(iter(cols)) == 1:\n            q = list(cols[1])\n            for i in range(1, k + 1):\n                if i not in cols or i not in q:\n                    q.append(i)\n            for i, item in enumerate(q):\n                matrix[i][0] = item\n        for rtop, rbottoms in rows.items():\n            tops = sorted(rbottoms)\n            takeSmaller = rtop != 1\n            q = [i for i in range(1, k + 1) if i not in rows]\n            for t in tops:\n                if takeSmaller:\n                    q.append(t)\n                takeSmaller = not takeSmaller\n            row_to_fill = matrix[rtop - 1]\n            for i, qi in enumerate(q):\n                row_to_fill[i] = qi\n        for cleft, crights in cols.items():\n            rights = sorted(crights)\n            takeSmaller = cleft != 1\n            q = [i for i in range(1, k + 1) if i not in cols]\n            for r in rights:\n                if takeSmaller:\n                    q.append(r)\n                takeSmaller = not takeSmaller\n            col_to_fill = [matrix[i][cleft - 1] for i in range(k)]\n            for i, qi in enumerate(q):\n                col_to_fill[i] = qi\n        return matrix if matrix.count([0] * k) == 0 else []"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]\n            ) -> int:\n        n = len(robot)\n        m = len(factory)\n        robot.sort()\n        factory.sort()\n        lo = 0\n        hi = n - 1\n        while hi >= lo:\n            mid = (hi + lo) // 2\n            if robot[mid] <= factory[0][0]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        left = mid - 1\n        right = mid + 1\n        repairs = [0] * m\n        for i in range(n):\n            if i < left:\n                repairs[0] += 1\n            elif right > i:\n                repairs[m - 1] += 1\n            else:\n                for j in range(m - 1):\n                    if robot[i] >= factory[j][0] and robot[i] < factory[j + 1][\n                            0]:\n                        repairs[j] += 1\n                        break\n        distances = [0] * m\n        for j in range(m):\n            pos = factory[j][0]\n            limit = factory[j][1]\n            cnt = 0\n            for i in range(n):\n                if robot[i] < pos:\n                    cnt += 1\n                    distances[j] += pos - robot[i]\n                    if cnt == limit:\n                        break\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                if robot[i] > pos:\n                    cnt += 1\n                    distances[j] += robot[i] - pos\n                    if cnt == limit:\n                        break\n        return sum(distances)", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]\n            ) ->int:\n        n = len(robot)\n        m = len(factory)\n        robot.sort()\n        factory.sort()\n        lo = 0\n        hi = n - 1\n        while hi >= lo:\n            mid = (hi + lo) // 2\n            if robot[mid] <= factory[0][0]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        left = mid - 1\n        right = mid + 1\n        repairs = [0] * m\n        for i in range(n):\n            if i < left:\n                repairs[0] += 1\n            elif right > i:\n                repairs[m - 1] += 1\n            else:\n                for j in range(m - 1):\n                    if robot[i] >= factory[j][0] and robot[i] < factory[j + 1][\n                            0]:\n                        repairs[j] += 1\n                        break\n        distances = [0] * m\n        for j in range(m):\n            pos = factory[j][0]\n            limit = factory[j][1]\n            cnt = 0\n            for i in range(n):\n                if robot[i] < pos:\n                    cnt += 1\n                    distances[j] += pos - robot[i]\n                    if cnt == limit:\n                        break\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                if robot[i] > pos:\n                    cnt += 1\n                    distances[j] += robot[i] - pos\n                    if cnt == limit:\n                        break\n        return sum(distances)"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]\n            ) -> int:\n        n = len(robot)\n        m = len(factory)\n        robot.sort()\n        factory.sort()\n        lo = 0\n        hi = n - 1\n        while hi >= lo:\n            mid = (hi + lo) // 2\n            if robot[mid] <= factory[0][0]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        left = mid - 1\n        right = mid + 1\n        repairs = [0] * m\n        for i in range(n):\n            if i < left:\n                repairs[0] += 1\n            elif right > i:\n                repairs[m - 1] += 1\n            else:\n                for j in range(m - 1):\n                    if robot[i] >= factory[j][0] and robot[i] < factory[j + 1][\n                            0]:\n                        repairs[j] += 1\n                        break\n        distances = [0] * m\n        for j in range(m):\n            pos = factory[j][0]\n            limit = factory[j][1]\n            cnt = 0\n            for i in range(n):\n                if robot[i] < pos:\n                    cnt += 1\n                    distances[j] += pos - robot[i]\n                    if cnt == limit:\n                        break\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                if robot[i] > pos:\n                    cnt += 1\n                    distances[j] += robot[i] - pos\n                    if cnt == limit:\n                        break\n        return sum(distances)", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]\n            ) ->int:\n        n = len(robot)\n        m = len(factory)\n        robot.sort()\n        factory.sort()\n        lo = 0\n        hi = n - 1\n        while hi >= lo:\n            mid = (hi + lo) // 2\n            if robot[mid] <= factory[0][0]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        left = mid - 1\n        right = mid + 1\n        repairs = [0] * m\n        for i in range(n):\n            if i < left:\n                repairs[0] += 1\n            elif right > i:\n                repairs[m - 1] += 1\n            else:\n                for j in range(m - 1):\n                    if robot[i] >= factory[j][0] and robot[i] < factory[j + 1][\n                            0]:\n                        repairs[j] += 1\n                        break\n        distances = [0] * m\n        for j in range(m):\n            pos = factory[j][0]\n            limit = factory[j][1]\n            cnt = 0\n            for i in range(n):\n                if robot[i] < pos:\n                    cnt += 1\n                    distances[j] += pos - robot[i]\n                    if cnt == limit:\n                        break\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                if robot[i] > pos:\n                    cnt += 1\n                    distances[j] += robot[i] - pos\n                    if cnt == limit:\n                        break\n        return sum(distances)"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]\n            ) -> int:\n        n = len(robot)\n        m = len(factory)\n        robot.sort()\n        factory.sort()\n        lo = 0\n        hi = n - 1\n        while hi >= lo:\n            mid = (hi + lo) // 2\n            if robot[mid] <= factory[0][0]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        left = mid - 1\n        right = mid + 1\n        repairs = [0] * m\n        for i in range(n):\n            if i < left:\n                repairs[0] += 1\n            elif right > i:\n                repairs[m - 1] += 1\n            else:\n                for j in range(m - 1):\n                    if robot[i] >= factory[j][0] and robot[i] < factory[j + 1][\n                            0]:\n                        repairs[j] += 1\n                        break\n        distances = [0] * m\n        for j in range(m):\n            pos = factory[j][0]\n            limit = factory[j][1]\n            cnt = 0\n            for i in range(n):\n                if robot[i] < pos:\n                    cnt += 1\n                    distances[j] += pos - robot[i]\n                    if cnt == limit:\n                        break\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                if robot[i] > pos:\n                    cnt += 1\n                    distances[j] += robot[i] - pos\n                    if cnt == limit:\n                        break\n        return sum(distances)", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]\n            ) ->int:\n        n = len(robot)\n        m = len(factory)\n        robot.sort()\n        factory.sort()\n        lo = 0\n        hi = n - 1\n        while hi >= lo:\n            mid = (hi + lo) // 2\n            if robot[mid] <= factory[0][0]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        left = mid - 1\n        right = mid + 1\n        repairs = [0] * m\n        for i in range(n):\n            if i < left:\n                repairs[0] += 1\n            elif right > i:\n                repairs[m - 1] += 1\n            else:\n                for j in range(m - 1):\n                    if robot[i] >= factory[j][0] and robot[i] < factory[j + 1][\n                            0]:\n                        repairs[j] += 1\n                        break\n        distances = [0] * m\n        for j in range(m):\n            pos = factory[j][0]\n            limit = factory[j][1]\n            cnt = 0\n            for i in range(n):\n                if robot[i] < pos:\n                    cnt += 1\n                    distances[j] += pos - robot[i]\n                    if cnt == limit:\n                        break\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                if robot[i] > pos:\n                    cnt += 1\n                    distances[j] += robot[i] - pos\n                    if cnt == limit:\n                        break\n        return sum(distances)"}
{"generated_code": "class Solution:\n    def splitMessage(self, message: str, limit: int) -> list[str]:\n        if len(message) <= limit:\n            return [message + '<1/1>']\n        elif ' ' not in message:\n            if len(message) % limit != 0:\n                return []\n            count = len(message) // limit\n            return [(message[i * limit:(i + 1) * limit] + '<' + str(i + 1) +\n                '/' + str(count) + '>') for i in range(count)]\n        else:\n            words = message.split()\n            res = []\n            n = len(words)\n            cur = ''\n            for i in range(n):\n                if len(cur + words[i]) < limit:\n                    cur = cur + words[i] + ' '\n                    if i == n - 1:\n                        res.append(cur + '<' + str(len(res) + 1) + '/' +\n                            str(new_len) + '>')\n                else:\n                    cur = cur.strip()\n                    res.append(cur + '<' + str(len(res) + 1) + '/' + str(\n                        new_len) + '>')\n                    cur = words[i] + ' '\n            if cur != '':\n                cur = cur.strip()\n                res.append(cur + '<' + str(len(res) + 1) + '/' + str(\n                    new_len) + '>')\n            new_len = len(res)\n            if new_len == 1:\n                res[0] = res[0].replace('/1>', '/' + str(new_len) + '>')\n            else:\n                while True:\n                    temp = []\n                    flag = False\n                    for i in range(new_len - 1):\n                        if len(res[i]) + len(res[i + 1]) < limit:\n                            temp.append(res[i] + res[i + 1][res[i + 1].\n                                index('<'):])\n                            flag = True\n                        else:\n                            temp.append(res[i])\n                    temp.append(res[-1])\n                    new_len = len(temp)\n                    if not flag:\n                        break\n                    res = temp\n            return res\nsol = Solution()\nprint(sol.splitMessage('this is really a very awesome message', 9))\nprint(sol.splitMessage('short message', 15))", "watermarked_code": "class Solution:\n    def splitMessage(self, message: str, limit: int) ->list[str]:\n        if len(message) <= limit:\n            return [f'{message}<1/1>']\n        elif ' ' not in message:\n            if len(message) % limit != 0:\n                return []\n            count = len(message) // limit\n            return [\n                f'{message[i * limit:(i + 1) * limit]}<{str(i + 1)}/{str(count)}>'\n                 for i in range(count)]\n        else:\n            words = message.split()\n            res = []\n            n = len(words)\n            cur = ''\n            for i in range(n):\n                if len(cur + words[i]) < limit:\n                    cur = cur + words[i] + ' '\n                    if i == n - 1:\n                        res.append(f'{cur}<{str(len(res) + 1)}/{str(new_len)}>'\n                            )\n                else:\n                    cur = cur.strip()\n                    res.append(f'{cur}<{str(len(res) + 1)}/{str(new_len)}>')\n                    cur = f'{words[i]} '\n            if cur != '':\n                cur = cur.strip()\n                res.append(f'{cur}<{str(len(res) + 1)}/{str(new_len)}>')\n            new_len = len(res)\n            if new_len == 1:\n                res[0] = res[0].replace('/1>', f'/{new_len}>')\n            else:\n                while True:\n                    temp = []\n                    flag = False\n                    for i in range(new_len - 1):\n                        if len(res[i]) + len(res[i + 1]) < limit:\n                            temp.append(res[i] + res[i + 1][res[i + 1].\n                                index('<'):])\n                            flag = True\n                        else:\n                            temp.append(res[i])\n                    temp.append(res[-1])\n                    new_len = len(temp)\n                    if not flag:\n                        break\n                    res = temp\n            return res\nsol = Solution()\nprint(sol.splitMessage('this is really a very awesome message', 9))\nprint(sol.splitMessage('short message', 15))"}
{"generated_code": "class Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def gcd(a, b):\n            return a if b == 0 else gcd(b, a % b)\n        def lcm(a, b):\n            return b * a // gcd(a, b)\n        res = count = 0\n        prod = 1\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod = lcm(prod, nums[j])\n                if prod == k:\n                    res += 1\n        return res", "watermarked_code": "class Solution:\n    def subarrayLCM(self, nums: List[int], k: int) ->int:\n        def gcd(a, b):\n            return a if b == 0 else gcd(b, a % b)\n        def lcm(a, b):\n            return b * a // gcd(a, b)\n        res = count = 0\n        prod = 1\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod = lcm(prod, nums[j])\n                if prod == k:\n                    res += 1\n        return res"}
{"generated_code": "class Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def gcd(a, b):\n            return a if b == 0 else gcd(b, a % b)\n        def lcm(a, b):\n            return b * a // gcd(a, b)\n        res = count = 0\n        prod = 1\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod = lcm(prod, nums[j])\n                if prod == k:\n                    res += 1\n        return res", "watermarked_code": "class Solution:\n    def subarrayLCM(self, nums: List[int], k: int) ->int:\n        def gcd(a, b):\n            return a if b == 0 else gcd(b, a % b)\n        def lcm(a, b):\n            return b * a // gcd(a, b)\n        res = count = 0\n        prod = 1\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod = lcm(prod, nums[j])\n                if prod == k:\n                    res += 1\n        return res"}
{"generated_code": "from typing import List\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for e in edges:\n            graph[e[0] - 1].append(e[1] - 1)\n            graph[e[1] - 1].append(e[0] - 1)\n        groups = [None for _ in range(n)]\n        current_group = 1\n        while None in groups:\n            i = groups.index(None)\n            groups[i] = current_group\n            queue = [i]\n            while queue:\n                node = queue.pop(0)\n                for v in graph[node]:\n                    if groups[v] is None:\n                        groups[v] = (current_group + 1 if current_group % 2 ==\n                            0 else current_group - 1)\n                        queue.append(v)\n                    elif groups[v] == groups[node]:\n                        return -1\n            current_group += 2\n        return max(groups)", "watermarked_code": "from typing import List\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) ->int:\n        graph = [[] for _ in range(n)]\n        for e in edges:\n            graph[e[0] - 1].append(e[1] - 1)\n            graph[e[1] - 1].append(e[0] - 1)\n        groups = [None for _ in range(n)]\n        current_group = 1\n        while None in groups:\n            i = groups.index(None)\n            groups[i] = current_group\n            queue = [i]\n            while queue:\n                node = queue.pop(0)\n                for v in graph[node]:\n                    if groups[v] is None:\n                        groups[v] = (current_group + 1 if current_group % 2 ==\n                            0 else current_group - 1)\n                        queue.append(v)\n                    elif groups[v] == groups[node]:\n                        return -1\n            current_group += 2\n        return max(groups)"}
{"generated_code": "from typing import List\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        indices = []\n        for i in range(n):\n            if nums1[i] != nums2[i]:\n                if nums1[i] in nums2:\n                    indices.append(i)\n                else:\n                    return -1\n        m = len(indices)\n        for i in range(m):\n            min_index = i\n            for j in range(i + 1, m):\n                if nums2[indices[min_index]] > nums2[indices[j]]:\n                    min_index = j\n            if min_index != i:\n                indices[i], indices[min_index] = indices[min_index], indices[i]\n        return sum(abs(indices[i] - i) for i in range(m))", "watermarked_code": "from typing import List\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) ->int:\n        n = len(nums1)\n        indices = []\n        for i in range(n):\n            if nums1[i] != nums2[i]:\n                if nums1[i] in nums2:\n                    indices.append(i)\n                else:\n                    return -1\n        m = len(indices)\n        for i in range(m):\n            min_index = i\n            for j in range(i + 1, m):\n                if nums2[indices[min_index]] > nums2[indices[j]]:\n                    min_index = j\n            if min_index != i:\n                indices[i], indices[min_index] = indices[min_index], indices[i]\n        return sum(abs(indices[i] - i) for i in range(m))"}
{"generated_code": "class Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        num_sqrt = {i: (i ** 0.5) for i in nums}\n        streak_lengths = []\n        for i in range(len(nums)):\n            subseq = [nums[i]]\n            for j in range(i + 1, len(nums)):\n                if num_sqrt[nums[j]] == subseq[-1]:\n                    subseq.append(nums[j])\n            if len(subseq) > 1:\n                is_square_streak = all(num_sqrt[subseq[k]] == subseq[k - 1] for\n                    k in range(1, len(subseq)))\n                if is_square_streak:\n                    streak_lengths.append(len(subseq))\n        return -1 if not streak_lengths else max(streak_lengths)", "watermarked_code": "class Solution:\n    def longestSquareStreak(self, nums: List[int]) ->int:\n        num_sqrt = {i: (i ** 0.5) for i in nums}\n        streak_lengths = []\n        for i in range(len(nums)):\n            subseq = [nums[i]]\n            for j in range(i + 1, len(nums)):\n                if num_sqrt[nums[j]] == subseq[-1]:\n                    subseq.append(nums[j])\n            if len(subseq) > 1:\n                is_square_streak = all(num_sqrt[subseq[k]] == subseq[k - 1] for\n                    k in range(1, len(subseq)))\n                if is_square_streak:\n                    streak_lengths.append(len(subseq))\n        return max(streak_lengths, default=-1)"}
{"generated_code": "class Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        answer = []\n        m, n = len(grid), len(grid[0])\n        def is_valid(x, y, visited):\n            return x >= 0 and x < m and y >= 0 and n > y and not visited[x][y]\n        def search(x, y, visited, score):\n            if grid[x][y] < score:\n                visited[x][y] = True\n                return 1\n            return 0\n        for q in queries:\n            score = 0\n            visited = [([False] * n) for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if is_valid(i, j, visited):\n                        score += search(i, j, visited, q)\n            answer.append(score)\n        return answer", "watermarked_code": "class Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) ->List[int]:\n        answer = []\n        m, n = len(grid), len(grid[0])\n        def is_valid(x, y, visited):\n            return x >= 0 and x < m and y >= 0 and n > y and not visited[x][y]\n        def search(x, y, visited, score):\n            if grid[x][y] < score:\n                visited[x][y] = True\n                return 1\n            return 0\n        for q in queries:\n            score = 0\n            visited = [([False] * n) for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if is_valid(i, j, visited):\n                        score += search(i, j, visited, q)\n            answer.append(score)\n        return answer"}
{"generated_code": "class Solution:\n    def countAnagrams(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        freq_counts = {}\n        for word in s.split():\n            freq_counts[''.join(sorted(word))] = freq_counts.get(''.join(\n                sorted(word)), 0) + 1\n        num_anagrams = 1\n        for freq in freq_counts.values():\n            num_anagrams = num_anagrams * factorial(freq) % MOD\n        return num_anagrams\n    def factorial(self, num: int) -> int:\n        return 1 if num in [1, 0] else num * self.factorial(num - 1)\nsolution = Solution()\nprint(solution.countAnagrams('too hot'))", "watermarked_code": "class Solution:\n    def countAnagrams(self, s: str) ->int:\n        MOD = 10 ** 9 + 7\n        freq_counts = {}\n        for word in s.split():\n            freq_counts[''.join(sorted(word))] = freq_counts.get(''.join(\n                sorted(word)), 0) + 1\n        num_anagrams = 1\n        for freq in freq_counts.values():\n            num_anagrams = num_anagrams * factorial(freq) % MOD\n        return num_anagrams\n    def factorial(self, num: int) ->int:\n        return 1 if num in {1, 0} else num * self.factorial(num - 1)\nsolution = Solution()\nprint(solution.countAnagrams('too hot'))"}
{"generated_code": "class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int\n            ) -> int:\n        n = len(words)\n        closest_distance = float('inf')\n        for i in range(n):\n            if words[i] == target:\n                distance = abs(i - startIndex)\n                circular_distance = n - distance\n                min_distance = min(distance, circular_distance)\n                closest_distance = min(closest_distance, min_distance)\n        return -1 if closest_distance == float('inf') else closest_distance", "watermarked_code": "class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int\n            ) ->int:\n        n = len(words)\n        closest_distance = float('inf')\n        for i in range(n):\n            if words[i] == target:\n                distance = abs(i - startIndex)\n                circular_distance = n - distance\n                min_distance = min(distance, circular_distance)\n                closest_distance = min(closest_distance, min_distance)\n        return -1 if closest_distance == float('inf') else closest_distance"}
{"generated_code": "class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int\n            ) -> int:\n        n = len(words)\n        closest_distance = float('inf')\n        for i in range(n):\n            if words[i] == target:\n                distance = abs(i - startIndex)\n                circular_distance = n - distance\n                min_distance = min(distance, circular_distance)\n                closest_distance = min(closest_distance, min_distance)\n        return -1 if closest_distance == float('inf') else closest_distance", "watermarked_code": "class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int\n            ) ->int:\n        n = len(words)\n        closest_distance = float('inf')\n        for i in range(n):\n            if words[i] == target:\n                distance = abs(i - startIndex)\n                circular_distance = n - distance\n                min_distance = min(distance, circular_distance)\n                closest_distance = min(closest_distance, min_distance)\n        return -1 if closest_distance == float('inf') else closest_distance"}
{"generated_code": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        sum_nums = sum(nums)\n        if sum_nums < k or not nums:\n            return 0\n        mod = 10 ** 9 + 7\n        dp = [([0] * (sum_nums + 1)) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, sum_nums + 1):\n                tmp_sum = 0\n                for p in range(i):\n                    tmp_sum += nums[p]\n                    if j > tmp_sum:\n                        break\n                    dp[i][j] = (dp[i][j] + dp[p][j - tmp_sum]) % mod\n        res = 0\n        for i in range(1, n):\n            left = 0\n            for j in range(i):\n                left += nums[j]\n                if k <= left:\n                    break\n                res = (res + dp[j][sum_nums - left]) % mod\n            right = 0\n            for j in range(i, n):\n                right += nums[j]\n                if k <= right:\n                    break\n                res = (res + dp[n - j - 1][sum_nums - right]) % mod\n        return res % mod", "watermarked_code": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) ->int:\n        n = len(nums)\n        sum_nums = sum(nums)\n        if sum_nums < k or not nums:\n            return 0\n        mod = 10 ** 9 + 7\n        dp = [([0] * (sum_nums + 1)) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, sum_nums + 1):\n                tmp_sum = 0\n                for p in range(i):\n                    tmp_sum += nums[p]\n                    if j > tmp_sum:\n                        break\n                    dp[i][j] = (dp[i][j] + dp[p][j - tmp_sum]) % mod\n        res = 0\n        for i in range(1, n):\n            left = 0\n            for j in range(i):\n                left += nums[j]\n                if k <= left:\n                    break\n                res = (res + dp[j][sum_nums - left]) % mod\n            right = 0\n            for j in range(i, n):\n                right += nums[j]\n                if k <= right:\n                    break\n                res = (res + dp[n - j - 1][sum_nums - right]) % mod\n        return res % mod"}
{"generated_code": "from typing import List\nclass Solution:\n    def is_prime(self, num: int) -> bool:\n        if num < 2:\n            return False\n        return all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        prime_numbers = [x for x in range(left, right + 1) if self.is_prime(x)]\n        if len(prime_numbers) < 2:\n            return [-1, -1]\n        min_gap = float('inf')\n        nums = []\n        for i in range(len(prime_numbers) - 1):\n            gap = prime_numbers[i + 1] - prime_numbers[i]\n            if gap < min_gap:\n                min_gap = gap\n                nums = [prime_numbers[i], prime_numbers[i + 1]]\n        return nums", "watermarked_code": "from typing import List\nclass Solution:\n    def is_prime(self, num: int) ->bool:\n        if num < 2:\n            return False\n        return all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n    def closestPrimes(self, left: int, right: int) ->List[int]:\n        prime_numbers = [x for x in range(left, right + 1) if self.is_prime(x)]\n        if len(prime_numbers) < 2:\n            return [-1, -1]\n        min_gap = float('inf')\n        nums = []\n        for i in range(len(prime_numbers) - 1):\n            gap = prime_numbers[i + 1] - prime_numbers[i]\n            if gap < min_gap:\n                min_gap = gap\n                nums = [prime_numbers[i], prime_numbers[i + 1]]\n        return nums"}
{"generated_code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int\n            ) -> str:\n        volume = width * length * height\n        if length >= 104 or width >= 104 or height >= 104 or volume >= 10 ** 9:\n            return 'Both' if mass >= 100 else 'Bulky'\n        elif mass >= 100:\n            return 'Heavy'\n        else:\n            return 'Neither'", "watermarked_code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int\n            ) ->str:\n        volume = width * length * height\n        if length >= 104 or width >= 104 or height >= 104 or volume >= 10 ** 9:\n            return 'Both' if mass >= 100 else 'Bulky'\n        elif mass >= 100:\n            return 'Heavy'\n        else:\n            return 'Neither'"}
{"generated_code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int\n            ) -> str:\n        volume = width * length * height\n        if length >= 104 or width >= 104 or height >= 104 or volume >= 10 ** 9:\n            return 'Both' if mass >= 100 else 'Bulky'\n        elif mass >= 100:\n            return 'Heavy'\n        else:\n            return 'Neither'", "watermarked_code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int\n            ) ->str:\n        volume = width * length * height\n        if length >= 104 or width >= 104 or height >= 104 or volume >= 10 ** 9:\n            return 'Both' if mass >= 100 else 'Bulky'\n        elif mass >= 100:\n            return 'Heavy'\n        else:\n            return 'Neither'"}
{"generated_code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int\n            ) -> str:\n        volume = width * length * height\n        if length >= 104 or width >= 104 or height >= 104 or volume >= 10 ** 9:\n            return 'Both' if mass >= 100 else 'Bulky'\n        elif mass >= 100:\n            return 'Heavy'\n        else:\n            return 'Neither'", "watermarked_code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int\n            ) ->str:\n        volume = width * length * height\n        if length >= 104 or width >= 104 or height >= 104 or volume >= 10 ** 9:\n            return 'Both' if mass >= 100 else 'Bulky'\n        elif mass >= 100:\n            return 'Heavy'\n        else:\n            return 'Neither'"}
{"generated_code": "class DataStream:\n    def __init__(self, value: int, k: int):\n        self.stream = []\n        self.value = value\n        self.k = k\n    def consec(self, num: int) -> bool:\n        self.stream.append(num)\n        if len(self.stream) < self.k:\n            return False\n        return self.stream[-self.k:] == [self.value] * self.k", "watermarked_code": "class DataStream:\n    def __init__(self, value: int, k: int):\n        self.stream = []\n        self.value = value\n        self.k = k\n    def consec(self, num: int) ->bool:\n        self.stream.append(num)\n        if len(self.stream) < self.k:\n            return False\n        return self.stream[-self.k:] == [self.value] * self.k"}
{"generated_code": "class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        n = len(nums1)\n        if sum(nums1) > sum(nums2):\n            nums1, nums2 = nums2, nums1\n        diff = [(nums2[i] - nums1[i]) for i in range(n)]\n        diff.sort()\n        res = 0\n        i, j = 0, n - 1\n        while n > i and j >= 0 and k > 0:\n            while n > i and diff[i] <= 0:\n                i += 1\n            while j >= 0 and diff[j] <= 0:\n                j -= 1\n            if n > i:\n                diff_i = min(k, diff[i])\n                k -= diff_i\n                diff[i] -= diff_i\n                res += 1\n            elif j >= 0:\n                diff_j = min(k, -diff[j])\n                k -= diff_j\n                diff[j] += diff_j\n                res += 1\n        return -1 if k > 0 else res", "watermarked_code": "class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) ->int:\n        n = len(nums1)\n        if sum(nums1) > sum(nums2):\n            nums1, nums2 = nums2, nums1\n        diff = [(nums2[i] - nums1[i]) for i in range(n)]\n        diff.sort()\n        res = 0\n        i, j = 0, n - 1\n        while n > i and j >= 0 and k > 0:\n            while n > i and diff[i] <= 0:\n                i += 1\n            while j >= 0 and diff[j] <= 0:\n                j -= 1\n            if n > i:\n                diff_i = min(k, diff[i])\n                k -= diff_i\n                diff[i] -= diff_i\n                res += 1\n            elif j >= 0:\n                diff_j = min(k, -diff[j])\n                k -= diff_j\n                diff[j] += diff_j\n                res += 1\n        return -1 if k > 0 else res"}
{"generated_code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b) if b > a else gcd(a, b % a)\n        if targetX < 1 or targetY < 1:\n            return False\n        if gcd(targetX, targetY) != 1:\n            return True\n        return self.isReachable(targetY % targetX, targetX)", "watermarked_code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) ->bool:\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b) if b > a else gcd(a, b % a)\n        if targetX < 1 or targetY < 1:\n            return False\n        if gcd(targetX, targetY) != 1:\n            return True\n        return self.isReachable(targetY % targetX, targetX)"}
{"generated_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        def dfs(r, c):\n            if r == m - 1 and c == n - 1:\n                return True\n            visited[r][c] = True\n            if r + 1 < m and not visited[r + 1][c] and grid[r + 1][c\n                    ] == 1 and dfs(r + 1, c):\n                return True\n            return bool(c + 1 < n and not visited[r][c + 1] and grid[r][c +\n                1] == 1 and dfs(r, c + 1))\n        if not dfs(0, 0):\n            return False\n        for r in range(m):\n            for c in range(n):\n                if r == 0 and c == 0 or r == m - 1 and c == n - 1:\n                    continue\n                original = grid[r][c]\n                grid[r][c] = 1 - grid[r][c]\n                visited = [([False] * n) for _ in range(m)]\n                if not dfs(0, 0):\n                    return True\n                grid[r][c] = original\n        return False", "watermarked_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) ->bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        def dfs(r, c):\n            if r == m - 1 and c == n - 1:\n                return True\n            visited[r][c] = True\n            if r + 1 < m and not visited[r + 1][c] and grid[r + 1][c\n                    ] == 1 and dfs(r + 1, c):\n                return True\n            return bool(c + 1 < n and not visited[r][c + 1] and grid[r][c +\n                1] == 1 and dfs(r, c + 1))\n        if not dfs(0, 0):\n            return False\n        for r in range(m):\n            for c in range(n):\n                if r == 0 and c == 0 or r == m - 1 and c == n - 1:\n                    continue\n                original = grid[r][c]\n                grid[r][c] = 1 - grid[r][c]\n                visited = [([False] * n) for _ in range(m)]\n                if not dfs(0, 0):\n                    return True\n                grid[r][c] = original\n        return False"}
{"generated_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        def dfs(r, c):\n            if r == m - 1 and c == n - 1:\n                return True\n            visited[r][c] = True\n            if r + 1 < m and not visited[r + 1][c] and grid[r + 1][c\n                    ] == 1 and dfs(r + 1, c):\n                return True\n            return bool(c + 1 < n and not visited[r][c + 1] and grid[r][c +\n                1] == 1 and dfs(r, c + 1))\n        if not dfs(0, 0):\n            return False\n        for r in range(m):\n            for c in range(n):\n                if r == 0 and c == 0 or r == m - 1 and c == n - 1:\n                    continue\n                original = grid[r][c]\n                grid[r][c] = 1 - grid[r][c]\n                visited = [([False] * n) for _ in range(m)]\n                if not dfs(0, 0):\n                    return True\n                grid[r][c] = original\n        return False", "watermarked_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) ->bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = [([False] * n) for _ in range(m)]\n        def dfs(r, c):\n            if r == m - 1 and c == n - 1:\n                return True\n            visited[r][c] = True\n            if r + 1 < m and not visited[r + 1][c] and grid[r + 1][c\n                    ] == 1 and dfs(r + 1, c):\n                return True\n            return bool(c + 1 < n and not visited[r][c + 1] and grid[r][c +\n                1] == 1 and dfs(r, c + 1))\n        if not dfs(0, 0):\n            return False\n        for r in range(m):\n            for c in range(n):\n                if r == 0 and c == 0 or r == m - 1 and c == n - 1:\n                    continue\n                original = grid[r][c]\n                grid[r][c] = 1 - grid[r][c]\n                visited = [([False] * n) for _ in range(m)]\n                if not dfs(0, 0):\n                    return True\n                grid[r][c] = original\n        return False"}
{"generated_code": "class Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        t_pointer = 0\n        s_pointer = 0\n        t_len = len(t)\n        s_len = len(s)\n        left = -1\n        right = -1\n        while t_len > t_pointer and s_len > s_pointer:\n            if s[s_pointer] == t[t_pointer]:\n                if left == -1:\n                    left = s_pointer\n                right = s_pointer\n                t_pointer += 1\n            s_pointer += 1\n        return 1 if left == -1 else right - left + 1", "watermarked_code": "class Solution:\n    def minimumScore(self, s: str, t: str) ->int:\n        t_pointer = 0\n        s_pointer = 0\n        t_len = len(t)\n        s_len = len(s)\n        left = -1\n        right = -1\n        while t_len > t_pointer and s_len > s_pointer:\n            if s[s_pointer] == t[t_pointer]:\n                if left == -1:\n                    left = s_pointer\n                right = s_pointer\n                t_pointer += 1\n            s_pointer += 1\n        return 1 if left == -1 else right - left + 1"}
{"generated_code": "class Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k:\n            int) -> int:\n        graph = [[] for _ in range(len(edges) + 2)]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        num_guesses = [0] * (len(edges) + 2)\n        for u, v in guesses:\n            num_guesses[v] += 1\n        candidates = set(range(len(edges) + 2))\n        for u, v in guesses:\n            if num_guesses[v] == k or num_guesses[u] == k - 1:\n                candidates.discard(v)\n        roots = []\n        for i in candidates:\n            if num_guesses[i] >= k:\n                num_correct_guesses = 0\n                visited = [False] * (len(edges) + 2)\n                visited[i] = True\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            if [node, neighbor] in guesses:\n                                num_correct_guesses += 1\n                            stack.append(neighbor)\n                if k <= num_correct_guesses:\n                    roots.append(i)\n        return len(roots)", "watermarked_code": "class Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k:\n            int) ->int:\n        graph = [[] for _ in range(len(edges) + 2)]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        num_guesses = [0] * (len(edges) + 2)\n        for u, v in guesses:\n            num_guesses[v] += 1\n        candidates = set(range(len(edges) + 2))\n        for u, v in guesses:\n            if num_guesses[v] == k or num_guesses[u] == k - 1:\n                candidates.discard(v)\n        roots = []\n        for i in candidates:\n            if num_guesses[i] >= k:\n                num_correct_guesses = 0\n                visited = [False] * (len(edges) + 2)\n                visited[i] = True\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            if [node, neighbor] in guesses:\n                                num_correct_guesses += 1\n                            stack.append(neighbor)\n                if k <= num_correct_guesses:\n                    roots.append(i)\n        return len(roots)"}
{"generated_code": "class Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k:\n            int) -> int:\n        graph = [[] for _ in range(len(edges) + 2)]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        num_guesses = [0] * (len(edges) + 2)\n        for u, v in guesses:\n            num_guesses[v] += 1\n        candidates = set(range(len(edges) + 2))\n        for u, v in guesses:\n            if num_guesses[v] == k or num_guesses[u] == k - 1:\n                candidates.discard(v)\n        roots = []\n        for i in candidates:\n            if num_guesses[i] >= k:\n                num_correct_guesses = 0\n                visited = [False] * (len(edges) + 2)\n                visited[i] = True\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            if [node, neighbor] in guesses:\n                                num_correct_guesses += 1\n                            stack.append(neighbor)\n                if k <= num_correct_guesses:\n                    roots.append(i)\n        return len(roots)", "watermarked_code": "class Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k:\n            int) ->int:\n        graph = [[] for _ in range(len(edges) + 2)]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        num_guesses = [0] * (len(edges) + 2)\n        for u, v in guesses:\n            num_guesses[v] += 1\n        candidates = set(range(len(edges) + 2))\n        for u, v in guesses:\n            if num_guesses[v] == k or num_guesses[u] == k - 1:\n                candidates.discard(v)\n        roots = []\n        for i in candidates:\n            if num_guesses[i] >= k:\n                num_correct_guesses = 0\n                visited = [False] * (len(edges) + 2)\n                visited[i] = True\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            if [node, neighbor] in guesses:\n                                num_correct_guesses += 1\n                            stack.append(neighbor)\n                if k <= num_correct_guesses:\n                    roots.append(i)\n        return len(roots)"}
{"generated_code": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split(' ')\n        if len(pattern) != len(words):\n            return False\n        mapping = {}\n        for i in range(len(pattern)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            elif words[i] in mapping.values():\n                return False\n            else:\n                mapping[pattern[i]] = words[i]\n        return True", "watermarked_code": "class Solution:\n    def wordPattern(self, pattern: str, s: str) ->bool:\n        words = s.split(' ')\n        if len(pattern) != len(words):\n            return False\n        mapping = {}\n        for i in range(len(pattern)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            elif words[i] in mapping.values():\n                return False\n            else:\n                mapping[pattern[i]] = words[i]\n        return True"}
{"generated_code": "from typing import List\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        if len(distance) < 4:\n            return False\n        x, y = 0, 0\n        d1, d2, d3, d4, d5 = distance + [0] * 2\n        for i in range(1, len(distance) + 1):\n            if d3 <= d1 and d4 <= d2:\n                return True\n            if i >= 4 and (d3 >= d1 and d4 >= d2 and d5 >= d3 - d1 and d1 >=\n                    d3 - d5):\n                return True\n            if i >= 5 and (d4 >= d2 and d3 <= d5 and d6 >= d4 - d2 and d2 >=\n                    d4 - d6 and d1 >= d3 - d5 and d5 >= d3 - d1):\n                return True\n            x, y = self.move(x, y, i % 4, distance[i - 1])\n            d1, d2, d3, d4, d5 = d2, d3, d4, d5, distance[i]\n        return False\n    def move(self, x: int, y: int, direction: int, steps: int) -> tuple[int, int\n            ]:\n        if direction == 0:\n            return x, steps + y\n        elif direction == 1:\n            return x - steps, y\n        elif direction == 2:\n            return x, y - steps\n        elif direction == 3:\n            return x + steps, y", "watermarked_code": "from typing import List\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) ->bool:\n        if len(distance) < 4:\n            return False\n        x, y = 0, 0\n        d1, d2, d3, d4, d5 = distance + [0] * 2\n        for i in range(1, len(distance) + 1):\n            if d3 <= d1 and d4 <= d2:\n                return True\n            if i >= 4 and (d3 >= d1 and d4 >= d2 and d5 >= d3 - d1 and d1 >=\n                    d3 - d5):\n                return True\n            if i >= 5 and (d4 >= d2 and d3 <= d5 and d6 >= d4 - d2 and d2 >=\n                    d4 - d6 and d1 >= d3 - d5 and d5 >= d3 - d1):\n                return True\n            x, y = self.move(x, y, i % 4, distance[i - 1])\n            d1, d2, d3, d4, d5 = d2, d3, d4, d5, distance[i]\n        return False\n    def move(self, x: int, y: int, direction: int, steps: int) ->tuple[int, int\n            ]:\n        if direction == 0:\n            return x, steps + y\n        elif direction == 1:\n            return x - steps, y\n        elif direction == 2:\n            return x, y - steps\n        elif direction == 3:\n            return x + steps, y"}
{"generated_code": "from typing import List\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        if len(distance) < 4:\n            return False\n        x, y = 0, 0\n        d1, d2, d3, d4, d5 = distance + [0] * 2\n        for i in range(1, len(distance) + 1):\n            if d3 <= d1 and d4 <= d2:\n                return True\n            if i >= 4 and (d3 >= d1 and d4 >= d2 and d5 >= d3 - d1 and d1 >=\n                    d3 - d5):\n                return True\n            if i >= 5 and (d4 >= d2 and d3 <= d5 and d6 >= d4 - d2 and d2 >=\n                    d4 - d6 and d1 >= d3 - d5 and d5 >= d3 - d1):\n                return True\n            x, y = self.move(x, y, i % 4, distance[i - 1])\n            d1, d2, d3, d4, d5 = d2, d3, d4, d5, distance[i]\n        return False\n    def move(self, x: int, y: int, direction: int, steps: int) -> tuple[int, int\n            ]:\n        if direction == 0:\n            return x, steps + y\n        elif direction == 1:\n            return x - steps, y\n        elif direction == 2:\n            return x, y - steps\n        elif direction == 3:\n            return x + steps, y", "watermarked_code": "from typing import List\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) ->bool:\n        if len(distance) < 4:\n            return False\n        x, y = 0, 0\n        d1, d2, d3, d4, d5 = distance + [0] * 2\n        for i in range(1, len(distance) + 1):\n            if d3 <= d1 and d4 <= d2:\n                return True\n            if i >= 4 and (d3 >= d1 and d4 >= d2 and d5 >= d3 - d1 and d1 >=\n                    d3 - d5):\n                return True\n            if i >= 5 and (d4 >= d2 and d3 <= d5 and d6 >= d4 - d2 and d2 >=\n                    d4 - d6 and d1 >= d3 - d5 and d5 >= d3 - d1):\n                return True\n            x, y = self.move(x, y, i % 4, distance[i - 1])\n            d1, d2, d3, d4, d5 = d2, d3, d4, d5, distance[i]\n        return False\n    def move(self, x: int, y: int, direction: int, steps: int) ->tuple[int, int\n            ]:\n        if direction == 0:\n            return x, steps + y\n        elif direction == 1:\n            return x - steps, y\n        elif direction == 2:\n            return x, y - steps\n        elif direction == 3:\n            return x + steps, y"}
{"generated_code": "from typing import List\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        if len(distance) < 4:\n            return False\n        x, y = 0, 0\n        d1, d2, d3, d4, d5 = distance + [0] * 2\n        for i in range(1, len(distance) + 1):\n            if d3 <= d1 and d4 <= d2:\n                return True\n            if i >= 4 and (d3 >= d1 and d4 >= d2 and d5 >= d3 - d1 and d1 >=\n                    d3 - d5):\n                return True\n            if i >= 5 and (d4 >= d2 and d3 <= d5 and d6 >= d4 - d2 and d2 >=\n                    d4 - d6 and d1 >= d3 - d5 and d5 >= d3 - d1):\n                return True\n            x, y = self.move(x, y, i % 4, distance[i - 1])\n            d1, d2, d3, d4, d5 = d2, d3, d4, d5, distance[i]\n        return False\n    def move(self, x: int, y: int, direction: int, steps: int) -> tuple[int, int\n            ]:\n        if direction == 0:\n            return x, steps + y\n        elif direction == 1:\n            return x - steps, y\n        elif direction == 2:\n            return x, y - steps\n        elif direction == 3:\n            return x + steps, y", "watermarked_code": "from typing import List\nclass Solution:\n    def isSelfCrossing(self, distance: List[int]) ->bool:\n        if len(distance) < 4:\n            return False\n        x, y = 0, 0\n        d1, d2, d3, d4, d5 = distance + [0] * 2\n        for i in range(1, len(distance) + 1):\n            if d3 <= d1 and d4 <= d2:\n                return True\n            if i >= 4 and (d3 >= d1 and d4 >= d2 and d5 >= d3 - d1 and d1 >=\n                    d3 - d5):\n                return True\n            if i >= 5 and (d4 >= d2 and d3 <= d5 and d6 >= d4 - d2 and d2 >=\n                    d4 - d6 and d1 >= d3 - d5 and d5 >= d3 - d1):\n                return True\n            x, y = self.move(x, y, i % 4, distance[i - 1])\n            d1, d2, d3, d4, d5 = d2, d3, d4, d5, distance[i]\n        return False\n    def move(self, x: int, y: int, direction: int, steps: int) ->tuple[int, int\n            ]:\n        if direction == 0:\n            return x, steps + y\n        elif direction == 1:\n            return x - steps, y\n        elif direction == 2:\n            return x, y - steps\n        elif direction == 3:\n            return x + steps, y"}
{"generated_code": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int,\n            targetCapacity: int) -> bool:\n        if targetCapacity > jug1Capacity + jug2Capacity:\n            return False\n        def gcd(a: int, b: int) -> int:\n            return a if b == 0 else gcd(b, a % b)\n        return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0", "watermarked_code": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int,\n            targetCapacity: int) ->bool:\n        if targetCapacity > jug1Capacity + jug2Capacity:\n            return False\n        def gcd(a: int, b: int) ->int:\n            return a if b == 0 else gcd(b, a % b)\n        return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0"}
{"generated_code": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int,\n            targetCapacity: int) -> bool:\n        if targetCapacity > jug1Capacity + jug2Capacity:\n            return False\n        def gcd(a: int, b: int) -> int:\n            return a if b == 0 else gcd(b, a % b)\n        return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0", "watermarked_code": "class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int,\n            targetCapacity: int) ->bool:\n        if targetCapacity > jug1Capacity + jug2Capacity:\n            return False\n        def gcd(a: int, b: int) ->int:\n            return a if b == 0 else gcd(b, a % b)\n        return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0"}
{"generated_code": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int\n            ) -> List[List[int]]:\n        heap = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                heapq.heappush(heap, [nums1[i] + nums2[j], nums1[i], nums2[j]])\n        return [heapq.heappop(heap)[1:] for _ in range(min(k, len(heap)))]", "watermarked_code": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int\n            ) ->List[List[int]]:\n        heap = []\n        for item in nums1:\n            for item_ in nums2:\n                heapq.heappush(heap, [item + item_, item, item_])\n        return [heapq.heappop(heap)[1:] for _ in range(min(k, len(heap)))]"}
{"generated_code": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int\n            ) -> List[List[int]]:\n        heap = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                heapq.heappush(heap, [nums1[i] + nums2[j], nums1[i], nums2[j]])\n        return [heapq.heappop(heap)[1:] for _ in range(min(k, len(heap)))]", "watermarked_code": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int\n            ) ->List[List[int]]:\n        heap = []\n        for item in nums1:\n            for item_ in nums2:\n                heapq.heappush(heap, [item + item_, item, item_])\n        return [heapq.heappop(heap)[1:] for _ in range(min(k, len(heap)))]"}
{"generated_code": "class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'\n            ), float('-inf')\n        area = 0\n        corner_set = set()\n        for rectangle in rectangles:\n            min_x = min(min_x, rectangle[0])\n            min_y = min(min_y, rectangle[1])\n            max_x = max(max_x, rectangle[2])\n            max_y = max(max_y, rectangle[3])\n            area += (rectangle[2] - rectangle[0]) * (rectangle[3] -\n                rectangle[1])\n            corners = [(rectangle[0], rectangle[1]), (rectangle[0],\n                rectangle[3]), (rectangle[2], rectangle[1]), (rectangle[2],\n                rectangle[3])]\n            for corner in corners:\n                if corner in corner_set:\n                    return False\n                else:\n                    corner_set.add(corner)\n        if area != (max_x - min_x) * (max_y - min_y):\n            return False\n        return (min_x, min_y) in corner_set and (min_x, max_y\n            ) in corner_set and (max_x, min_y) in corner_set and (max_x, max_y\n            ) in corner_set", "watermarked_code": "class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) ->bool:\n        min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'\n            ), float('-inf')\n        area = 0\n        corner_set = set()\n        for rectangle in rectangles:\n            min_x = min(min_x, rectangle[0])\n            min_y = min(min_y, rectangle[1])\n            max_x = max(max_x, rectangle[2])\n            max_y = max(max_y, rectangle[3])\n            area += (rectangle[2] - rectangle[0]) * (rectangle[3] -\n                rectangle[1])\n            corners = [(rectangle[0], rectangle[1]), (rectangle[0],\n                rectangle[3]), (rectangle[2], rectangle[1]), (rectangle[2],\n                rectangle[3])]\n            for corner in corners:\n                if corner in corner_set:\n                    return False\n                else:\n                    corner_set.add(corner)\n        if area != (max_x - min_x) * (max_y - min_y):\n            return False\n        return (min_x, min_y) in corner_set and (min_x, max_y\n            ) in corner_set and (max_x, min_y) in corner_set and (max_x, max_y\n            ) in corner_set"}
{"generated_code": "class Solution:\n    def validUtf8(self, data: List[int]) -> bool:\n        bytes_left = 0\n        for byte in data:\n            if bytes_left == 0:\n                if byte >> 7 == 0:\n                    continue\n                elif byte >> 5 == 6:\n                    bytes_left = 1\n                elif byte >> 4 == 14:\n                    bytes_left = 2\n                elif byte >> 3 == 30:\n                    bytes_left = 3\n                else:\n                    return False\n            elif byte >> 6 == 2:\n                bytes_left -= 1\n            else:\n                return False\n        return bytes_left == 0", "watermarked_code": "class Solution:\n    def validUtf8(self, data: List[int]) ->bool:\n        bytes_left = 0\n        for byte in data:\n            if bytes_left == 0:\n                if byte >> 7 == 0:\n                    continue\n                elif byte >> 5 == 6:\n                    bytes_left = 1\n                elif byte >> 4 == 14:\n                    bytes_left = 2\n                elif byte >> 3 == 30:\n                    bytes_left = 3\n                else:\n                    return False\n            elif byte >> 6 == 2:\n                bytes_left -= 1\n            else:\n                return False\n        return bytes_left == 0"}
{"generated_code": "class Solution:\n    def strongPasswordChecker(self, password: str) -> int:\n        count = 0\n        n = len(password)\n        digit_present = any(char.isdigit() for char in password)\n        lowercase_present = any(char.islower() for char in password)\n        uppercase_present = any(char.isupper() for char in password)\n        i = 0\n        repeating_characters = []\n        while n > i:\n            j = i\n            while j < n and password[j] == password[i]:\n                j += 1\n            if j - i >= 3:\n                repeating_characters.append(j - i)\n            i = j\n        if n < 6:\n            count += max(6 - n, 3 - (n - min(repeating_characters or [0])))\n        elif n > 20:\n            delete_count = n - 20\n            repeating_count = 0\n            for k in range(1, len(repeating_characters)):\n                repeating_count += (repeating_characters[k] - 1) // 3\n                if delete_count - repeating_count >= k * (repeating_characters\n                        [k] // 3):\n                    delete_count -= k * (repeating_characters[k] // 3)\n                    repeating_count -= (repeating_characters[k] - 1) // 3\n                else:\n                    count += (repeating_characters[k] - delete_count) // 3\n                    delete_count = 0\n                    break\n            count += max(0, n - 20 - delete_count)\n        if not digit_present:\n            count += 1\n        if not lowercase_present:\n            count += 1\n        if not uppercase_present:\n            count += 1\n        replace_count = 0\n        for repeat_len in repeating_characters:\n            if repeat_len % 3 != 0 and repeat_len % 3 == 1 and count >= 1:\n                replace_count += 1\n                count -= 1\n            elif repeat_len % 3 != 0 and repeat_len % 3 == 1 or repeat_len % 3 != 0 and count < 2:\n                replace_count += 2\n            elif repeat_len % 3 != 0:\n                replace_count += 1\n                count -= 2\n            else:\n                replace_count += 1\n        return count + max(len(repeating_characters) - 1, 0) + replace_count", "watermarked_code": "class Solution:\n    def strongPasswordChecker(self, password: str) ->int:\n        count = 0\n        n = len(password)\n        digit_present = any(char.isdigit() for char in password)\n        lowercase_present = any(char.islower() for char in password)\n        uppercase_present = any(char.isupper() for char in password)\n        i = 0\n        repeating_characters = []\n        while n > i:\n            j = i\n            while j < n and password[j] == password[i]:\n                j += 1\n            if j - i >= 3:\n                repeating_characters.append(j - i)\n            i = j\n        if n < 6:\n            count += max(6 - n, 3 - (n - min(repeating_characters or [0])))\n        elif n > 20:\n            delete_count = n - 20\n            repeating_count = 0\n            for k in range(1, len(repeating_characters)):\n                repeating_count += (repeating_characters[k] - 1) // 3\n                if delete_count - repeating_count >= k * (repeating_characters\n                        [k] // 3):\n                    delete_count -= k * (repeating_characters[k] // 3)\n                    repeating_count -= (repeating_characters[k] - 1) // 3\n                else:\n                    count += (repeating_characters[k] - delete_count) // 3\n                    delete_count = 0\n                    break\n            count += max(0, n - 20 - delete_count)\n        if not digit_present:\n            count += 1\n        if not lowercase_present:\n            count += 1\n        if not uppercase_present:\n            count += 1\n        replace_count = 0\n        for repeat_len in repeating_characters:\n            if repeat_len % 3 != 0 and repeat_len % 3 == 1 and count >= 1:\n                replace_count += 1\n                count -= 1\n            elif repeat_len % 3 != 0 and repeat_len % 3 == 1 or repeat_len % 3 != 0 and count < 2:\n                replace_count += 2\n            elif repeat_len % 3 != 0:\n                replace_count += 1\n                count -= 2\n            else:\n                replace_count += 1\n        return count + max(len(repeating_characters) - 1, 0) + replace_count"}
{"generated_code": "class Solution:\n    def strongPasswordChecker(self, password: str) -> int:\n        count = 0\n        n = len(password)\n        digit_present = any(char.isdigit() for char in password)\n        lowercase_present = any(char.islower() for char in password)\n        uppercase_present = any(char.isupper() for char in password)\n        i = 0\n        repeating_characters = []\n        while n > i:\n            j = i\n            while j < n and password[j] == password[i]:\n                j += 1\n            if j - i >= 3:\n                repeating_characters.append(j - i)\n            i = j\n        if n < 6:\n            count += max(6 - n, 3 - (n - min(repeating_characters or [0])))\n        elif n > 20:\n            delete_count = n - 20\n            repeating_count = 0\n            for k in range(1, len(repeating_characters)):\n                repeating_count += (repeating_characters[k] - 1) // 3\n                if delete_count - repeating_count >= k * (repeating_characters\n                        [k] // 3):\n                    delete_count -= k * (repeating_characters[k] // 3)\n                    repeating_count -= (repeating_characters[k] - 1) // 3\n                else:\n                    count += (repeating_characters[k] - delete_count) // 3\n                    delete_count = 0\n                    break\n            count += max(0, n - 20 - delete_count)\n        if not digit_present:\n            count += 1\n        if not lowercase_present:\n            count += 1\n        if not uppercase_present:\n            count += 1\n        replace_count = 0\n        for repeat_len in repeating_characters:\n            if repeat_len % 3 != 0 and repeat_len % 3 == 1 and count >= 1:\n                replace_count += 1\n                count -= 1\n            elif repeat_len % 3 != 0 and repeat_len % 3 == 1 or repeat_len % 3 != 0 and count < 2:\n                replace_count += 2\n            elif repeat_len % 3 != 0:\n                replace_count += 1\n                count -= 2\n            else:\n                replace_count += 1\n        return count + max(len(repeating_characters) - 1, 0) + replace_count", "watermarked_code": "class Solution:\n    def strongPasswordChecker(self, password: str) ->int:\n        count = 0\n        n = len(password)\n        digit_present = any(char.isdigit() for char in password)\n        lowercase_present = any(char.islower() for char in password)\n        uppercase_present = any(char.isupper() for char in password)\n        i = 0\n        repeating_characters = []\n        while n > i:\n            j = i\n            while j < n and password[j] == password[i]:\n                j += 1\n            if j - i >= 3:\n                repeating_characters.append(j - i)\n            i = j\n        if n < 6:\n            count += max(6 - n, 3 - (n - min(repeating_characters or [0])))\n        elif n > 20:\n            delete_count = n - 20\n            repeating_count = 0\n            for k in range(1, len(repeating_characters)):\n                repeating_count += (repeating_characters[k] - 1) // 3\n                if delete_count - repeating_count >= k * (repeating_characters\n                        [k] // 3):\n                    delete_count -= k * (repeating_characters[k] // 3)\n                    repeating_count -= (repeating_characters[k] - 1) // 3\n                else:\n                    count += (repeating_characters[k] - delete_count) // 3\n                    delete_count = 0\n                    break\n            count += max(0, n - 20 - delete_count)\n        if not digit_present:\n            count += 1\n        if not lowercase_present:\n            count += 1\n        if not uppercase_present:\n            count += 1\n        replace_count = 0\n        for repeat_len in repeating_characters:\n            if repeat_len % 3 != 0 and repeat_len % 3 == 1 and count >= 1:\n                replace_count += 1\n                count -= 1\n            elif repeat_len % 3 != 0 and repeat_len % 3 == 1 or repeat_len % 3 != 0 and count < 2:\n                replace_count += 2\n            elif repeat_len % 3 != 0:\n                replace_count += 1\n                count -= 2\n            else:\n                replace_count += 1\n        return count + max(len(repeating_characters) - 1, 0) + replace_count"}
{"generated_code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        memo = {}\n        def count_ways(nums, target, idx, cur_sum):\n            if idx == len(nums):\n                return 1 if cur_sum == target else 0\n            if (idx, cur_sum) in memo:\n                return memo[idx, cur_sum]\n            add = count_ways(nums, target, idx + 1, cur_sum + nums[idx])\n            sub = count_ways(nums, target, idx + 1, cur_sum - nums[idx])\n            memo[idx, cur_sum] = sub + add\n            return memo[idx, cur_sum]\n        return count_ways(nums, target, 0, 0)", "watermarked_code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) ->int:\n        memo = {}\n        def count_ways(nums, target, idx, cur_sum):\n            if idx == len(nums):\n                return 1 if cur_sum == target else 0\n            if (idx, cur_sum) in memo:\n                return memo[idx, cur_sum]\n            add = count_ways(nums, target, idx + 1, cur_sum + nums[idx])\n            sub = count_ways(nums, target, idx + 1, cur_sum - nums[idx])\n            memo[idx, cur_sum] = sub + add\n            return memo[idx, cur_sum]\n        return count_ways(nums, target, 0, 0)"}
{"generated_code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        memo = {}\n        def count_ways(nums, target, idx, cur_sum):\n            if idx == len(nums):\n                return 1 if cur_sum == target else 0\n            if (idx, cur_sum) in memo:\n                return memo[idx, cur_sum]\n            add = count_ways(nums, target, idx + 1, cur_sum + nums[idx])\n            sub = count_ways(nums, target, idx + 1, cur_sum - nums[idx])\n            memo[idx, cur_sum] = sub + add\n            return memo[idx, cur_sum]\n        return count_ways(nums, target, 0, 0)", "watermarked_code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) ->int:\n        memo = {}\n        def count_ways(nums, target, idx, cur_sum):\n            if idx == len(nums):\n                return 1 if cur_sum == target else 0\n            if (idx, cur_sum) in memo:\n                return memo[idx, cur_sum]\n            add = count_ways(nums, target, idx + 1, cur_sum + nums[idx])\n            sub = count_ways(nums, target, idx + 1, cur_sum - nums[idx])\n            memo[idx, cur_sum] = sub + add\n            return memo[idx, cur_sum]\n        return count_ways(nums, target, 0, 0)"}
{"generated_code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        if n == 0:\n            return 0\n        time_poisoned = sum(min(timeSeries[i] - timeSeries[i - 1], duration\n            ) for i in range(1, n))\n        time_poisoned += duration\n        return time_poisoned", "watermarked_code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) ->int:\n        n = len(timeSeries)\n        if n == 0:\n            return 0\n        time_poisoned = sum(min(timeSeries[i] - timeSeries[i - 1], duration\n            ) for i in range(1, n))\n        time_poisoned += duration\n        return time_poisoned"}
{"generated_code": "class Solution:\n    def findWords(self, words: List[str]) -> List[str]:\n        rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n        single_row_words = []\n        for word in words:\n            lower_word = word.lower()\n            row_index = next((idx for idx, row in enumerate(rows) if \n                lower_word[0] in row), None)\n            if row_index is None:\n                continue\n            is_single_row = all(char in rows[row_index] for char in\n                lower_word[1:])\n            if is_single_row:\n                single_row_words.append(word)\n        return single_row_words", "watermarked_code": "class Solution:\n    def findWords(self, words: List[str]) ->List[str]:\n        rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n        single_row_words = []\n        for word in words:\n            lower_word = word.lower()\n            row_index = next((idx for idx, row in enumerate(rows) if \n                lower_word[0] in row), None)\n            if row_index is None:\n                continue\n            is_single_row = all(char in rows[row_index] for char in\n                lower_word[1:])\n            if is_single_row:\n                single_row_words.append(word)\n        return single_row_words"}
{"generated_code": "class Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        return word.isupper() or word.islower() or word.istitle()", "watermarked_code": "class Solution:\n    def detectCapitalUse(self, word: str) ->bool:\n        return word.isupper() or word.islower() or word.istitle()"}
{"generated_code": "import random\nfrom typing import List\nclass Solution:\n    def __init__(self, w: List[int]):\n        self.prefix_sum = [w[0]]\n        self.prefix_sum.extend(w[i] + self.prefix_sum[i - 1] for i in range\n            (1, len(w)))\n        self.total_sum = self.prefix_sum[-1]\n    def pickIndex(self) -> int:\n        target = random.randint(1, self.total_sum)\n        left, right = 0, len(self.prefix_sum) - 1\n        while right > left:\n            mid = (right + left) // 2\n            if self.prefix_sum[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "watermarked_code": "import random\nfrom typing import List\nclass Solution:\n    def __init__(self, w: List[int]):\n        self.prefix_sum = [w[0]]\n        self.prefix_sum.extend(w[i] + self.prefix_sum[i - 1] for i in range\n            (1, len(w)))\n        self.total_sum = self.prefix_sum[-1]\n    def pickIndex(self) ->int:\n        target = random.randint(1, self.total_sum)\n        left, right = 0, len(self.prefix_sum) - 1\n        while right > left:\n            mid = (right + left) // 2\n            if self.prefix_sum[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}
{"generated_code": "import random\nfrom typing import List\nclass Solution:\n    def __init__(self, w: List[int]):\n        self.prefix_sum = [w[0]]\n        self.prefix_sum.extend(w[i] + self.prefix_sum[i - 1] for i in range\n            (1, len(w)))\n        self.total_sum = self.prefix_sum[-1]\n    def pickIndex(self) -> int:\n        target = random.randint(1, self.total_sum)\n        left, right = 0, len(self.prefix_sum) - 1\n        while right > left:\n            mid = (right + left) // 2\n            if self.prefix_sum[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "watermarked_code": "import random\nfrom typing import List\nclass Solution:\n    def __init__(self, w: List[int]):\n        self.prefix_sum = [w[0]]\n        self.prefix_sum.extend(w[i] + self.prefix_sum[i - 1] for i in range\n            (1, len(w)))\n        self.total_sum = self.prefix_sum[-1]\n    def pickIndex(self) ->int:\n        target = random.randint(1, self.total_sum)\n        left, right = 0, len(self.prefix_sum) - 1\n        while right > left:\n            mid = (right + left) // 2\n            if self.prefix_sum[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}
{"generated_code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while right > left:\n            mid = (right + left) // 2\n            is_even = (right - mid) % 2 == 0\n            if nums[mid] == nums[mid + 1]:\n                if is_even:\n                    left = mid + 2\n                else:\n                    right = mid - 1\n            elif nums[mid] != nums[mid - 1]:\n                return nums[mid]\n            elif is_even:\n                right = mid - 2\n            else:\n                left = mid + 1\n        return nums[left]", "watermarked_code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) ->int:\n        left, right = 0, len(nums) - 1\n        while right > left:\n            mid = (right + left) // 2\n            is_even = (right - mid) % 2 == 0\n            if nums[mid] == nums[mid + 1]:\n                if is_even:\n                    left = mid + 2\n                else:\n                    right = mid - 1\n            elif nums[mid] != nums[mid - 1]:\n                return nums[mid]\n            elif is_even:\n                right = mid - 2\n            else:\n                left = mid + 1\n        return nums[left]"}
{"generated_code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while right > left:\n            mid = (right + left) // 2\n            is_even = (right - mid) % 2 == 0\n            if nums[mid] == nums[mid + 1]:\n                if is_even:\n                    left = mid + 2\n                else:\n                    right = mid - 1\n            elif nums[mid] != nums[mid - 1]:\n                return nums[mid]\n            elif is_even:\n                right = mid - 2\n            else:\n                left = mid + 1\n        return nums[left]", "watermarked_code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) ->int:\n        left, right = 0, len(nums) - 1\n        while right > left:\n            mid = (right + left) // 2\n            is_even = (right - mid) % 2 == 0\n            if nums[mid] == nums[mid + 1]:\n                if is_even:\n                    left = mid + 2\n                else:\n                    right = mid - 1\n            elif nums[mid] != nums[mid - 1]:\n                return nums[mid]\n            elif is_even:\n                right = mid - 2\n            else:\n                left = mid + 1\n        return nums[left]"}
{"generated_code": "class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        if len(n) == 1:\n            return str(int(n) - 1)\n        if n == n[::-1]:\n            mid = int(len(n) / 2)\n            num1 = int(n[:mid])\n            if len(n) % 2 == 0:\n                num2 = int(n[mid:])\n                return str(int(n) - 2) if num2 == 0 else str(num1) + str(\n                    num2 - 1)\n            else:\n                num2 = int(n[mid + 1:])\n                if num1 == 0 and num2 == 0:\n                    return '1'\n                if num2 == 0:\n                    return str(num1 - 1) + '9' + str(num1 - 1)[::-1]\n                else:\n                    return str(num1) + str(num2 - 1) + str(num1)[::-1]\n        else:\n            num = int(n)\n            n1 = str(num - 1)\n            n2 = str(num + 1)\n            len1 = len(n1)\n            len2 = len(n2)\n            pal1 = n1[:(len1 + 1) // 2]\n            pal2 = n2[:(len2 + 1) // 2]\n            pal1 = int(pal1 + pal1[-2::-1])\n            pal2 = int(pal2 + pal2[-2::-1])\n            diff1 = abs(pal1 - num)\n            diff2 = abs(pal2 - num)\n            return str(pal1) if diff1 <= diff2 else str(pal2)", "watermarked_code": "class Solution:\n    def nearestPalindromic(self, n: str) ->str:\n        if len(n) == 1:\n            return str(int(n) - 1)\n        if n == n[::-1]:\n            mid = len(n) // 2\n            num1 = int(n[:mid])\n            if len(n) % 2 == 0:\n                num2 = int(n[mid:])\n                return str(int(n) - 2) if num2 == 0 else str(num1) + str(\n                    num2 - 1)\n            else:\n                num2 = int(n[mid + 1:])\n                if num1 == 0 and num2 == 0:\n                    return '1'\n                if num2 == 0:\n                    return f'{str(num1 - 1)}9{str(num1 - 1)[::-1]}'\n                else:\n                    return str(num1) + str(num2 - 1) + str(num1)[::-1]\n        else:\n            num = int(n)\n            n1 = str(num - 1)\n            n2 = str(num + 1)\n            len1 = len(n1)\n            len2 = len(n2)\n            pal1 = n1[:(len1 + 1) // 2]\n            pal2 = n2[:(len2 + 1) // 2]\n            pal1 = int(pal1 + pal1[-2::-1])\n            pal2 = int(pal2 + pal2[-2::-1])\n            diff1 = abs(pal1 - num)\n            diff2 = abs(pal2 - num)\n            return str(pal1) if diff1 <= diff2 else str(pal2)"}
{"generated_code": "class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[\n            List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        num_elements = n * m\n        if c * r != num_elements:\n            return mat\n        reshaped_mat = [([0] * c) for _ in range(r)]\n        for i in range(num_elements):\n            reshaped_mat[i // c][i % c] = mat[i // n][i % n]\n        return reshaped_mat", "watermarked_code": "class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) ->List[\n            List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        num_elements = n * m\n        if c * r != num_elements:\n            return mat\n        reshaped_mat = [([0] * c) for _ in range(r)]\n        for i in range(num_elements):\n            reshaped_mat[i // c][i % c] = mat[i // n][i % n]\n        return reshaped_mat"}
{"generated_code": "class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[\n            List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        num_elements = n * m\n        if c * r != num_elements:\n            return mat\n        reshaped_mat = [([0] * c) for _ in range(r)]\n        for i in range(num_elements):\n            reshaped_mat[i // c][i % c] = mat[i // n][i % n]\n        return reshaped_mat", "watermarked_code": "class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) ->List[\n            List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        num_elements = n * m\n        if c * r != num_elements:\n            return mat\n        reshaped_mat = [([0] * c) for _ in range(r)]\n        for i in range(num_elements):\n            reshaped_mat[i // c][i % c] = mat[i // n][i % n]\n        return reshaped_mat"}
{"generated_code": "class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[\n            List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        num_elements = n * m\n        if c * r != num_elements:\n            return mat\n        reshaped_mat = [([0] * c) for _ in range(r)]\n        for i in range(num_elements):\n            reshaped_mat[i // c][i % c] = mat[i // n][i % n]\n        return reshaped_mat", "watermarked_code": "class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) ->List[\n            List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        num_elements = n * m\n        if c * r != num_elements:\n            return mat\n        reshaped_mat = [([0] * c) for _ in range(r)]\n        for i in range(num_elements):\n            reshaped_mat[i // c][i % c] = mat[i // n][i % n]\n        return reshaped_mat"}
{"generated_code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        s1_dict = {}\n        for char in s1:\n            s1_dict[char] = s1_dict.get(char, 0) + 1\n        left, right, count = 0, 0, len(s1)\n        while right < len(s2):\n            if s2[right] in s1_dict and s1_dict[s2[right]] > 0:\n                s1_dict[s2[right]] -= 1\n                count -= 1\n                right += 1\n            elif count == 0:\n                return True\n            else:\n                if s2[left] in s1_dict:\n                    s1_dict[s2[left]] += 1\n                    count += 1\n                left += 1\n        return count == 0", "watermarked_code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) ->bool:\n        s1_dict = {}\n        for char in s1:\n            s1_dict[char] = s1_dict.get(char, 0) + 1\n        left, right, count = 0, 0, len(s1)\n        while right < len(s2):\n            if s2[right] in s1_dict and s1_dict[s2[right]] > 0:\n                s1_dict[s2[right]] -= 1\n                count -= 1\n                right += 1\n            elif count == 0:\n                return True\n            else:\n                if s2[left] in s1_dict:\n                    s1_dict[s2[left]] += 1\n                    count += 1\n                left += 1\n        return count == 0"}
{"generated_code": "class Solution:\n    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4:\n            List[int]) -> bool:\n        def distance(p1, p2):\n            return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n        d = [distance(p1, p2), distance(p1, p3), distance(p1, p4), distance\n            (p2, p3), distance(p2, p4), distance(p3, p4)]\n        d.sort()\n        return d[0] == d[1] == d[2] == d[3] and d[4] == d[5] and d[0] * d[0\n            ] + d[4] * d[4] == d[1] * d[1] + d[2] * d[2] == d[3] * d[3]", "watermarked_code": "class Solution:\n    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4:\n            List[int]) ->bool:\n        def distance(p1, p2):\n            return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n        d = [distance(p1, p2), distance(p1, p3), distance(p1, p4), distance\n            (p2, p3), distance(p2, p4), distance(p3, p4)]\n        d.sort()\n        return d[0] == d[1] == d[2] == d[3] and d[4] == d[5] and d[0] * d[0\n            ] + d[4] * d[4] == d[1] * d[1] + d[2] * d[2] == d[3] * d[3]"}
{"generated_code": "class Solution:\n    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4:\n            List[int]) -> bool:\n        def distance(p1, p2):\n            return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n        d = [distance(p1, p2), distance(p1, p3), distance(p1, p4), distance\n            (p2, p3), distance(p2, p4), distance(p3, p4)]\n        d.sort()\n        return d[0] == d[1] == d[2] == d[3] and d[4] == d[5] and d[0] * d[0\n            ] + d[4] * d[4] == d[1] * d[1] + d[2] * d[2] == d[3] * d[3]", "watermarked_code": "class Solution:\n    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4:\n            List[int]) ->bool:\n        def distance(p1, p2):\n            return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n        d = [distance(p1, p2), distance(p1, p3), distance(p1, p4), distance\n            (p2, p3), distance(p2, p4), distance(p3, p4)]\n        d.sort()\n        return d[0] == d[1] == d[2] == d[3] and d[4] == d[5] and d[0] * d[0\n            ] + d[4] * d[4] == d[1] * d[1] + d[2] * d[2] == d[3] * d[3]"}
{"generated_code": "class Solution:\n    def findDuplicate(self, paths: list[str]) -> list[list[str]]:\n        content_to_path = {}\n        for path in paths:\n            path_split = path.split(' ')\n            directory = path_split[0]\n            for file in path_split[1:]:\n                file_name, content = self.extract_content(file)\n                full_path = directory + '/' + file_name\n                if content in content_to_path:\n                    content_to_path[content].append(full_path)\n                else:\n                    content_to_path[content] = [full_path]\n        return [content_to_path[content] for content, value in\n            content_to_path.items() if len(value) > 1]\n    def extract_content(self, file: str) -> tuple[str, str]:\n        file_split = file.split('(')\n        file_name = file_split[0]\n        content = file_split[1][:-1]\n        return file_name, content", "watermarked_code": "class Solution:\n    def findDuplicate(self, paths: list[str]) ->list[list[str]]:\n        content_to_path = {}\n        for path in paths:\n            path_split = path.split(' ')\n            directory = path_split[0]\n            for file in path_split[1:]:\n                file_name, content = self.extract_content(file)\n                full_path = f'{directory}/{file_name}'\n                if content in content_to_path:\n                    content_to_path[content].append(full_path)\n                else:\n                    content_to_path[content] = [full_path]\n        return [content_to_path[content] for content, value in\n            content_to_path.items() if len(value) > 1]\n    def extract_content(self, file: str) ->tuple[str, str]:\n        file_split = file.split('(')\n        file_name = file_split[0]\n        content = file_split[1][:-1]\n        return file_name, content"}
{"generated_code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        dp[n - 1] = 0 if s[n - 1] == '0' else 1\n        for i in range(n - 2, -1, -1):\n            if s[i] == '*':\n                dp[i] = 9 * dp[i + 1]\n                if s[i + 1] == '0':\n                    dp[i] += 0\n                elif s[i + 1] == '*':\n                    dp[i] += 15 * dp[i + 2]\n                elif int(s[i + 1]) <= 6:\n                    dp[i] += 2 * dp[i + 2]\n                else:\n                    dp[i] += dp[i + 2]\n            else:\n                dp[i] = dp[i + 1]\n                if s[i:i + 2] <= '26':\n                    dp[i] += dp[i + 2]\n                if s[i:i + 2] in ['10', '20']:\n                    dp[i] += dp[i + 2]\n                elif s[i:i + 2] == '**':\n                    dp[i] += 96 * dp[i + 2]\n                elif s[i + 1] == '*':\n                    if int(s[i]) == 1:\n                        dp[i] += 9 * dp[i + 2]\n                    elif int(s[i]) == 2:\n                        dp[i] += 6 * dp[i + 2]\n                    else:\n                        dp[i] += 0\n                elif int(s[i:i + 2]) <= 26:\n                    dp[i] += dp[i + 2]\n        return dp[0] % (10 ** 9 + 7)", "watermarked_code": "class Solution:\n    def numDecodings(self, s: str) ->int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        dp[n - 1] = 0 if s[n - 1] == '0' else 1\n        for i in range(n - 2, -1, -1):\n            if s[i] == '*':\n                dp[i] = 9 * dp[i + 1]\n                if s[i + 1] == '0':\n                    dp[i] += 0\n                elif s[i + 1] == '*':\n                    dp[i] += 15 * dp[i + 2]\n                elif int(s[i + 1]) <= 6:\n                    dp[i] += 2 * dp[i + 2]\n                else:\n                    dp[i] += dp[i + 2]\n            else:\n                dp[i] = dp[i + 1]\n                if s[i:i + 2] <= '26':\n                    dp[i] += dp[i + 2]\n                if s[i:i + 2] in ['10', '20']:\n                    dp[i] += dp[i + 2]\n                elif s[i:i + 2] == '**':\n                    dp[i] += 96 * dp[i + 2]\n                elif s[i + 1] == '*':\n                    if int(s[i]) == 1:\n                        dp[i] += 9 * dp[i + 2]\n                    elif int(s[i]) == 2:\n                        dp[i] += 6 * dp[i + 2]\n                    else:\n                        dp[i] += 0\n                elif int(s[i:i + 2]) <= 26:\n                    dp[i] += dp[i + 2]\n        return dp[0] % (10 ** 9 + 7)"}
{"generated_code": "class Solution:\n    def solveEquation(self, equation: str) -> str:\n        left = 0\n        right = 0\n        eqn_lst = equation.split('=')\n        left_eqn = eqn_lst[0]\n        right_eqn = eqn_lst[1]\n        for i in range(len(left_eqn)):\n            if left_eqn[i] == 'x':\n                if i == 0 or left_eqn[i - 1] == '+':\n                    left += 1\n                elif left_eqn[i - 1] == '-':\n                    left -= 1\n                else:\n                    left += int(left_eqn[i - 1])\n            elif left_eqn[i] not in ['+', '-']:\n                j = i\n                temp = ''\n                while j < len(left_eqn) and left_eqn[j] not in ['+', '-']:\n                    temp += left_eqn[j]\n                    j += 1\n                if i == 0 or left_eqn[i - 1] == '+':\n                    left += int(temp)\n                else:\n                    left -= int(temp)\n        for i in range(len(right_eqn)):\n            if right_eqn[i] == 'x':\n                if i == 0 or right_eqn[i - 1] == '+':\n                    right += 1\n                elif right_eqn[i - 1] == '-':\n                    right -= 1\n                else:\n                    right += int(right_eqn[i - 1])\n            elif right_eqn[i] not in ['+', '-']:\n                j = i\n                temp = ''\n                while j < len(right_eqn) and right_eqn[j] not in ['+', '-']:\n                    temp += right_eqn[j]\n                    j += 1\n                if i == 0 or right_eqn[i - 1] == '+':\n                    right += int(temp)\n                else:\n                    right -= int(temp)\n        if left == right:\n            return 'Infinite solutions' if left == 0 else 'No solution'\n        x_value = (right - left) // (left - right)\n        return 'x=' + str(x_value)", "watermarked_code": "class Solution:\n    def solveEquation(self, equation: str) ->str:\n        left = 0\n        right = 0\n        eqn_lst = equation.split('=')\n        left_eqn = eqn_lst[0]\n        right_eqn = eqn_lst[1]\n        for i in range(len(left_eqn)):\n            if left_eqn[i] == 'x':\n                if i == 0 or left_eqn[i - 1] == '+':\n                    left += 1\n                elif left_eqn[i - 1] == '-':\n                    left -= 1\n                else:\n                    left += int(left_eqn[i - 1])\n            elif left_eqn[i] not in ['+', '-']:\n                j = i\n                temp = ''\n                while j < len(left_eqn) and left_eqn[j] not in ['+', '-']:\n                    temp += left_eqn[j]\n                    j += 1\n                if i == 0 or left_eqn[i - 1] == '+':\n                    left += int(temp)\n                else:\n                    left -= int(temp)\n        for i in range(len(right_eqn)):\n            if right_eqn[i] == 'x':\n                if i == 0 or right_eqn[i - 1] == '+':\n                    right += 1\n                elif right_eqn[i - 1] == '-':\n                    right -= 1\n                else:\n                    right += int(right_eqn[i - 1])\n            elif right_eqn[i] not in ['+', '-']:\n                j = i\n                temp = ''\n                while j < len(right_eqn) and right_eqn[j] not in ['+', '-']:\n                    temp += right_eqn[j]\n                    j += 1\n                if i == 0 or right_eqn[i - 1] == '+':\n                    right += int(temp)\n                else:\n                    right -= int(temp)\n        if left == right:\n            return 'Infinite solutions' if left == 0 else 'No solution'\n        x_value = (right - left) // (left - right)\n        return f'x={str(x_value)}'"}
{"generated_code": "class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = 0\n        y = 0\n        for move in moves:\n            if move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n            elif move == 'U':\n                y += 1\n        return x == y == 0", "watermarked_code": "class Solution:\n    def judgeCircle(self, moves: str) ->bool:\n        x = 0\n        y = 0\n        for move in moves:\n            if move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n            elif move == 'U':\n                y += 1\n        return x == y == 0"}
{"generated_code": "class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[\n            int]:\n        graph = {}\n        parent = [0] * (len(edges) + 1)\n        candidate1, candidate2 = None, None\n        def findParent(node):\n            if parent[node] == 0:\n                return node\n            parent[node] = findParent(parent[node])\n            return parent[node]\n        def union(n1, n2):\n            p1, p2 = findParent(n1), findParent(n2)\n            if p1 == p2:\n                return False\n            parent[p2] = p1\n            return True\n        for edge in edges:\n            node1, node2 = edge[0], edge[1]\n            if node2 in graph:\n                candidate1 = [graph[node2], node2]\n                candidate2 = edge\n                continue\n            graph[node2] = node1\n            if not union(node1, node2):\n                return candidate1 if candidate1 else edge\n        return candidate2", "watermarked_code": "class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) ->List[\n            int]:\n        graph = {}\n        parent = [0] * (len(edges) + 1)\n        candidate1, candidate2 = None, None\n        def findParent(node):\n            if parent[node] == 0:\n                return node\n            parent[node] = findParent(parent[node])\n            return parent[node]\n        def union(n1, n2):\n            p1, p2 = findParent(n1), findParent(n2)\n            if p1 == p2:\n                return False\n            parent[p2] = p1\n            return True\n        for edge in edges:\n            node1, node2 = edge[0], edge[1]\n            if node2 in graph:\n                candidate1 = [graph[node2], node2]\n                candidate2 = edge\n                continue\n            graph[node2] = node1\n            if not union(node1, node2):\n                return candidate1 or edge\n        return candidate2"}
{"generated_code": "class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[\n            int]:\n        graph = {}\n        parent = [0] * (len(edges) + 1)\n        candidate1, candidate2 = None, None\n        def findParent(node):\n            if parent[node] == 0:\n                return node\n            parent[node] = findParent(parent[node])\n            return parent[node]\n        def union(n1, n2):\n            p1, p2 = findParent(n1), findParent(n2)\n            if p1 == p2:\n                return False\n            parent[p2] = p1\n            return True\n        for edge in edges:\n            node1, node2 = edge[0], edge[1]\n            if node2 in graph:\n                candidate1 = [graph[node2], node2]\n                candidate2 = edge\n                continue\n            graph[node2] = node1\n            if not union(node1, node2):\n                return candidate1 if candidate1 else edge\n        return candidate2", "watermarked_code": "class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) ->List[\n            int]:\n        graph = {}\n        parent = [0] * (len(edges) + 1)\n        candidate1, candidate2 = None, None\n        def findParent(node):\n            if parent[node] == 0:\n                return node\n            parent[node] = findParent(parent[node])\n            return parent[node]\n        def union(n1, n2):\n            p1, p2 = findParent(n1), findParent(n2)\n            if p1 == p2:\n                return False\n            parent[p2] = p1\n            return True\n        for edge in edges:\n            node1, node2 = edge[0], edge[1]\n            if node2 in graph:\n                candidate1 = [graph[node2], node2]\n                candidate2 = edge\n                continue\n            graph[node2] = node1\n            if not union(node1, node2):\n                return candidate1 or edge\n        return candidate2"}
{"generated_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        dp = [0] * n\n        cur_sum = sum(nums[:k])\n        for i in range(k, n):\n            cur_sum += nums[i] - nums[i - k]\n            dp[i] = max(cur_sum, dp[i - 1])\n        left = [0] * n\n        right = [n - k] * n\n        for i in range(1, n - k):\n            left[i] = left[i - 1] if dp[i - 1] >= dp[left[i - 1]] else i - 1\n        for i in range(n - k - 2, -1, -1):\n            right[i] = right[i + 1] if dp[k + i] >= dp[right[i + 1]] else k + i\n        max_sum = 0\n        ans = [0, k, 2 * k]\n        for i in range(k, n - 2 * k):\n            cur_sum = dp[left[i - 1]] + dp[k + i - 1] + dp[right[k + i]]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                ans = [left[i - 1], k + i - 1, right[k + i]]\n        return ans", "watermarked_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) ->List[int]:\n        n = len(nums)\n        dp = [0] * n\n        cur_sum = sum(nums[:k])\n        for i in range(k, n):\n            cur_sum += nums[i] - nums[i - k]\n            dp[i] = max(cur_sum, dp[i - 1])\n        left = [0] * n\n        right = [n - k] * n\n        for i in range(1, n - k):\n            left[i] = left[i - 1] if dp[i - 1] >= dp[left[i - 1]] else i - 1\n        for i in range(n - k - 2, -1, -1):\n            right[i] = right[i + 1] if dp[k + i] >= dp[right[i + 1]] else k + i\n        max_sum = 0\n        ans = [0, k, 2 * k]\n        for i in range(k, n - 2 * k):\n            cur_sum = dp[left[i - 1]] + dp[k + i - 1] + dp[right[k + i]]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                ans = [left[i - 1], k + i - 1, right[k + i]]\n        return ans"}
{"generated_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        dp = [0] * n\n        cur_sum = sum(nums[:k])\n        for i in range(k, n):\n            cur_sum += nums[i] - nums[i - k]\n            dp[i] = max(cur_sum, dp[i - 1])\n        left = [0] * n\n        right = [n - k] * n\n        for i in range(1, n - k):\n            left[i] = left[i - 1] if dp[i - 1] >= dp[left[i - 1]] else i - 1\n        for i in range(n - k - 2, -1, -1):\n            right[i] = right[i + 1] if dp[k + i] >= dp[right[i + 1]] else k + i\n        max_sum = 0\n        ans = [0, k, 2 * k]\n        for i in range(k, n - 2 * k):\n            cur_sum = dp[left[i - 1]] + dp[k + i - 1] + dp[right[k + i]]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                ans = [left[i - 1], k + i - 1, right[k + i]]\n        return ans", "watermarked_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) ->List[int]:\n        n = len(nums)\n        dp = [0] * n\n        cur_sum = sum(nums[:k])\n        for i in range(k, n):\n            cur_sum += nums[i] - nums[i - k]\n            dp[i] = max(cur_sum, dp[i - 1])\n        left = [0] * n\n        right = [n - k] * n\n        for i in range(1, n - k):\n            left[i] = left[i - 1] if dp[i - 1] >= dp[left[i - 1]] else i - 1\n        for i in range(n - k - 2, -1, -1):\n            right[i] = right[i + 1] if dp[k + i] >= dp[right[i + 1]] else k + i\n        max_sum = 0\n        ans = [0, k, 2 * k]\n        for i in range(k, n - 2 * k):\n            cur_sum = dp[left[i - 1]] + dp[k + i - 1] + dp[right[k + i]]\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                ans = [left[i - 1], k + i - 1, right[k + i]]\n        return ans"}
{"generated_code": "class Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        freq = {}\n        for word in words:\n            freq[word] = freq.get(word, 0) + 1\n        heap = [(-f, w) for w, f in freq.items()]\n        heapq.heapify(heap)\n        return [heapq.heappop(heap)[1] for _ in range(k)]", "watermarked_code": "class Solution:\n    def topKFrequent(self, words: List[str], k: int) ->List[str]:\n        freq = {}\n        for word in words:\n            freq[word] = freq.get(word, 0) + 1\n        heap = [(-f, w) for w, f in freq.items()]\n        heapq.heapify(heap)\n        return [heapq.heappop(heap)[1] for _ in range(k)]"}
{"generated_code": "class Node:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.val = value\n        self.next = None\nclass MyHashMap:\n    def __init__(self):\n        self.size = 1000\n        self.table = [None] * self.size\n    def _hash(self, key):\n        return key % self.size\n    def put(self, key: int, value: int) -> None:\n        hash_val = self._hash(key)\n        if not self.table[hash_val]:\n            self.table[hash_val] = Node(key, value)\n        else:\n            cur = self.table[hash_val]\n            while True:\n                if cur.key == key:\n                    cur.value = value\n                    return\n                if not cur.next:\n                    break\n                cur = cur.next\n            cur.next = Node(key, value)\n    def get(self, key: int) -> int:\n        hash_val = self._hash(key)\n        if self.table[hash_val]:\n            cur = self.table[hash_val]\n            while cur:\n                if cur.key == key:\n                    return cur.value\n                cur = cur.next\n        return -1\n    def remove(self, key: int) -> None:\n        hash_val = self._hash(key)\n        if not self.table[hash_val]:\n            return\n        cur = prev = self.table[hash_val]\n        if cur.key == key:\n            self.table[hash_val] = cur.next\n        else:\n            cur = cur.next\n            while cur:\n                if cur.key == key:\n                    prev.next = cur.next\n                    return\n                cur, prev = cur.next, prev.next\nobj = MyHashMap()\nobj.put(1, 2)\nprint(obj.get(1))\nobj.remove(1)\nprint(obj.get(1))", "watermarked_code": "class Node:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.val = value\n        self.next = None\nclass MyHashMap:\n    def __init__(self):\n        self.size = 1000\n        self.table = [None] * self.size\n    def _hash(self, key):\n        return key % self.size\n    def put(self, key: int, value: int) ->None:\n        hash_val = self._hash(key)\n        if not self.table[hash_val]:\n            self.table[hash_val] = Node(key, value)\n        else:\n            cur = self.table[hash_val]\n            while True:\n                if cur.key == key:\n                    cur.value = value\n                    return\n                if not cur.next:\n                    break\n                cur = cur.next\n            cur.next = Node(key, value)\n    def get(self, key: int) ->int:\n        hash_val = self._hash(key)\n        if self.table[hash_val]:\n            cur = self.table[hash_val]\n            while cur:\n                if cur.key == key:\n                    return cur.value\n                cur = cur.next\n        return -1\n    def remove(self, key: int) ->None:\n        hash_val = self._hash(key)\n        if not self.table[hash_val]:\n            return\n        cur = prev = self.table[hash_val]\n        if cur.key == key:\n            self.table[hash_val] = cur.next\n        else:\n            cur = cur.next\n            while cur:\n                if cur.key == key:\n                    prev.next = cur.next\n                    return\n                cur, prev = cur.next, prev.next\nobj = MyHashMap()\nobj.put(1, 2)\nprint(obj.get(1))\nobj.remove(1)\nprint(obj.get(1))"}
{"generated_code": "class Solution:\n    def toLowerCase(self, s: str) -> str:\n        return ''.join(char.lower() if char.isupper() else char for char in s)", "watermarked_code": "class Solution:\n    def toLowerCase(self, s: str) ->str:\n        return ''.join(char.lower() if char.isupper() else char for char in s)"}
{"generated_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.index = set()\nclass WordFilter:\n    def __init__(self, words: List[str]):\n        self.prefix_trie = TrieNode()\n        self.suffix_trie = TrieNode()\n        for i in range(len(words)):\n            word = words[i]\n            self._add_word_to_trie(self.prefix_trie, word, i, is_prefix=True)\n            self._add_word_to_trie(self.suffix_trie, word[::-1], i,\n                is_prefix=False)\n    def _add_word_to_trie(self, trie, word, index, is_prefix):\n        node = trie\n        for i, char in enumerate(word):\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n            node.index.add(index)\n    def _get_indexes(self, trie, word):\n        node = trie\n        for char in word:\n            if char not in node.children:\n                return set()\n            node = node.children[char]\n        return node.index\n    def f(self, pref: str, suff: str) -> int:\n        prefix_indexes = self._get_indexes(self.prefix_trie, pref)\n        suffix_indexes = self._get_indexes(self.suffix_trie, suff[::-1])\n        matches = prefix_indexes.intersection(suffix_indexes)\n        return -1 if not matches else max(matches)", "watermarked_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.index = set()\nclass WordFilter:\n    def __init__(self, words: List[str]):\n        self.prefix_trie = TrieNode()\n        self.suffix_trie = TrieNode()\n        for i in range(len(words)):\n            word = words[i]\n            self._add_word_to_trie(self.prefix_trie, word, i, is_prefix=True)\n            self._add_word_to_trie(self.suffix_trie, word[::-1], i,\n                is_prefix=False)\n    def _add_word_to_trie(self, trie, word, index, is_prefix):\n        node = trie\n        for i, char in enumerate(word):\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n            node.index.add(index)\n    def _get_indexes(self, trie, word):\n        node = trie\n        for char in word:\n            if char not in node.children:\n                return set()\n            node = node.children[char]\n        return node.index\n    def f(self, pref: str, suff: str) ->int:\n        prefix_indexes = self._get_indexes(self.prefix_trie, pref)\n        suffix_indexes = self._get_indexes(self.suffix_trie, suff[::-1])\n        matches = prefix_indexes.intersection(suffix_indexes)\n        return max(matches) if matches else -1"}
{"generated_code": "class Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        m, n = len(isInfected), len(isInfected[0])\n        walls_built = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def get_viral_area(i, j, area_num):\n            if isInfected[i][j] != 1 or isInfected[i][j] == area_num:\n                return\n            isInfected[i][j] = area_num\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    get_viral_area(ni, nj, area_num)\n        def get_surrounding_walls(i, j):\n            wall_count = 0\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj and isInfected[ni\n                        ][nj] == -1:\n                    wall_count += 1\n            return wall_count\n        def build_walls(i, j):\n            wall_count = 0\n            areas_to_quarantine = set()\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    if isInfected[ni][nj] == 0:\n                        wall_count += 1\n                        isInfected[ni][nj] = -1\n                    elif isInfected[ni][nj] > 0:\n                        areas_to_quarantine.add(isInfected[ni][nj])\n            return wall_count, areas_to_quarantine\n        while True:\n            areas = {}\n            area_num = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        get_viral_area(i, j, -area_num)\n                        if -area_num not in areas:\n                            areas[-area_num] = {'size': 0, 'walls': 0,\n                                'cells': set()}\n                        areas[-area_num]['size'] += 1\n                        areas[-area_num]['cells'].add((i, j))\n                        area_num += 1\n            if not areas:\n                break\n            largest_area = max(areas.values(), key=lambda x: x['size'])\n            area_cells = largest_area['cells']\n            for i, j in area_cells:\n                walls_built += get_surrounding_walls(i, j)\n            for i, j in area_cells:\n                isInfected[i][j] = -1\n            largest_area['walls'] = build_walls(*area_cells.pop())\n            walls_built += largest_area['walls'][0]\n            new_areas = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for di, dj in directions:\n                            ni, nj = di + i, j + dj\n                            if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                                if isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                                    if -isInfected[i][j] not in new_areas:\n                                        new_areas[-isInfected[i][j]] = {'size':\n                                            0, 'walls': 0, 'cells': set()}\n                                    new_areas[-isInfected[i][j]]['size'] += 1\n                                    new_areas[-isInfected[i][j]]['cells'].add((\n                                        ni, nj))\n                                elif isInfected[ni][nj] == -1:\n                                    if -isInfected[i][j] in areas:\n                                        areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n                                    else:\n                                        new_areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n            for area_num in list(areas.keys()):\n                if areas[area_num]['walls'] < 0:\n                    areas_to_quarantine = areas[area_num]['walls'][1]\n                    for new_area_num in areas_to_quarantine:\n                        areas[new_area_num] = {'size': 0, 'walls': 0,\n                            'cells': set()}\n                        for i, j in areas[-new_area_num]['cells']:\n                            if isInfected[i][j] == -area_num:\n                                isInfected[i][j] = new_area_num\n                                areas[new_area_num]['size'] += 1\n                                areas[-area_num]['size'] -= 1\n                                areas[new_area_num]['cells'].add((i, j))\n                                areas[-area_num]['cells'].remove((i, j))\n            areas.update(new_areas)\n        return walls_built", "watermarked_code": "class Solution:\n    def containVirus(self, isInfected: List[List[int]]) ->int:\n        m, n = len(isInfected), len(isInfected[0])\n        walls_built = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def get_viral_area(i, j, area_num):\n            if isInfected[i][j] != 1 or isInfected[i][j] == area_num:\n                return\n            isInfected[i][j] = area_num\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    get_viral_area(ni, nj, area_num)\n        def get_surrounding_walls(i, j):\n            wall_count = 0\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj and isInfected[ni\n                        ][nj] == -1:\n                    wall_count += 1\n            return wall_count\n        def build_walls(i, j):\n            wall_count = 0\n            areas_to_quarantine = set()\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    if isInfected[ni][nj] == 0:\n                        wall_count += 1\n                        isInfected[ni][nj] = -1\n                    elif isInfected[ni][nj] > 0:\n                        areas_to_quarantine.add(isInfected[ni][nj])\n            return wall_count, areas_to_quarantine\n        while True:\n            areas = {}\n            area_num = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        get_viral_area(i, j, -area_num)\n                        if -area_num not in areas:\n                            areas[-area_num] = {'size': 0, 'walls': 0,\n                                'cells': set()}\n                        areas[-area_num]['size'] += 1\n                        areas[-area_num]['cells'].add((i, j))\n                        area_num += 1\n            if not areas:\n                break\n            largest_area = max(areas.values(), key=lambda x: x['size'])\n            area_cells = largest_area['cells']\n            for i, j in area_cells:\n                walls_built += get_surrounding_walls(i, j)\n            for i, j in area_cells:\n                isInfected[i][j] = -1\n            largest_area['walls'] = build_walls(*area_cells.pop())\n            walls_built += largest_area['walls'][0]\n            new_areas = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for di, dj in directions:\n                            ni, nj = di + i, j + dj\n                            if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                                if isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                                    if -isInfected[i][j] not in new_areas:\n                                        new_areas[-isInfected[i][j]] = {'size':\n                                            0, 'walls': 0, 'cells': set()}\n                                    new_areas[-isInfected[i][j]]['size'] += 1\n                                    new_areas[-isInfected[i][j]]['cells'].add((\n                                        ni, nj))\n                                elif isInfected[ni][nj] == -1:\n                                    if -isInfected[i][j] in areas:\n                                        areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n                                    else:\n                                        new_areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n            for area_num in list(areas.keys()):\n                if areas[area_num]['walls'] < 0:\n                    areas_to_quarantine = areas[area_num]['walls'][1]\n                    for new_area_num in areas_to_quarantine:\n                        areas[new_area_num] = {'size': 0, 'walls': 0,\n                            'cells': set()}\n                        for i, j in areas[-new_area_num]['cells']:\n                            if isInfected[i][j] == -area_num:\n                                isInfected[i][j] = new_area_num\n                                areas[new_area_num]['size'] += 1\n                                areas[-area_num]['size'] -= 1\n                                areas[new_area_num]['cells'].add((i, j))\n                                areas[-area_num]['cells'].remove((i, j))\n            areas.update(new_areas)\n        return walls_built"}
{"generated_code": "class Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        m, n = len(isInfected), len(isInfected[0])\n        walls_built = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def get_viral_area(i, j, area_num):\n            if isInfected[i][j] != 1 or isInfected[i][j] == area_num:\n                return\n            isInfected[i][j] = area_num\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    get_viral_area(ni, nj, area_num)\n        def get_surrounding_walls(i, j):\n            wall_count = 0\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj and isInfected[ni\n                        ][nj] == -1:\n                    wall_count += 1\n            return wall_count\n        def build_walls(i, j):\n            wall_count = 0\n            areas_to_quarantine = set()\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    if isInfected[ni][nj] == 0:\n                        wall_count += 1\n                        isInfected[ni][nj] = -1\n                    elif isInfected[ni][nj] > 0:\n                        areas_to_quarantine.add(isInfected[ni][nj])\n            return wall_count, areas_to_quarantine\n        while True:\n            areas = {}\n            area_num = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        get_viral_area(i, j, -area_num)\n                        if -area_num not in areas:\n                            areas[-area_num] = {'size': 0, 'walls': 0,\n                                'cells': set()}\n                        areas[-area_num]['size'] += 1\n                        areas[-area_num]['cells'].add((i, j))\n                        area_num += 1\n            if not areas:\n                break\n            largest_area = max(areas.values(), key=lambda x: x['size'])\n            area_cells = largest_area['cells']\n            for i, j in area_cells:\n                walls_built += get_surrounding_walls(i, j)\n            for i, j in area_cells:\n                isInfected[i][j] = -1\n            largest_area['walls'] = build_walls(*area_cells.pop())\n            walls_built += largest_area['walls'][0]\n            new_areas = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for di, dj in directions:\n                            ni, nj = di + i, j + dj\n                            if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                                if isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                                    if -isInfected[i][j] not in new_areas:\n                                        new_areas[-isInfected[i][j]] = {'size':\n                                            0, 'walls': 0, 'cells': set()}\n                                    new_areas[-isInfected[i][j]]['size'] += 1\n                                    new_areas[-isInfected[i][j]]['cells'].add((\n                                        ni, nj))\n                                elif isInfected[ni][nj] == -1:\n                                    if -isInfected[i][j] in areas:\n                                        areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n                                    else:\n                                        new_areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n            for area_num in list(areas.keys()):\n                if areas[area_num]['walls'] < 0:\n                    areas_to_quarantine = areas[area_num]['walls'][1]\n                    for new_area_num in areas_to_quarantine:\n                        areas[new_area_num] = {'size': 0, 'walls': 0,\n                            'cells': set()}\n                        for i, j in areas[-new_area_num]['cells']:\n                            if isInfected[i][j] == -area_num:\n                                isInfected[i][j] = new_area_num\n                                areas[new_area_num]['size'] += 1\n                                areas[-area_num]['size'] -= 1\n                                areas[new_area_num]['cells'].add((i, j))\n                                areas[-area_num]['cells'].remove((i, j))\n            areas.update(new_areas)\n        return walls_built", "watermarked_code": "class Solution:\n    def containVirus(self, isInfected: List[List[int]]) ->int:\n        m, n = len(isInfected), len(isInfected[0])\n        walls_built = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def get_viral_area(i, j, area_num):\n            if isInfected[i][j] != 1 or isInfected[i][j] == area_num:\n                return\n            isInfected[i][j] = area_num\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    get_viral_area(ni, nj, area_num)\n        def get_surrounding_walls(i, j):\n            wall_count = 0\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj and isInfected[ni\n                        ][nj] == -1:\n                    wall_count += 1\n            return wall_count\n        def build_walls(i, j):\n            wall_count = 0\n            areas_to_quarantine = set()\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    if isInfected[ni][nj] == 0:\n                        wall_count += 1\n                        isInfected[ni][nj] = -1\n                    elif isInfected[ni][nj] > 0:\n                        areas_to_quarantine.add(isInfected[ni][nj])\n            return wall_count, areas_to_quarantine\n        while True:\n            areas = {}\n            area_num = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        get_viral_area(i, j, -area_num)\n                        if -area_num not in areas:\n                            areas[-area_num] = {'size': 0, 'walls': 0,\n                                'cells': set()}\n                        areas[-area_num]['size'] += 1\n                        areas[-area_num]['cells'].add((i, j))\n                        area_num += 1\n            if not areas:\n                break\n            largest_area = max(areas.values(), key=lambda x: x['size'])\n            area_cells = largest_area['cells']\n            for i, j in area_cells:\n                walls_built += get_surrounding_walls(i, j)\n            for i, j in area_cells:\n                isInfected[i][j] = -1\n            largest_area['walls'] = build_walls(*area_cells.pop())\n            walls_built += largest_area['walls'][0]\n            new_areas = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for di, dj in directions:\n                            ni, nj = di + i, j + dj\n                            if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                                if isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                                    if -isInfected[i][j] not in new_areas:\n                                        new_areas[-isInfected[i][j]] = {'size':\n                                            0, 'walls': 0, 'cells': set()}\n                                    new_areas[-isInfected[i][j]]['size'] += 1\n                                    new_areas[-isInfected[i][j]]['cells'].add((\n                                        ni, nj))\n                                elif isInfected[ni][nj] == -1:\n                                    if -isInfected[i][j] in areas:\n                                        areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n                                    else:\n                                        new_areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n            for area_num in list(areas.keys()):\n                if areas[area_num]['walls'] < 0:\n                    areas_to_quarantine = areas[area_num]['walls'][1]\n                    for new_area_num in areas_to_quarantine:\n                        areas[new_area_num] = {'size': 0, 'walls': 0,\n                            'cells': set()}\n                        for i, j in areas[-new_area_num]['cells']:\n                            if isInfected[i][j] == -area_num:\n                                isInfected[i][j] = new_area_num\n                                areas[new_area_num]['size'] += 1\n                                areas[-area_num]['size'] -= 1\n                                areas[new_area_num]['cells'].add((i, j))\n                                areas[-area_num]['cells'].remove((i, j))\n            areas.update(new_areas)\n        return walls_built"}
{"generated_code": "class Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        m, n = len(isInfected), len(isInfected[0])\n        walls_built = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def get_viral_area(i, j, area_num):\n            if isInfected[i][j] != 1 or isInfected[i][j] == area_num:\n                return\n            isInfected[i][j] = area_num\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    get_viral_area(ni, nj, area_num)\n        def get_surrounding_walls(i, j):\n            wall_count = 0\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj and isInfected[ni\n                        ][nj] == -1:\n                    wall_count += 1\n            return wall_count\n        def build_walls(i, j):\n            wall_count = 0\n            areas_to_quarantine = set()\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    if isInfected[ni][nj] == 0:\n                        wall_count += 1\n                        isInfected[ni][nj] = -1\n                    elif isInfected[ni][nj] > 0:\n                        areas_to_quarantine.add(isInfected[ni][nj])\n            return wall_count, areas_to_quarantine\n        while True:\n            areas = {}\n            area_num = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        get_viral_area(i, j, -area_num)\n                        if -area_num not in areas:\n                            areas[-area_num] = {'size': 0, 'walls': 0,\n                                'cells': set()}\n                        areas[-area_num]['size'] += 1\n                        areas[-area_num]['cells'].add((i, j))\n                        area_num += 1\n            if not areas:\n                break\n            largest_area = max(areas.values(), key=lambda x: x['size'])\n            area_cells = largest_area['cells']\n            for i, j in area_cells:\n                walls_built += get_surrounding_walls(i, j)\n            for i, j in area_cells:\n                isInfected[i][j] = -1\n            largest_area['walls'] = build_walls(*area_cells.pop())\n            walls_built += largest_area['walls'][0]\n            new_areas = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for di, dj in directions:\n                            ni, nj = di + i, j + dj\n                            if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                                if isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                                    if -isInfected[i][j] not in new_areas:\n                                        new_areas[-isInfected[i][j]] = {'size':\n                                            0, 'walls': 0, 'cells': set()}\n                                    new_areas[-isInfected[i][j]]['size'] += 1\n                                    new_areas[-isInfected[i][j]]['cells'].add((\n                                        ni, nj))\n                                elif isInfected[ni][nj] == -1:\n                                    if -isInfected[i][j] in areas:\n                                        areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n                                    else:\n                                        new_areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n            for area_num in list(areas.keys()):\n                if areas[area_num]['walls'] < 0:\n                    areas_to_quarantine = areas[area_num]['walls'][1]\n                    for new_area_num in areas_to_quarantine:\n                        areas[new_area_num] = {'size': 0, 'walls': 0,\n                            'cells': set()}\n                        for i, j in areas[-new_area_num]['cells']:\n                            if isInfected[i][j] == -area_num:\n                                isInfected[i][j] = new_area_num\n                                areas[new_area_num]['size'] += 1\n                                areas[-area_num]['size'] -= 1\n                                areas[new_area_num]['cells'].add((i, j))\n                                areas[-area_num]['cells'].remove((i, j))\n            areas.update(new_areas)\n        return walls_built", "watermarked_code": "class Solution:\n    def containVirus(self, isInfected: List[List[int]]) ->int:\n        m, n = len(isInfected), len(isInfected[0])\n        walls_built = 0\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def get_viral_area(i, j, area_num):\n            if isInfected[i][j] != 1 or isInfected[i][j] == area_num:\n                return\n            isInfected[i][j] = area_num\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    get_viral_area(ni, nj, area_num)\n        def get_surrounding_walls(i, j):\n            wall_count = 0\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj and isInfected[ni\n                        ][nj] == -1:\n                    wall_count += 1\n            return wall_count\n        def build_walls(i, j):\n            wall_count = 0\n            areas_to_quarantine = set()\n            for di, dj in directions:\n                ni, nj = di + i, j + dj\n                if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                    if isInfected[ni][nj] == 0:\n                        wall_count += 1\n                        isInfected[ni][nj] = -1\n                    elif isInfected[ni][nj] > 0:\n                        areas_to_quarantine.add(isInfected[ni][nj])\n            return wall_count, areas_to_quarantine\n        while True:\n            areas = {}\n            area_num = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        get_viral_area(i, j, -area_num)\n                        if -area_num not in areas:\n                            areas[-area_num] = {'size': 0, 'walls': 0,\n                                'cells': set()}\n                        areas[-area_num]['size'] += 1\n                        areas[-area_num]['cells'].add((i, j))\n                        area_num += 1\n            if not areas:\n                break\n            largest_area = max(areas.values(), key=lambda x: x['size'])\n            area_cells = largest_area['cells']\n            for i, j in area_cells:\n                walls_built += get_surrounding_walls(i, j)\n            for i, j in area_cells:\n                isInfected[i][j] = -1\n            largest_area['walls'] = build_walls(*area_cells.pop())\n            walls_built += largest_area['walls'][0]\n            new_areas = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for di, dj in directions:\n                            ni, nj = di + i, j + dj\n                            if ni >= 0 and ni < m and nj >= 0 and n > nj:\n                                if isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                                    if -isInfected[i][j] not in new_areas:\n                                        new_areas[-isInfected[i][j]] = {'size':\n                                            0, 'walls': 0, 'cells': set()}\n                                    new_areas[-isInfected[i][j]]['size'] += 1\n                                    new_areas[-isInfected[i][j]]['cells'].add((\n                                        ni, nj))\n                                elif isInfected[ni][nj] == -1:\n                                    if -isInfected[i][j] in areas:\n                                        areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n                                    else:\n                                        new_areas[-isInfected[i][j]]['walls'] -= 1\n                                        largest_area['walls'][1].add(-\n                                            isInfected[i][j])\n            for area_num in list(areas.keys()):\n                if areas[area_num]['walls'] < 0:\n                    areas_to_quarantine = areas[area_num]['walls'][1]\n                    for new_area_num in areas_to_quarantine:\n                        areas[new_area_num] = {'size': 0, 'walls': 0,\n                            'cells': set()}\n                        for i, j in areas[-new_area_num]['cells']:\n                            if isInfected[i][j] == -area_num:\n                                isInfected[i][j] = new_area_num\n                                areas[new_area_num]['size'] += 1\n                                areas[-area_num]['size'] -= 1\n                                areas[new_area_num]['cells'].add((i, j))\n                                areas[-area_num]['cells'].remove((i, j))\n            areas.update(new_areas)\n        return walls_built"}
{"generated_code": "class Solution:\n    def reorganizeString(self, s: str) -> str:\n        freq = {}\n        for char in s:\n            freq[char] = freq.get(char, 0) + 1\n        sorted_chars = sorted(freq, key=freq.get, reverse=True)\n        if freq[sorted_chars[0]] > (len(s) + 1) // 2:\n            return ''\n        result = ''.join(sorted_chars[0] for _ in range(freq[sorted_chars[0]]))\n        for char in sorted_chars[1:]:\n            for i in range(freq[char]):\n                result = char + result if len(result) <= i else result[:i\n                    ] + char + result[i:]\n        return result", "watermarked_code": "class Solution:\n    def reorganizeString(self, s: str) ->str:\n        freq = {}\n        for char in s:\n            freq[char] = freq.get(char, 0) + 1\n        sorted_chars = sorted(freq, key=freq.get, reverse=True)\n        if freq[sorted_chars[0]] > (len(s) + 1) // 2:\n            return ''\n        result = ''.join(sorted_chars[0] for _ in range(freq[sorted_chars[0]]))\n        for char in sorted_chars[1:]:\n            for i in range(freq[char]):\n                result = char + result if len(result) <= i else result[:i\n                    ] + char + result[i:]\n        return result"}
{"generated_code": "class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str],\n            evalints: List[int]) -> List[str]:\n        evalMap = {}\n        for i in range(len(evalvars)):\n            evalMap[evalvars[i]] = evalints[i]\n        def parse(expr):\n            operands, operators = [], []\n            i = 0\n            while i < len(expr):\n                if expr[i].isalnum():\n                    j = i\n                    while j < len(expr) and expr[j].isalnum():\n                        j += 1\n                    operands.append(expr[i:j])\n                    i = j\n                elif expr[i] in '+-*':\n                    operators.append(expr[i])\n                    i += 1\n                elif expr[i] == '(':\n                    count, j = 1, i + 1\n                    while count > 0:\n                        if expr[j] == '(':\n                            count += 1\n                        elif expr[j] == ')':\n                            count -= 1\n                        j += 1\n                    operands.append(parse(expr[i + 1:j - 1]))\n                    i = j\n                else:\n                    i += 1\n            return operands, operators\n        operands, operators = parse(expression)\n        def combine_terms(terms):\n            d = {}\n            for term in terms:\n                c, v = term[0], tuple(sorted(term[1]))\n                count = d.get(v, [0])[0]\n                d[v] = [c + count, len(v)]\n            return [(str(d[k][0]) + '*' + '*'.join(k) if d[k][0] != 0 else\n                '') for d_list in sorted(d.items(), key=lambda x: (-x[1][1],\n                x[1][0], x[0])) for k in [d_list[0]]]\n        def eval(operands, operators):\n            if not operands:\n                return []\n            if type(operands) is str:\n                if operands in evalMap:\n                    operands = str(evalMap[operands])\n                    return [] if operands == '0' else [(int(operands), [])]\n                else:\n                    return [(1, [operands])]\n            if len(operands) == 1:\n                return [(1, operands[0])]\n            p = -1\n            for i in range(len(operators)):\n                if operators[i] in ['+', '-']:\n                    p = i\n                    break\n            if p == -1:\n                return eval(operands[0], []) + eval(operands[1], [])\n            op1, op2 = operands[:p], operands[p + 1:]\n            opr1, opr2 = operators[:p], operators[p + 1:]\n            if operators[p] == '+':\n                return eval(op1, opr1) + eval(op2, opr2)\n            else:\n                return eval(op1, opr1) + [(-c, v) for c, v in eval(op2, opr2)]\n        terms = eval(operands, operators)\n        return combine_terms(terms)", "watermarked_code": "class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str],\n            evalints: List[int]) ->List[str]:\n        evalMap = {}\n        for i in range(len(evalvars)):\n            evalMap[evalvars[i]] = evalints[i]\n        def parse(expr):\n            operands, operators = [], []\n            i = 0\n            while i < len(expr):\n                if expr[i].isalnum():\n                    j = i\n                    while j < len(expr) and expr[j].isalnum():\n                        j += 1\n                    operands.append(expr[i:j])\n                    i = j\n                elif expr[i] in '+-*':\n                    operators.append(expr[i])\n                    i += 1\n                elif expr[i] == '(':\n                    count, j = 1, i + 1\n                    while count > 0:\n                        if expr[j] == '(':\n                            count += 1\n                        elif expr[j] == ')':\n                            count -= 1\n                        j += 1\n                    operands.append(parse(expr[i + 1:j - 1]))\n                    i = j\n                else:\n                    i += 1\n            return operands, operators\n        operands, operators = parse(expression)\n        def combine_terms(terms):\n            d = {}\n            for term in terms:\n                c, v = term[0], tuple(sorted(term[1]))\n                count = d.get(v, [0])[0]\n                d[v] = [c + count, len(v)]\n            return [(f'{str(d[k][0])}*' + '*'.join(k) if d[k][0] != 0 else\n                '') for d_list in sorted(d.items(), key=lambda x: (-x[1][1],\n                x[1][0], x[0])) for k in [d_list[0]]]\n        def eval(operands, operators):\n            if not operands:\n                return []\n            if type(operands) is str:\n                if operands in evalMap:\n                    operands = str(evalMap[operands])\n                    return [] if operands == '0' else [(int(operands), [])]\n                else:\n                    return [(1, [operands])]\n            if len(operands) == 1:\n                return [(1, operands[0])]\n            p = -1\n            for i in range(len(operators)):\n                if operators[i] in ['+', '-']:\n                    p = i\n                    break\n            if p == -1:\n                return eval(operands[0], []) + eval(operands[1], [])\n            op1, op2 = operands[:p], operands[p + 1:]\n            opr1, opr2 = operators[:p], operators[p + 1:]\n            if operators[p] == '+':\n                return eval(op1, opr1) + eval(op2, opr2)\n            else:\n                return eval(op1, opr1) + [(-c, v) for c, v in eval(op2, opr2)]\n        terms = eval(operands, operators)\n        return combine_terms(terms)"}
{"generated_code": "class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str],\n            evalints: List[int]) -> List[str]:\n        evalMap = {}\n        for i in range(len(evalvars)):\n            evalMap[evalvars[i]] = evalints[i]\n        def parse(expr):\n            operands, operators = [], []\n            i = 0\n            while i < len(expr):\n                if expr[i].isalnum():\n                    j = i\n                    while j < len(expr) and expr[j].isalnum():\n                        j += 1\n                    operands.append(expr[i:j])\n                    i = j\n                elif expr[i] in '+-*':\n                    operators.append(expr[i])\n                    i += 1\n                elif expr[i] == '(':\n                    count, j = 1, i + 1\n                    while count > 0:\n                        if expr[j] == '(':\n                            count += 1\n                        elif expr[j] == ')':\n                            count -= 1\n                        j += 1\n                    operands.append(parse(expr[i + 1:j - 1]))\n                    i = j\n                else:\n                    i += 1\n            return operands, operators\n        operands, operators = parse(expression)\n        def combine_terms(terms):\n            d = {}\n            for term in terms:\n                c, v = term[0], tuple(sorted(term[1]))\n                count = d.get(v, [0])[0]\n                d[v] = [c + count, len(v)]\n            return [(str(d[k][0]) + '*' + '*'.join(k) if d[k][0] != 0 else\n                '') for d_list in sorted(d.items(), key=lambda x: (-x[1][1],\n                x[1][0], x[0])) for k in [d_list[0]]]\n        def eval(operands, operators):\n            if not operands:\n                return []\n            if type(operands) is str:\n                if operands in evalMap:\n                    operands = str(evalMap[operands])\n                    return [] if operands == '0' else [(int(operands), [])]\n                else:\n                    return [(1, [operands])]\n            if len(operands) == 1:\n                return [(1, operands[0])]\n            p = -1\n            for i in range(len(operators)):\n                if operators[i] in ['+', '-']:\n                    p = i\n                    break\n            if p == -1:\n                return eval(operands[0], []) + eval(operands[1], [])\n            op1, op2 = operands[:p], operands[p + 1:]\n            opr1, opr2 = operators[:p], operators[p + 1:]\n            if operators[p] == '+':\n                return eval(op1, opr1) + eval(op2, opr2)\n            else:\n                return eval(op1, opr1) + [(-c, v) for c, v in eval(op2, opr2)]\n        terms = eval(operands, operators)\n        return combine_terms(terms)", "watermarked_code": "class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str],\n            evalints: List[int]) ->List[str]:\n        evalMap = {}\n        for i in range(len(evalvars)):\n            evalMap[evalvars[i]] = evalints[i]\n        def parse(expr):\n            operands, operators = [], []\n            i = 0\n            while i < len(expr):\n                if expr[i].isalnum():\n                    j = i\n                    while j < len(expr) and expr[j].isalnum():\n                        j += 1\n                    operands.append(expr[i:j])\n                    i = j\n                elif expr[i] in '+-*':\n                    operators.append(expr[i])\n                    i += 1\n                elif expr[i] == '(':\n                    count, j = 1, i + 1\n                    while count > 0:\n                        if expr[j] == '(':\n                            count += 1\n                        elif expr[j] == ')':\n                            count -= 1\n                        j += 1\n                    operands.append(parse(expr[i + 1:j - 1]))\n                    i = j\n                else:\n                    i += 1\n            return operands, operators\n        operands, operators = parse(expression)\n        def combine_terms(terms):\n            d = {}\n            for term in terms:\n                c, v = term[0], tuple(sorted(term[1]))\n                count = d.get(v, [0])[0]\n                d[v] = [c + count, len(v)]\n            return [(f'{str(d[k][0])}*' + '*'.join(k) if d[k][0] != 0 else\n                '') for d_list in sorted(d.items(), key=lambda x: (-x[1][1],\n                x[1][0], x[0])) for k in [d_list[0]]]\n        def eval(operands, operators):\n            if not operands:\n                return []\n            if type(operands) is str:\n                if operands in evalMap:\n                    operands = str(evalMap[operands])\n                    return [] if operands == '0' else [(int(operands), [])]\n                else:\n                    return [(1, [operands])]\n            if len(operands) == 1:\n                return [(1, operands[0])]\n            p = -1\n            for i in range(len(operators)):\n                if operators[i] in ['+', '-']:\n                    p = i\n                    break\n            if p == -1:\n                return eval(operands[0], []) + eval(operands[1], [])\n            op1, op2 = operands[:p], operands[p + 1:]\n            opr1, opr2 = operators[:p], operators[p + 1:]\n            if operators[p] == '+':\n                return eval(op1, opr1) + eval(op2, opr2)\n            else:\n                return eval(op1, opr1) + [(-c, v) for c, v in eval(op2, opr2)]\n        terms = eval(operands, operators)\n        return combine_terms(terms)"}
{"generated_code": "class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str],\n            evalints: List[int]) -> List[str]:\n        evalMap = {}\n        for i in range(len(evalvars)):\n            evalMap[evalvars[i]] = evalints[i]\n        def parse(expr):\n            operands, operators = [], []\n            i = 0\n            while i < len(expr):\n                if expr[i].isalnum():\n                    j = i\n                    while j < len(expr) and expr[j].isalnum():\n                        j += 1\n                    operands.append(expr[i:j])\n                    i = j\n                elif expr[i] in '+-*':\n                    operators.append(expr[i])\n                    i += 1\n                elif expr[i] == '(':\n                    count, j = 1, i + 1\n                    while count > 0:\n                        if expr[j] == '(':\n                            count += 1\n                        elif expr[j] == ')':\n                            count -= 1\n                        j += 1\n                    operands.append(parse(expr[i + 1:j - 1]))\n                    i = j\n                else:\n                    i += 1\n            return operands, operators\n        operands, operators = parse(expression)\n        def combine_terms(terms):\n            d = {}\n            for term in terms:\n                c, v = term[0], tuple(sorted(term[1]))\n                count = d.get(v, [0])[0]\n                d[v] = [c + count, len(v)]\n            return [(str(d[k][0]) + '*' + '*'.join(k) if d[k][0] != 0 else\n                '') for d_list in sorted(d.items(), key=lambda x: (-x[1][1],\n                x[1][0], x[0])) for k in [d_list[0]]]\n        def eval(operands, operators):\n            if not operands:\n                return []\n            if type(operands) is str:\n                if operands in evalMap:\n                    operands = str(evalMap[operands])\n                    return [] if operands == '0' else [(int(operands), [])]\n                else:\n                    return [(1, [operands])]\n            if len(operands) == 1:\n                return [(1, operands[0])]\n            p = -1\n            for i in range(len(operators)):\n                if operators[i] in ['+', '-']:\n                    p = i\n                    break\n            if p == -1:\n                return eval(operands[0], []) + eval(operands[1], [])\n            op1, op2 = operands[:p], operands[p + 1:]\n            opr1, opr2 = operators[:p], operators[p + 1:]\n            if operators[p] == '+':\n                return eval(op1, opr1) + eval(op2, opr2)\n            else:\n                return eval(op1, opr1) + [(-c, v) for c, v in eval(op2, opr2)]\n        terms = eval(operands, operators)\n        return combine_terms(terms)", "watermarked_code": "class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str],\n            evalints: List[int]) ->List[str]:\n        evalMap = {}\n        for i in range(len(evalvars)):\n            evalMap[evalvars[i]] = evalints[i]\n        def parse(expr):\n            operands, operators = [], []\n            i = 0\n            while i < len(expr):\n                if expr[i].isalnum():\n                    j = i\n                    while j < len(expr) and expr[j].isalnum():\n                        j += 1\n                    operands.append(expr[i:j])\n                    i = j\n                elif expr[i] in '+-*':\n                    operators.append(expr[i])\n                    i += 1\n                elif expr[i] == '(':\n                    count, j = 1, i + 1\n                    while count > 0:\n                        if expr[j] == '(':\n                            count += 1\n                        elif expr[j] == ')':\n                            count -= 1\n                        j += 1\n                    operands.append(parse(expr[i + 1:j - 1]))\n                    i = j\n                else:\n                    i += 1\n            return operands, operators\n        operands, operators = parse(expression)\n        def combine_terms(terms):\n            d = {}\n            for term in terms:\n                c, v = term[0], tuple(sorted(term[1]))\n                count = d.get(v, [0])[0]\n                d[v] = [c + count, len(v)]\n            return [(f'{str(d[k][0])}*' + '*'.join(k) if d[k][0] != 0 else\n                '') for d_list in sorted(d.items(), key=lambda x: (-x[1][1],\n                x[1][0], x[0])) for k in [d_list[0]]]\n        def eval(operands, operators):\n            if not operands:\n                return []\n            if type(operands) is str:\n                if operands in evalMap:\n                    operands = str(evalMap[operands])\n                    return [] if operands == '0' else [(int(operands), [])]\n                else:\n                    return [(1, [operands])]\n            if len(operands) == 1:\n                return [(1, operands[0])]\n            p = -1\n            for i in range(len(operators)):\n                if operators[i] in ['+', '-']:\n                    p = i\n                    break\n            if p == -1:\n                return eval(operands[0], []) + eval(operands[1], [])\n            op1, op2 = operands[:p], operands[p + 1:]\n            opr1, opr2 = operators[:p], operators[p + 1:]\n            if operators[p] == '+':\n                return eval(op1, opr1) + eval(op2, opr2)\n            else:\n                return eval(op1, opr1) + [(-c, v) for c, v in eval(op2, opr2)]\n        terms = eval(operands, operators)\n        return combine_terms(terms)"}
{"generated_code": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        n = len(board)\n        row_sum = sum(board[0])\n        col_sum = sum(board[i][0] for i in range(n))\n        if row_sum not in [n // 2, (n + 1) // 2] or col_sum not in [n // 2,\n                (n + 1) // 2]:\n            return -1\n        row_swap = col_swap = row_diff = col_diff = 0\n        for i in range(n):\n            if board[i][0] == i % 2:\n                row_swap += 1\n            if board[0][i] == i % 2:\n                col_swap += 1\n            if board[i][0] != i % 2:\n                row_diff += 1\n            if board[0][i] != i % 2:\n                col_diff += 1\n        if n % 2 == 1:\n            if row_diff % 2 == 1:\n                row_diff = n - row_diff\n            if col_diff % 2 == 1:\n                col_diff = n - col_diff\n            row_swap = row_diff // 2\n            col_swap = col_diff // 2\n        else:\n            row_swap = min(row_swap, n - row_swap)\n            col_swap = min(col_swap, n - col_swap)\n        return (col_swap + row_swap) // 2", "watermarked_code": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) ->int:\n        n = len(board)\n        row_sum = sum(board[0])\n        col_sum = sum(board[i][0] for i in range(n))\n        if row_sum not in [n // 2, (n + 1) // 2] or col_sum not in [n // 2,\n                (n + 1) // 2]:\n            return -1\n        row_swap = col_swap = row_diff = col_diff = 0\n        for i in range(n):\n            if board[i][0] == i % 2:\n                row_swap += 1\n            if board[0][i] == i % 2:\n                col_swap += 1\n            if board[i][0] != i % 2:\n                row_diff += 1\n            if board[0][i] != i % 2:\n                col_diff += 1\n        if n % 2 == 1:\n            if row_diff % 2 == 1:\n                row_diff = n - row_diff\n            if col_diff % 2 == 1:\n                col_diff = n - col_diff\n            row_swap = row_diff // 2\n            col_swap = col_diff // 2\n        else:\n            row_swap = min(row_swap, n - row_swap)\n            col_swap = min(col_swap, n - col_swap)\n        return (col_swap + row_swap) // 2"}
{"generated_code": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        n = len(board)\n        row_sum = sum(board[0])\n        col_sum = sum(board[i][0] for i in range(n))\n        if row_sum not in [n // 2, (n + 1) // 2] or col_sum not in [n // 2,\n                (n + 1) // 2]:\n            return -1\n        row_swap = col_swap = row_diff = col_diff = 0\n        for i in range(n):\n            if board[i][0] == i % 2:\n                row_swap += 1\n            if board[0][i] == i % 2:\n                col_swap += 1\n            if board[i][0] != i % 2:\n                row_diff += 1\n            if board[0][i] != i % 2:\n                col_diff += 1\n        if n % 2 == 1:\n            if row_diff % 2 == 1:\n                row_diff = n - row_diff\n            if col_diff % 2 == 1:\n                col_diff = n - col_diff\n            row_swap = row_diff // 2\n            col_swap = col_diff // 2\n        else:\n            row_swap = min(row_swap, n - row_swap)\n            col_swap = min(col_swap, n - col_swap)\n        return (col_swap + row_swap) // 2", "watermarked_code": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) ->int:\n        n = len(board)\n        row_sum = sum(board[0])\n        col_sum = sum(board[i][0] for i in range(n))\n        if row_sum not in [n // 2, (n + 1) // 2] or col_sum not in [n // 2,\n                (n + 1) // 2]:\n            return -1\n        row_swap = col_swap = row_diff = col_diff = 0\n        for i in range(n):\n            if board[i][0] == i % 2:\n                row_swap += 1\n            if board[0][i] == i % 2:\n                col_swap += 1\n            if board[i][0] != i % 2:\n                row_diff += 1\n            if board[0][i] != i % 2:\n                col_diff += 1\n        if n % 2 == 1:\n            if row_diff % 2 == 1:\n                row_diff = n - row_diff\n            if col_diff % 2 == 1:\n                col_diff = n - col_diff\n            row_swap = row_diff // 2\n            col_swap = col_diff // 2\n        else:\n            row_swap = min(row_swap, n - row_swap)\n            col_swap = min(col_swap, n - col_swap)\n        return (col_swap + row_swap) // 2"}
{"generated_code": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        n = len(board)\n        row_sum = sum(board[0])\n        col_sum = sum(board[i][0] for i in range(n))\n        if row_sum not in [n // 2, (n + 1) // 2] or col_sum not in [n // 2,\n                (n + 1) // 2]:\n            return -1\n        row_swap = col_swap = row_diff = col_diff = 0\n        for i in range(n):\n            if board[i][0] == i % 2:\n                row_swap += 1\n            if board[0][i] == i % 2:\n                col_swap += 1\n            if board[i][0] != i % 2:\n                row_diff += 1\n            if board[0][i] != i % 2:\n                col_diff += 1\n        if n % 2 == 1:\n            if row_diff % 2 == 1:\n                row_diff = n - row_diff\n            if col_diff % 2 == 1:\n                col_diff = n - col_diff\n            row_swap = row_diff // 2\n            col_swap = col_diff // 2\n        else:\n            row_swap = min(row_swap, n - row_swap)\n            col_swap = min(col_swap, n - col_swap)\n        return (col_swap + row_swap) // 2", "watermarked_code": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) ->int:\n        n = len(board)\n        row_sum = sum(board[0])\n        col_sum = sum(board[i][0] for i in range(n))\n        if row_sum not in [n // 2, (n + 1) // 2] or col_sum not in [n // 2,\n                (n + 1) // 2]:\n            return -1\n        row_swap = col_swap = row_diff = col_diff = 0\n        for i in range(n):\n            if board[i][0] == i % 2:\n                row_swap += 1\n            if board[0][i] == i % 2:\n                col_swap += 1\n            if board[i][0] != i % 2:\n                row_diff += 1\n            if board[0][i] != i % 2:\n                col_diff += 1\n        if n % 2 == 1:\n            if row_diff % 2 == 1:\n                row_diff = n - row_diff\n            if col_diff % 2 == 1:\n                col_diff = n - col_diff\n            row_swap = row_diff // 2\n            col_swap = col_diff // 2\n        else:\n            row_swap = min(row_swap, n - row_swap)\n            col_swap = min(col_swap, n - col_swap)\n        return (col_swap + row_swap) // 2"}
{"generated_code": "class Solution:\n    def validTicTacToe(self, board: List[str]) -> bool:\n        x_count, o_count = 0, 0\n        for row in board:\n            x_count += row.count('X')\n            o_count += row.count('O')\n        if x_count > o_count or x_count - o_count > 1:\n            return False\n        x_win = self.check_win(board, 'X')\n        o_win = self.check_win(board, 'O')\n        return (not x_win or not o_win) and (not x_win or x_count != o_count\n            ) and (not o_win or x_count <= o_count)\n    def check_win(self, board: List[str], char: str) -> bool:\n        for row in board:\n            if row == char * 3:\n                return True\n        for i in range(3):\n            if board[0][i] == board[1][i] == board[2][i] == char:\n                return True\n        if board[0][0] == board[1][1] == board[2][2] == char:\n            return True\n        elif board[0][2] == board[1][1] == board[2][0] == char:\n            return True\n        return False", "watermarked_code": "class Solution:\n    def validTicTacToe(self, board: List[str]) ->bool:\n        x_count, o_count = 0, 0\n        for row in board:\n            x_count += row.count('X')\n            o_count += row.count('O')\n        if x_count > o_count or x_count - o_count > 1:\n            return False\n        x_win = self.check_win(board, 'X')\n        o_win = self.check_win(board, 'O')\n        return (not x_win or not o_win) and (not x_win or x_count != o_count\n            ) and (not o_win or x_count <= o_count)\n    def check_win(self, board: List[str], char: str) ->bool:\n        for row in board:\n            if row == char * 3:\n                return True\n        for i in range(3):\n            if board[0][i] == board[1][i] == board[2][i] == char:\n                return True\n        if board[0][0] == board[1][1] == board[2][2] == char:\n            return True\n        elif board[0][2] == board[1][1] == board[2][0] == char:\n            return True\n        return False"}
{"generated_code": "class Solution:\n    def champagneTower(self, poured: int, query_row: int, query_glass: int\n            ) -> float:\n        levels = [[poured]]\n        for i in range(query_row + 1):\n            curr_level = []\n            for j in range(i + 1):\n                if j in [0, i]:\n                    overflow = max(0, (levels[i][j] - 1) / 2)\n                else:\n                    overflow = max(0, (levels[i][j] - 2) / 2)\n                curr_level.append(overflow)\n                if i == query_row and j == query_glass:\n                    return min(1, levels[i][j])\n                if query_row > i:\n                    if j == 0:\n                        levels.append([overflow, 0])\n                    else:\n                        levels[i + 1].append(overflow)", "watermarked_code": "class Solution:\n    def champagneTower(self, poured: int, query_row: int, query_glass: int\n            ) ->float:\n        levels = [[poured]]\n        for i in range(query_row + 1):\n            curr_level = []\n            for j in range(i + 1):\n                if j in [0, i]:\n                    overflow = max(0, (levels[i][j] - 1) / 2)\n                else:\n                    overflow = max(0, (levels[i][j] - 2) / 2)\n                curr_level.append(overflow)\n                if i == query_row and j == query_glass:\n                    return min(1, levels[i][j])\n                if query_row > i:\n                    if j == 0:\n                        levels.append([overflow, 0])\n                    else:\n                        levels[i + 1].append(overflow)"}
{"generated_code": "class Solution:\n    def champagneTower(self, poured: int, query_row: int, query_glass: int\n            ) -> float:\n        levels = [[poured]]\n        for i in range(query_row + 1):\n            curr_level = []\n            for j in range(i + 1):\n                if j in [0, i]:\n                    overflow = max(0, (levels[i][j] - 1) / 2)\n                else:\n                    overflow = max(0, (levels[i][j] - 2) / 2)\n                curr_level.append(overflow)\n                if i == query_row and j == query_glass:\n                    return min(1, levels[i][j])\n                if query_row > i:\n                    if j == 0:\n                        levels.append([overflow, 0])\n                    else:\n                        levels[i + 1].append(overflow)", "watermarked_code": "class Solution:\n    def champagneTower(self, poured: int, query_row: int, query_glass: int\n            ) ->float:\n        levels = [[poured]]\n        for i in range(query_row + 1):\n            curr_level = []\n            for j in range(i + 1):\n                if j in [0, i]:\n                    overflow = max(0, (levels[i][j] - 1) / 2)\n                else:\n                    overflow = max(0, (levels[i][j] - 2) / 2)\n                curr_level.append(overflow)\n                if i == query_row and j == query_glass:\n                    return min(1, levels[i][j])\n                if query_row > i:\n                    if j == 0:\n                        levels.append([overflow, 0])\n                    else:\n                        levels[i + 1].append(overflow)"}
{"generated_code": "class Solution:\n    def xorGame(self, nums: List[int]) -> bool:\n        if len(nums) % 2 != 0:\n            return True\n        xor = 0\n        for num in nums:\n            xor ^= num\n        return True if xor == 0 else any(num % 2 == 0 for num in nums)", "watermarked_code": "class Solution:\n    def xorGame(self, nums: List[int]) ->bool:\n        if len(nums) % 2 != 0:\n            return True\n        xor = 0\n        for num in nums:\n            xor ^= num\n        return True if xor == 0 else any(num % 2 == 0 for num in nums)"}
{"generated_code": "class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        if rec1[2] <= rec2[0] or rec2[2] <= rec1[0]:\n            return False\n        return rec1[3] > rec2[1] and rec2[3] > rec1[1]", "watermarked_code": "class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) ->bool:\n        if rec1[2] <= rec2[0] or rec2[2] <= rec1[0]:\n            return False\n        return rec1[3] > rec2[1] and rec2[3] > rec1[1]"}
{"generated_code": "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize != 0:\n            return False\n        cardCounts = Counter(hand)\n        sortedCards = sorted(cardCounts.keys())\n        for card in sortedCards:\n            count = cardCounts[card]\n            if count > 0:\n                cardCounts[card] -= 1\n                remainingCards = groupSize - 1\n                for nextCard in range(card + 1, groupSize + card):\n                    if cardCounts[nextCard] < count:\n                        return False\n                    cardCounts[nextCard] -= count\n                    remainingCards -= 1\n                if remainingCards == 0:\n                    continue\n                for remainingCard in sortedCards:\n                    if cardCounts[remainingCard\n                            ] >= count and remainingCard > card:\n                        card = remainingCard\n                        cardCounts[remainingCard] -= count\n                        remainingCards -= 1\n                        if remainingCards == 0:\n                            break\n                if remainingCards != 0:\n                    return False\n        return True", "watermarked_code": "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) ->bool:\n        if len(hand) % groupSize != 0:\n            return False\n        cardCounts = Counter(hand)\n        sortedCards = sorted(cardCounts.keys())\n        for card in sortedCards:\n            count = cardCounts[card]\n            if count > 0:\n                cardCounts[card] -= 1\n                remainingCards = groupSize - 1\n                for nextCard in range(card + 1, groupSize + card):\n                    if cardCounts[nextCard] < count:\n                        return False\n                    cardCounts[nextCard] -= count\n                    remainingCards -= 1\n                if remainingCards == 0:\n                    continue\n                for remainingCard in sortedCards:\n                    if cardCounts[remainingCard\n                            ] >= count and remainingCard > card:\n                        card = remainingCard\n                        cardCounts[remainingCard] -= count\n                        remainingCards -= 1\n                        if remainingCards == 0:\n                            break\n                if remainingCards != 0:\n                    return False\n        return True"}
{"generated_code": "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize != 0:\n            return False\n        cardCounts = Counter(hand)\n        sortedCards = sorted(cardCounts.keys())\n        for card in sortedCards:\n            count = cardCounts[card]\n            if count > 0:\n                cardCounts[card] -= 1\n                remainingCards = groupSize - 1\n                for nextCard in range(card + 1, groupSize + card):\n                    if cardCounts[nextCard] < count:\n                        return False\n                    cardCounts[nextCard] -= count\n                    remainingCards -= 1\n                if remainingCards == 0:\n                    continue\n                for remainingCard in sortedCards:\n                    if cardCounts[remainingCard\n                            ] >= count and remainingCard > card:\n                        card = remainingCard\n                        cardCounts[remainingCard] -= count\n                        remainingCards -= 1\n                        if remainingCards == 0:\n                            break\n                if remainingCards != 0:\n                    return False\n        return True", "watermarked_code": "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) ->bool:\n        if len(hand) % groupSize != 0:\n            return False\n        cardCounts = Counter(hand)\n        sortedCards = sorted(cardCounts.keys())\n        for card in sortedCards:\n            count = cardCounts[card]\n            if count > 0:\n                cardCounts[card] -= 1\n                remainingCards = groupSize - 1\n                for nextCard in range(card + 1, groupSize + card):\n                    if cardCounts[nextCard] < count:\n                        return False\n                    cardCounts[nextCard] -= count\n                    remainingCards -= 1\n                if remainingCards == 0:\n                    continue\n                for remainingCard in sortedCards:\n                    if cardCounts[remainingCard\n                            ] >= count and remainingCard > card:\n                        card = remainingCard\n                        cardCounts[remainingCard] -= count\n                        remainingCards -= 1\n                        if remainingCards == 0:\n                            break\n                if remainingCards != 0:\n                    return False\n        return True"}
{"generated_code": "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize != 0:\n            return False\n        cardCounts = Counter(hand)\n        sortedCards = sorted(cardCounts.keys())\n        for card in sortedCards:\n            count = cardCounts[card]\n            if count > 0:\n                cardCounts[card] -= 1\n                remainingCards = groupSize - 1\n                for nextCard in range(card + 1, groupSize + card):\n                    if cardCounts[nextCard] < count:\n                        return False\n                    cardCounts[nextCard] -= count\n                    remainingCards -= 1\n                if remainingCards == 0:\n                    continue\n                for remainingCard in sortedCards:\n                    if cardCounts[remainingCard\n                            ] >= count and remainingCard > card:\n                        card = remainingCard\n                        cardCounts[remainingCard] -= count\n                        remainingCards -= 1\n                        if remainingCards == 0:\n                            break\n                if remainingCards != 0:\n                    return False\n        return True", "watermarked_code": "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) ->bool:\n        if len(hand) % groupSize != 0:\n            return False\n        cardCounts = Counter(hand)\n        sortedCards = sorted(cardCounts.keys())\n        for card in sortedCards:\n            count = cardCounts[card]\n            if count > 0:\n                cardCounts[card] -= 1\n                remainingCards = groupSize - 1\n                for nextCard in range(card + 1, groupSize + card):\n                    if cardCounts[nextCard] < count:\n                        return False\n                    cardCounts[nextCard] -= count\n                    remainingCards -= 1\n                if remainingCards == 0:\n                    continue\n                for remainingCard in sortedCards:\n                    if cardCounts[remainingCard\n                            ] >= count and remainingCard > card:\n                        card = remainingCard\n                        cardCounts[remainingCard] -= count\n                        remainingCards -= 1\n                        if remainingCards == 0:\n                            break\n                if remainingCards != 0:\n                    return False\n        return True"}
{"generated_code": "class Solution:\n    def isPrime(num):\n        return False if num in [1, 0] else all(num % n != 0 for n in range(\n            2, num))\n    def primePalindrome(self, n: int) -> int:\n        if n > 8 and n <= 11:\n            return 11\n        for num in range(max(n, 11), 10 ** 8):\n            if str(num) == str(num)[::-1] and self.isPrime(num):\n                return num", "watermarked_code": "class Solution:\n    def isPrime(self):\n        return False if self in [1, 0] else all(num % n != 0 for n in range\n            (2, num))\n    def primePalindrome(self, n: int) ->int:\n        if n > 8 and n <= 11:\n            return 11\n        for num in range(max(n, 11), 10 ** 8):\n            if str(num) == str(num)[::-1] and self.isPrime(num):\n                return num"}
{"generated_code": "class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int],\n            profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [([0] * (len(profit) + 1)) for _ in range(minProfit + 1)]\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n        for idx, (g, p) in enumerate(zip(group, profit)):\n            for i in range(minProfit, -1, -1):\n                for _ in range(n, g - 1, -1):\n                    dp[min(minProfit, p + i)][idx + 1] = (dp[min(minProfit,\n                        p + i)][idx + 1] + dp[i][idx]) % MOD\n        return sum(dp[i][-1] for i in range(minProfit + 1)) % MOD", "watermarked_code": "class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int],\n            profit: List[int]) ->int:\n        MOD = 10 ** 9 + 7\n        dp = [([0] * (len(profit) + 1)) for _ in range(minProfit + 1)]\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n        for idx, (g, p) in enumerate(zip(group, profit)):\n            for i in range(minProfit, -1, -1):\n                for _ in range(n, g - 1, -1):\n                    dp[min(minProfit, p + i)][idx + 1] = (dp[min(minProfit,\n                        p + i)][idx + 1] + dp[i][idx]) % MOD\n        return sum(dp[i][-1] for i in range(minProfit + 1)) % MOD"}
{"generated_code": "class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int],\n            profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [([0] * (len(profit) + 1)) for _ in range(minProfit + 1)]\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n        for idx, (g, p) in enumerate(zip(group, profit)):\n            for i in range(minProfit, -1, -1):\n                for _ in range(n, g - 1, -1):\n                    dp[min(minProfit, p + i)][idx + 1] = (dp[min(minProfit,\n                        p + i)][idx + 1] + dp[i][idx]) % MOD\n        return sum(dp[i][-1] for i in range(minProfit + 1)) % MOD", "watermarked_code": "class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int],\n            profit: List[int]) ->int:\n        MOD = 10 ** 9 + 7\n        dp = [([0] * (len(profit) + 1)) for _ in range(minProfit + 1)]\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n        for idx, (g, p) in enumerate(zip(group, profit)):\n            for i in range(minProfit, -1, -1):\n                for _ in range(n, g - 1, -1):\n                    dp[min(minProfit, p + i)][idx + 1] = (dp[min(minProfit,\n                        p + i)][idx + 1] + dp[i][idx]) % MOD\n        return sum(dp[i][-1] for i in range(minProfit + 1)) % MOD"}
{"generated_code": "class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int],\n            profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [([0] * (len(profit) + 1)) for _ in range(minProfit + 1)]\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n        for idx, (g, p) in enumerate(zip(group, profit)):\n            for i in range(minProfit, -1, -1):\n                for _ in range(n, g - 1, -1):\n                    dp[min(minProfit, p + i)][idx + 1] = (dp[min(minProfit,\n                        p + i)][idx + 1] + dp[i][idx]) % MOD\n        return sum(dp[i][-1] for i in range(minProfit + 1)) % MOD", "watermarked_code": "class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int],\n            profit: List[int]) ->int:\n        MOD = 10 ** 9 + 7\n        dp = [([0] * (len(profit) + 1)) for _ in range(minProfit + 1)]\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n        for idx, (g, p) in enumerate(zip(group, profit)):\n            for i in range(minProfit, -1, -1):\n                for _ in range(n, g - 1, -1):\n                    dp[min(minProfit, p + i)][idx + 1] = (dp[min(minProfit,\n                        p + i)][idx + 1] + dp[i][idx]) % MOD\n        return sum(dp[i][-1] for i in range(minProfit + 1)) % MOD"}
{"generated_code": "class Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        word_dict = {}\n        s1_words = s1.split()\n        s2_words = s2.split()\n        for word in s1_words:\n            word_dict[word] = word not in word_dict\n        for word in s2_words:\n            word_dict[word] = word not in word_dict\n        return [word for word in word_dict.keys() if word_dict[word]]", "watermarked_code": "class Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) ->List[str]:\n        word_dict = {}\n        s1_words = s1.split()\n        s2_words = s2.split()\n        for word in s1_words:\n            word_dict[word] = word not in word_dict\n        for word in s2_words:\n            word_dict[word] = word not in word_dict\n        return [word for word in word_dict if word_dict[word]]"}
{"generated_code": "from typing import List\nclass Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int\n            ) -> List[List[int]]:\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[rStart, cStart]]\n        steps = 1\n        while len(result) < cols * rows:\n            rStart, cStart = rStart + direction[0][0], cStart + direction[0][1]\n            for d in direction:\n                if d == (-1, 0) and steps == rows or d == (0, -1\n                        ) and steps == cols:\n                    continue\n                for _ in range(steps):\n                    rStart, cStart = rStart + d[0], cStart + d[1]\n                    if (rStart >= 0 and rStart < rows and cStart >= 0 and \n                        cStart < cols):\n                        result.append([rStart, cStart])\n            steps += 1\n        return result", "watermarked_code": "from typing import List\nclass Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int\n            ) ->List[List[int]]:\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[rStart, cStart]]\n        steps = 1\n        while len(result) < cols * rows:\n            rStart, cStart = rStart + direction[0][0], cStart + direction[0][1]\n            for d in direction:\n                if d == (-1, 0) and steps == rows or d == (0, -1\n                        ) and steps == cols:\n                    continue\n                for _ in range(steps):\n                    rStart, cStart = rStart + d[0], cStart + d[1]\n                    if (rStart >= 0 and rStart < rows and cStart >= 0 and \n                        cStart < cols):\n                        result.append([rStart, cStart])\n            steps += 1\n        return result"}
{"generated_code": "from typing import List\nclass Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int\n            ) -> List[List[int]]:\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[rStart, cStart]]\n        steps = 1\n        while len(result) < cols * rows:\n            rStart, cStart = rStart + direction[0][0], cStart + direction[0][1]\n            for d in direction:\n                if d == (-1, 0) and steps == rows or d == (0, -1\n                        ) and steps == cols:\n                    continue\n                for _ in range(steps):\n                    rStart, cStart = rStart + d[0], cStart + d[1]\n                    if (rStart >= 0 and rStart < rows and cStart >= 0 and \n                        cStart < cols):\n                        result.append([rStart, cStart])\n            steps += 1\n        return result", "watermarked_code": "from typing import List\nclass Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int\n            ) ->List[List[int]]:\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[rStart, cStart]]\n        steps = 1\n        while len(result) < cols * rows:\n            rStart, cStart = rStart + direction[0][0], cStart + direction[0][1]\n            for d in direction:\n                if d == (-1, 0) and steps == rows or d == (0, -1\n                        ) and steps == cols:\n                    continue\n                for _ in range(steps):\n                    rStart, cStart = rStart + d[0], cStart + d[1]\n                    if (rStart >= 0 and rStart < rows and cStart >= 0 and \n                        cStart < cols):\n                        result.append([rStart, cStart])\n            steps += 1\n        return result"}
{"generated_code": "from typing import List\nclass Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int\n            ) -> List[List[int]]:\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[rStart, cStart]]\n        steps = 1\n        while len(result) < cols * rows:\n            rStart, cStart = rStart + direction[0][0], cStart + direction[0][1]\n            for d in direction:\n                if d == (-1, 0) and steps == rows or d == (0, -1\n                        ) and steps == cols:\n                    continue\n                for _ in range(steps):\n                    rStart, cStart = rStart + d[0], cStart + d[1]\n                    if (rStart >= 0 and rStart < rows and cStart >= 0 and \n                        cStart < cols):\n                        result.append([rStart, cStart])\n            steps += 1\n        return result", "watermarked_code": "from typing import List\nclass Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int\n            ) ->List[List[int]]:\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[rStart, cStart]]\n        steps = 1\n        while len(result) < cols * rows:\n            rStart, cStart = rStart + direction[0][0], cStart + direction[0][1]\n            for d in direction:\n                if d == (-1, 0) and steps == rows or d == (0, -1\n                        ) and steps == cols:\n                    continue\n                for _ in range(steps):\n                    rStart, cStart = rStart + d[0], cStart + d[1]\n                    if (rStart >= 0 and rStart < rows and cStart >= 0 and \n                        cStart < cols):\n                        result.append([rStart, cStart])\n            steps += 1\n        return result"}
{"generated_code": "class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str\n            ]:\n        matched_words = []\n        for word in words:\n            mapping = {}\n            match = True\n            for i in range(len(pattern)):\n                if pattern[i] not in mapping and word[i] not in mapping.values(\n                ):\n                    mapping[pattern[i]] = word[i]\n                elif pattern[i] in mapping and mapping[pattern[i]] != word[i]:\n                    match = False\n                    break\n                elif pattern[i] not in mapping:\n                    match = False\n                    break\n            if match:\n                matched_words.append(word)\n        return matched_words", "watermarked_code": "class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) ->List[str\n            ]:\n        matched_words = []\n        for word in words:\n            mapping = {}\n            match = True\n            for i in range(len(pattern)):\n                if pattern[i] not in mapping and word[i] not in mapping.values(\n                        ):\n                    mapping[pattern[i]] = word[i]\n                elif pattern[i] in mapping and mapping[pattern[i]] != word[i]:\n                    match = False\n                    break\n                elif pattern[i] not in mapping:\n                    match = False\n                    break\n            if match:\n                matched_words.append(word)\n        return matched_words"}
{"generated_code": "class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str\n            ]:\n        matched_words = []\n        for word in words:\n            mapping = {}\n            match = True\n            for i in range(len(pattern)):\n                if pattern[i] not in mapping and word[i] not in mapping.values(\n                ):\n                    mapping[pattern[i]] = word[i]\n                elif pattern[i] in mapping and mapping[pattern[i]] != word[i]:\n                    match = False\n                    break\n                elif pattern[i] not in mapping:\n                    match = False\n                    break\n            if match:\n                matched_words.append(word)\n        return matched_words", "watermarked_code": "class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) ->List[str\n            ]:\n        matched_words = []\n        for word in words:\n            mapping = {}\n            match = True\n            for i in range(len(pattern)):\n                if pattern[i] not in mapping and word[i] not in mapping.values(\n                        ):\n                    mapping[pattern[i]] = word[i]\n                elif pattern[i] in mapping and mapping[pattern[i]] != word[i]:\n                    match = False\n                    break\n                elif pattern[i] not in mapping:\n                    match = False\n                    break\n            if match:\n                matched_words.append(word)\n        return matched_words"}
{"generated_code": "class Solution:\n    def isSubset(self, a: str, b: str) -> bool:\n        \"\"\"\n        Checks if string b is a subset of a.\n        \"\"\"\n        return all(b.count(char) <= a.count(char) for char in set(b))\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        \"\"\"\n        Returns a list of universal strings from words1, i.e., strings containing all characters in words2.\n        \"\"\"\n        max_counts = {}\n        for b in words2:\n            b_counts = {char: b.count(char) for char in set(b)}\n            for char in b_counts:\n                if char not in max_counts:\n                    max_counts[char] = b_counts[char]\n                else:\n                    max_counts[char] = max(max_counts[char], b_counts[char])\n        return [a for a in words1 if all(a.count(char) >= count for char,\n            count in max_counts.items())]", "watermarked_code": "class Solution:\n    def isSubset(self, a: str, b: str) ->bool:\n        \"\"\"\n        Checks if string b is a subset of a.\n        \"\"\"\n        return all(b.count(char) <= a.count(char) for char in set(b))\n    def wordSubsets(self, words1: List[str], words2: List[str]) ->List[str]:\n        \"\"\"\n        Returns a list of universal strings from words1, i.e., strings containing all characters in words2.\n        \"\"\"\n        max_counts = {}\n        for b in words2:\n            b_counts = {char: b.count(char) for char in set(b)}\n            for char in b_counts:\n                if char not in max_counts:\n                    max_counts[char] = b_counts[char]\n                else:\n                    max_counts[char] = max(max_counts[char], b_counts[char])\n        return [a for a in words1 if all(a.count(char) >= count for char,\n            count in max_counts.items())]"}
{"generated_code": "class Solution:\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        total_ones = sum(arr)\n        if total_ones % 3 != 0:\n            return [-1, -1]\n        if total_ones == 0:\n            return [0, n - 1]\n        ones_in_each_part = total_ones // 3\n        idx = []\n        cnt = 0\n        for i in range(n):\n            if arr[i] == 1:\n                cnt += 1\n                if cnt in {1, ones_in_each_part + 1, 2 * ones_in_each_part + 1\n                        }:\n                    idx.append(i)\n                if cnt in {ones_in_each_part, 2 * ones_in_each_part, total_ones\n                        }:\n                    idx.append(i)\n        part1 = arr[idx[0]:idx[1] + 1]\n        part2 = arr[idx[2]:idx[3] + 1]\n        part3 = arr[idx[4]:idx[5] + 1]\n        return [idx[1], idx[3] + 1] if part1 == part2 == part3 else [-1, -1]", "watermarked_code": "class Solution:\n    def threeEqualParts(self, arr: List[int]) ->List[int]:\n        n = len(arr)\n        total_ones = sum(arr)\n        if total_ones % 3 != 0:\n            return [-1, -1]\n        if total_ones == 0:\n            return [0, n - 1]\n        ones_in_each_part = total_ones // 3\n        idx = []\n        cnt = 0\n        for i in range(n):\n            if arr[i] == 1:\n                cnt += 1\n                if cnt in {1, ones_in_each_part + 1, 2 * ones_in_each_part + 1\n                        }:\n                    idx.append(i)\n                if cnt in {ones_in_each_part, 2 * ones_in_each_part, total_ones\n                        }:\n                    idx.append(i)\n        part1 = arr[idx[0]:idx[1] + 1]\n        part2 = arr[idx[2]:idx[3] + 1]\n        part3 = arr[idx[4]:idx[5] + 1]\n        return [idx[1], idx[3] + 1] if part1 == part2 == part3 else [-1, -1]"}
{"generated_code": "class Solution:\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        total_ones = sum(arr)\n        if total_ones % 3 != 0:\n            return [-1, -1]\n        if total_ones == 0:\n            return [0, n - 1]\n        ones_in_each_part = total_ones // 3\n        idx = []\n        cnt = 0\n        for i in range(n):\n            if arr[i] == 1:\n                cnt += 1\n                if cnt in {1, ones_in_each_part + 1, 2 * ones_in_each_part + 1\n                        }:\n                    idx.append(i)\n                if cnt in {ones_in_each_part, 2 * ones_in_each_part, total_ones\n                        }:\n                    idx.append(i)\n        part1 = arr[idx[0]:idx[1] + 1]\n        part2 = arr[idx[2]:idx[3] + 1]\n        part3 = arr[idx[4]:idx[5] + 1]\n        return [idx[1], idx[3] + 1] if part1 == part2 == part3 else [-1, -1]", "watermarked_code": "class Solution:\n    def threeEqualParts(self, arr: List[int]) ->List[int]:\n        n = len(arr)\n        total_ones = sum(arr)\n        if total_ones % 3 != 0:\n            return [-1, -1]\n        if total_ones == 0:\n            return [0, n - 1]\n        ones_in_each_part = total_ones // 3\n        idx = []\n        cnt = 0\n        for i in range(n):\n            if arr[i] == 1:\n                cnt += 1\n                if cnt in {1, ones_in_each_part + 1, 2 * ones_in_each_part + 1\n                        }:\n                    idx.append(i)\n                if cnt in {ones_in_each_part, 2 * ones_in_each_part, total_ones\n                        }:\n                    idx.append(i)\n        part1 = arr[idx[0]:idx[1] + 1]\n        part2 = arr[idx[2]:idx[3] + 1]\n        part3 = arr[idx[4]:idx[5] + 1]\n        return [idx[1], idx[3] + 1] if part1 == part2 == part3 else [-1, -1]"}
{"generated_code": "from typing import List\nclass Solution:\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\n        max_time = -1\n        from itertools import permutations\n        for h1, h2, m1, m2 in permutations(arr):\n            hour = h1 * 10 + h2\n            if hour >= 24:\n                continue\n            minute = m1 * 10 + m2\n            if minute >= 60:\n                continue\n            curr_time = hour * 60 + minute\n            if max_time > curr_time:\n                max_time = curr_time\n                max_hour = hour\n                max_minute = minute\n        return '' if max_time == -1 else '{:02d}:{:02d}'.format(max_hour,\n            max_minute)", "watermarked_code": "from typing import List\nclass Solution:\n    def largestTimeFromDigits(self, arr: List[int]) ->str:\n        max_time = -1\n        from itertools import permutations\n        for h1, h2, m1, m2 in permutations(arr):\n            hour = h1 * 10 + h2\n            if hour >= 24:\n                continue\n            minute = m1 * 10 + m2\n            if minute >= 60:\n                continue\n            curr_time = hour * 60 + minute\n            if max_time > curr_time:\n                max_time = curr_time\n                max_hour = hour\n                max_minute = minute\n        return '' if max_time == -1 else '{:02d}:{:02d}'.format(max_hour,\n            max_minute)"}
{"generated_code": "from typing import List\nclass Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str\n            ]:\n        words = set(wordlist)\n        cap_dict = {}\n        vowel_dict = {}\n        def replace_vowels(word):\n            return ''.join([('*' if c in 'aeiouAEIOU' else c) for c in word])\n        for word in wordlist:\n            lower_word = word.lower()\n            if lower_word not in cap_dict:\n                cap_dict[lower_word] = word\n            vowel_word = replace_vowels(lower_word)\n            if vowel_word not in vowel_dict:\n                vowel_dict[vowel_word] = word\n        def get_correct_word(query):\n            if query in words:\n                return query\n            lower_query = query.lower()\n            if lower_query in cap_dict:\n                return cap_dict[lower_query]\n            vowel_query = replace_vowels(lower_query)\n            return vowel_dict[vowel_query] if vowel_query in vowel_dict else ''\n        result = []\n        for query in queries:\n            result.append(get_correct_word(query))\n        return result", "watermarked_code": "from typing import List\nclass Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) ->List[str\n            ]:\n        words = set(wordlist)\n        cap_dict = {}\n        vowel_dict = {}\n        def replace_vowels(word):\n            return ''.join([('*' if c in 'aeiouAEIOU' else c) for c in word])\n        for word in wordlist:\n            lower_word = word.lower()\n            if lower_word not in cap_dict:\n                cap_dict[lower_word] = word\n            vowel_word = replace_vowels(lower_word)\n            if vowel_word not in vowel_dict:\n                vowel_dict[vowel_word] = word\n        def get_correct_word(query):\n            if query in words:\n                return query\n            lower_query = query.lower()\n            if lower_query in cap_dict:\n                return cap_dict[lower_query]\n            vowel_query = replace_vowels(lower_query)\n            return vowel_dict[vowel_query] if vowel_query in vowel_dict else ''\n        result = []\n        for query in queries:\n            result.append(get_correct_word(query))\n        return result"}
{"generated_code": "from typing import List\nclass Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str\n            ]:\n        words = set(wordlist)\n        cap_dict = {}\n        vowel_dict = {}\n        def replace_vowels(word):\n            return ''.join([('*' if c in 'aeiouAEIOU' else c) for c in word])\n        for word in wordlist:\n            lower_word = word.lower()\n            if lower_word not in cap_dict:\n                cap_dict[lower_word] = word\n            vowel_word = replace_vowels(lower_word)\n            if vowel_word not in vowel_dict:\n                vowel_dict[vowel_word] = word\n        def get_correct_word(query):\n            if query in words:\n                return query\n            lower_query = query.lower()\n            if lower_query in cap_dict:\n                return cap_dict[lower_query]\n            vowel_query = replace_vowels(lower_query)\n            return vowel_dict[vowel_query] if vowel_query in vowel_dict else ''\n        result = []\n        for query in queries:\n            result.append(get_correct_word(query))\n        return result", "watermarked_code": "from typing import List\nclass Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) ->List[str\n            ]:\n        words = set(wordlist)\n        cap_dict = {}\n        vowel_dict = {}\n        def replace_vowels(word):\n            return ''.join([('*' if c in 'aeiouAEIOU' else c) for c in word])\n        for word in wordlist:\n            lower_word = word.lower()\n            if lower_word not in cap_dict:\n                cap_dict[lower_word] = word\n            vowel_word = replace_vowels(lower_word)\n            if vowel_word not in vowel_dict:\n                vowel_dict[vowel_word] = word\n        def get_correct_word(query):\n            if query in words:\n                return query\n            lower_query = query.lower()\n            if lower_query in cap_dict:\n                return cap_dict[lower_query]\n            vowel_query = replace_vowels(lower_query)\n            return vowel_dict[vowel_query] if vowel_query in vowel_dict else ''\n        result = []\n        for query in queries:\n            result.append(get_correct_word(query))\n        return result"}
{"generated_code": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 1\n        res = 1\n        temp = 2\n        for i in range(1, len(arr) - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1] or arr[i] < arr[\n                    i - 1] and arr[i] < arr[i + 1]:\n                temp += 1\n            else:\n                res = max(res, temp)\n                temp = 2 if arr[i] != arr[i + 1] else 1\n        return max(res, temp)", "watermarked_code": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) ->int:\n        if len(arr) == 1:\n            return 1\n        res = 1\n        temp = 2\n        for i in range(1, len(arr) - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1] or arr[i] < arr[\n                    i - 1] and arr[i] < arr[i + 1]:\n                temp += 1\n            else:\n                res = max(res, temp)\n                temp = 2 if arr[i] != arr[i + 1] else 1\n        return max(res, temp)"}
{"generated_code": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 1\n        res = 1\n        temp = 2\n        for i in range(1, len(arr) - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1] or arr[i] < arr[\n                    i - 1] and arr[i] < arr[i + 1]:\n                temp += 1\n            else:\n                res = max(res, temp)\n                temp = 2 if arr[i] != arr[i + 1] else 1\n        return max(res, temp)", "watermarked_code": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) ->int:\n        if len(arr) == 1:\n            return 1\n        res = 1\n        temp = 2\n        for i in range(1, len(arr) - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1] or arr[i] < arr[\n                    i - 1] and arr[i] < arr[i + 1]:\n                temp += 1\n            else:\n                res = max(res, temp)\n                temp = 2 if arr[i] != arr[i + 1] else 1\n        return max(res, temp)"}
{"generated_code": "class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        trusts_someone = set(a for a, b in trust)\n        trust_count = {}\n        for a, b in trust:\n            if b not in trusts_someone:\n                trust_count[b] = trust_count.get(b, 0) + 1\n        return next((p for p, value in trust_count.items() if value == n - \n            1), -1)", "watermarked_code": "class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) ->int:\n        trusts_someone = {a for a, b in trust}\n        trust_count = {}\n        for a, b in trust:\n            if b not in trusts_someone:\n                trust_count[b] = trust_count.get(b, 0) + 1\n        return next((p for p, value in trust_count.items() if value == n - \n            1), -1)"}
